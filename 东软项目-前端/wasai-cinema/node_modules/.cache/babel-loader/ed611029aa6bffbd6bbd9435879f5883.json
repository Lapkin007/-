{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _createClass = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _classCallCheck = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _inherits = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _defineProperty = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\n\nvar _class;\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n\nrequire(\"core-js/modules/es.array.splice.js\");\n\nvar WebSocket = require(\"ws\");\n\nvar BaseServer = require(\"./BaseServer\");\n/** @typedef {import(\"../Server\").WebSocketServerConfiguration} WebSocketServerConfiguration */\n\n/** @typedef {import(\"../Server\").ClientConnection} ClientConnection */\n\n\nmodule.exports = (_class = /*#__PURE__*/function (_BaseServer) {\n  _inherits(WebsocketServer, _BaseServer);\n\n  var _super = _createSuper(WebsocketServer);\n\n  /**\n   * @param {import(\"../Server\")} server\n   */\n  function WebsocketServer(server) {\n    var _this;\n\n    _classCallCheck(this, WebsocketServer);\n\n    _this = _super.call(this, server);\n    /** @type {import(\"ws\").ServerOptions} */\n\n    var options = _objectSpread(_objectSpread({},\n    /** @type {WebSocketServerConfiguration} */\n    _this.server.options.webSocketServer.options), {}, {\n      clientTracking: false\n    });\n\n    var isNoServerMode = typeof options.port === \"undefined\" && typeof options.server === \"undefined\";\n\n    if (isNoServerMode) {\n      options.noServer = true;\n    }\n\n    _this.implementation = new WebSocket.Server(options);\n    /** @type {import(\"http\").Server} */\n\n    _this.server.server.on(\"upgrade\",\n    /**\n     * @param {import(\"http\").IncomingMessage} req\n     * @param {import(\"stream\").Duplex} sock\n     * @param {Buffer} head\n     */\n    function (req, sock, head) {\n      if (!_this.implementation.shouldHandle(req)) {\n        return;\n      }\n\n      _this.implementation.handleUpgrade(req, sock, head, function (connection) {\n        _this.implementation.emit(\"connection\", connection, req);\n      });\n    });\n\n    _this.implementation.on(\"error\",\n    /**\n     * @param {Error} err\n     */\n    function (err) {\n      _this.server.logger.error(err.message);\n    });\n\n    var interval = setInterval(function () {\n      _this.clients.forEach(\n      /**\n       * @param {ClientConnection} client\n       */\n      function (client) {\n        if (client.isAlive === false) {\n          client.terminate();\n          return;\n        }\n\n        client.isAlive = false;\n        client.ping(function () {});\n      });\n    }, WebsocketServer.heartbeatInterval);\n\n    _this.implementation.on(\"connection\",\n    /**\n     * @param {ClientConnection} client\n     */\n    function (client) {\n      _this.clients.push(client);\n\n      client.isAlive = true;\n      client.on(\"pong\", function () {\n        client.isAlive = true;\n      });\n      client.on(\"close\", function () {\n        _this.clients.splice(_this.clients.indexOf(client), 1);\n      });\n    });\n\n    _this.implementation.on(\"close\", function () {\n      clearInterval(interval);\n    });\n\n    return _this;\n  }\n\n  return _createClass(WebsocketServer);\n}(BaseServer), _defineProperty(_class, \"heartbeatInterval\", 1000), _class);","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/webpack-dev-server/lib/servers/WebsocketServer.js"],"names":["WebSocket","require","BaseServer","module","exports","server","options","webSocketServer","clientTracking","isNoServerMode","port","noServer","implementation","Server","on","req","sock","head","shouldHandle","handleUpgrade","connection","emit","err","logger","error","message","interval","setInterval","clients","forEach","client","isAlive","terminate","ping","WebsocketServer","heartbeatInterval","push","splice","indexOf","clearInterval"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst WebSocket = require(\"ws\");\nconst BaseServer = require(\"./BaseServer\");\n\n/** @typedef {import(\"../Server\").WebSocketServerConfiguration} WebSocketServerConfiguration */\n/** @typedef {import(\"../Server\").ClientConnection} ClientConnection */\n\nmodule.exports = class WebsocketServer extends BaseServer {\n  static heartbeatInterval = 1000;\n\n  /**\n   * @param {import(\"../Server\")} server\n   */\n  constructor(server) {\n    super(server);\n\n    /** @type {import(\"ws\").ServerOptions} */\n    const options = {\n      .../** @type {WebSocketServerConfiguration} */\n      (this.server.options.webSocketServer).options,\n      clientTracking: false,\n    };\n    const isNoServerMode =\n      typeof options.port === \"undefined\" &&\n      typeof options.server === \"undefined\";\n\n    if (isNoServerMode) {\n      options.noServer = true;\n    }\n\n    this.implementation = new WebSocket.Server(options);\n\n    /** @type {import(\"http\").Server} */\n    (this.server.server).on(\n      \"upgrade\",\n      /**\n       * @param {import(\"http\").IncomingMessage} req\n       * @param {import(\"stream\").Duplex} sock\n       * @param {Buffer} head\n       */\n      (req, sock, head) => {\n        if (!this.implementation.shouldHandle(req)) {\n          return;\n        }\n\n        this.implementation.handleUpgrade(req, sock, head, (connection) => {\n          this.implementation.emit(\"connection\", connection, req);\n        });\n      }\n    );\n\n    this.implementation.on(\n      \"error\",\n      /**\n       * @param {Error} err\n       */\n      (err) => {\n        this.server.logger.error(err.message);\n      }\n    );\n\n    const interval = setInterval(() => {\n      this.clients.forEach(\n        /**\n         * @param {ClientConnection} client\n         */\n        (client) => {\n          if (client.isAlive === false) {\n            client.terminate();\n\n            return;\n          }\n\n          client.isAlive = false;\n          client.ping(() => {});\n        }\n      );\n    }, WebsocketServer.heartbeatInterval);\n\n    this.implementation.on(\n      \"connection\",\n      /**\n       * @param {ClientConnection} client\n       */\n      (client) => {\n        this.clients.push(client);\n\n        client.isAlive = true;\n\n        client.on(\"pong\", () => {\n          client.isAlive = true;\n        });\n\n        client.on(\"close\", () => {\n          this.clients.splice(this.clients.indexOf(client), 1);\n        });\n      }\n    );\n\n    this.implementation.on(\"close\", () => {\n      clearInterval(interval);\n    });\n  }\n};\n"]},"metadata":{},"sourceType":"script"}