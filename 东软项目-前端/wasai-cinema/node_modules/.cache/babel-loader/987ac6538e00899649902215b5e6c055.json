{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nrequire(\"regenerator-runtime/runtime.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.object.keys.js\");\n\nrequire(\"core-js/modules/es.array.filter.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.array.includes.js\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.string.replace.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.responseInterceptor = void 0;\n\nvar zlib = require(\"zlib\");\n/**\n * Intercept responses from upstream.\n * Automatically decompress (deflate, gzip, brotli).\n * Give developer the opportunity to modify intercepted Buffer and http.ServerResponse\n *\n * NOTE: must set options.selfHandleResponse=true (prevent automatic call of res.end())\n */\n\n\nfunction responseInterceptor(interceptor) {\n  return /*#__PURE__*/function () {\n    var _proxyRes2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(proxyRes, req, res) {\n      var originalProxyRes, buffer, _proxyRes;\n\n      return regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              originalProxyRes = proxyRes;\n              buffer = Buffer.from('', 'utf8'); // decompress proxy response\n\n              _proxyRes = decompress(proxyRes, proxyRes.headers['content-encoding']); // concat data stream\n\n              _proxyRes.on('data', function (chunk) {\n                return buffer = Buffer.concat([buffer, chunk]);\n              });\n\n              _proxyRes.on('end', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n                var interceptedBuffer;\n                return regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        // copy original headers\n                        copyHeaders(proxyRes, res); // call interceptor with intercepted response (buffer)\n\n                        _context.t0 = Buffer;\n                        _context.next = 4;\n                        return interceptor(buffer, originalProxyRes, req, res);\n\n                      case 4:\n                        _context.t1 = _context.sent;\n                        interceptedBuffer = _context.t0.from.call(_context.t0, _context.t1);\n                        // set correct content-length (with double byte character support)\n                        res.setHeader('content-length', Buffer.byteLength(interceptedBuffer, 'utf8'));\n                        res.write(interceptedBuffer);\n                        res.end();\n\n                      case 9:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              })));\n\n              _proxyRes.on('error', function (error) {\n                res.end(\"Error fetching proxied request: \".concat(error.message));\n              });\n\n            case 6:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    function proxyRes(_x, _x2, _x3) {\n      return _proxyRes2.apply(this, arguments);\n    }\n\n    return proxyRes;\n  }();\n}\n\nexports.responseInterceptor = responseInterceptor;\n/**\n * Streaming decompression of proxy response\n * source: https://github.com/apache/superset/blob/9773aba522e957ed9423045ca153219638a85d2f/superset-frontend/webpack.proxy-config.js#L116\n */\n\nfunction decompress(proxyRes, contentEncoding) {\n  var _proxyRes = proxyRes;\n  var decompress;\n\n  switch (contentEncoding) {\n    case 'gzip':\n      decompress = zlib.createGunzip();\n      break;\n\n    case 'br':\n      decompress = zlib.createBrotliDecompress();\n      break;\n\n    case 'deflate':\n      decompress = zlib.createInflate();\n      break;\n\n    default:\n      break;\n  }\n\n  if (decompress) {\n    _proxyRes.pipe(decompress);\n\n    _proxyRes = decompress;\n  }\n\n  return _proxyRes;\n}\n/**\n * Copy original headers\n * https://github.com/apache/superset/blob/9773aba522e957ed9423045ca153219638a85d2f/superset-frontend/webpack.proxy-config.js#L78\n */\n\n\nfunction copyHeaders(originalResponse, response) {\n  response.statusCode = originalResponse.statusCode;\n  response.statusMessage = originalResponse.statusMessage;\n\n  if (response.setHeader) {\n    var keys = Object.keys(originalResponse.headers); // ignore chunked, brotli, gzip, deflate headers\n\n    keys = keys.filter(function (key) {\n      return !['content-encoding', 'transfer-encoding'].includes(key);\n    });\n    keys.forEach(function (key) {\n      var value = originalResponse.headers[key];\n\n      if (key === 'set-cookie') {\n        // remove cookie domain\n        value = Array.isArray(value) ? value : [value];\n        value = value.map(function (x) {\n          return x.replace(/Domain=[^;]+?/i, '');\n        });\n      }\n\n      response.setHeader(key, value);\n    });\n  } else {\n    response.headers = originalResponse.headers;\n  }\n}","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/http-proxy-middleware/dist/handlers/response-interceptor.js"],"names":["Object","defineProperty","exports","value","responseInterceptor","zlib","require","interceptor","proxyRes","req","res","originalProxyRes","buffer","Buffer","from","_proxyRes","decompress","headers","on","chunk","concat","copyHeaders","interceptedBuffer","setHeader","byteLength","write","end","error","message","contentEncoding","createGunzip","createBrotliDecompress","createInflate","pipe","originalResponse","response","statusCode","statusMessage","keys","filter","key","includes","forEach","Array","isArray","map","x","replace"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.responseInterceptor = void 0;\nconst zlib = require(\"zlib\");\n/**\n * Intercept responses from upstream.\n * Automatically decompress (deflate, gzip, brotli).\n * Give developer the opportunity to modify intercepted Buffer and http.ServerResponse\n *\n * NOTE: must set options.selfHandleResponse=true (prevent automatic call of res.end())\n */\nfunction responseInterceptor(interceptor) {\n    return async function proxyRes(proxyRes, req, res) {\n        const originalProxyRes = proxyRes;\n        let buffer = Buffer.from('', 'utf8');\n        // decompress proxy response\n        const _proxyRes = decompress(proxyRes, proxyRes.headers['content-encoding']);\n        // concat data stream\n        _proxyRes.on('data', (chunk) => (buffer = Buffer.concat([buffer, chunk])));\n        _proxyRes.on('end', async () => {\n            // copy original headers\n            copyHeaders(proxyRes, res);\n            // call interceptor with intercepted response (buffer)\n            const interceptedBuffer = Buffer.from(await interceptor(buffer, originalProxyRes, req, res));\n            // set correct content-length (with double byte character support)\n            res.setHeader('content-length', Buffer.byteLength(interceptedBuffer, 'utf8'));\n            res.write(interceptedBuffer);\n            res.end();\n        });\n        _proxyRes.on('error', (error) => {\n            res.end(`Error fetching proxied request: ${error.message}`);\n        });\n    };\n}\nexports.responseInterceptor = responseInterceptor;\n/**\n * Streaming decompression of proxy response\n * source: https://github.com/apache/superset/blob/9773aba522e957ed9423045ca153219638a85d2f/superset-frontend/webpack.proxy-config.js#L116\n */\nfunction decompress(proxyRes, contentEncoding) {\n    let _proxyRes = proxyRes;\n    let decompress;\n    switch (contentEncoding) {\n        case 'gzip':\n            decompress = zlib.createGunzip();\n            break;\n        case 'br':\n            decompress = zlib.createBrotliDecompress();\n            break;\n        case 'deflate':\n            decompress = zlib.createInflate();\n            break;\n        default:\n            break;\n    }\n    if (decompress) {\n        _proxyRes.pipe(decompress);\n        _proxyRes = decompress;\n    }\n    return _proxyRes;\n}\n/**\n * Copy original headers\n * https://github.com/apache/superset/blob/9773aba522e957ed9423045ca153219638a85d2f/superset-frontend/webpack.proxy-config.js#L78\n */\nfunction copyHeaders(originalResponse, response) {\n    response.statusCode = originalResponse.statusCode;\n    response.statusMessage = originalResponse.statusMessage;\n    if (response.setHeader) {\n        let keys = Object.keys(originalResponse.headers);\n        // ignore chunked, brotli, gzip, deflate headers\n        keys = keys.filter((key) => !['content-encoding', 'transfer-encoding'].includes(key));\n        keys.forEach((key) => {\n            let value = originalResponse.headers[key];\n            if (key === 'set-cookie') {\n                // remove cookie domain\n                value = Array.isArray(value) ? value : [value];\n                value = value.map((x) => x.replace(/Domain=[^;]+?/i, ''));\n            }\n            response.setHeader(key, value);\n        });\n    }\n    else {\n        response.headers = originalResponse.headers;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}