{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _inherits = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _createForOfIteratorHelper = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nrequire(\"core-js/modules/es.map.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.set.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.array.join.js\");\n\nvar fs = require(\"fs\");\n\nvar path = require(\"path\");\n\nvar _require = require(\"events\"),\n    EventEmitter = _require.EventEmitter;\n\nvar reducePlan = require(\"./reducePlan\");\n\nvar IS_OSX = require(\"os\").platform() === \"darwin\";\nvar IS_WIN = require(\"os\").platform() === \"win32\";\nvar SUPPORTS_RECURSIVE_WATCHING = IS_OSX || IS_WIN;\nvar watcherLimit = +process.env.WATCHPACK_WATCHER_LIMIT || (IS_OSX ? 2000 : 10000);\nvar recursiveWatcherLogging = !!process.env.WATCHPACK_RECURSIVE_WATCHER_LOGGING;\nvar isBatch = false;\nvar watcherCount = 0;\n/** @type {Map<Watcher, string>} */\n\nvar pendingWatchers = new Map();\n/** @type {Map<string, RecursiveWatcher>} */\n\nvar recursiveWatchers = new Map();\n/** @type {Map<string, DirectWatcher>} */\n\nvar directWatchers = new Map();\n/** @type {Map<Watcher, RecursiveWatcher | DirectWatcher>} */\n\nvar underlyingWatcher = new Map();\n\nvar DirectWatcher = /*#__PURE__*/function () {\n  function DirectWatcher(filePath) {\n    var _this = this;\n\n    _classCallCheck(this, DirectWatcher);\n\n    this.filePath = filePath;\n    this.watchers = new Set();\n    this.watcher = undefined;\n\n    try {\n      var watcher = fs.watch(filePath);\n      this.watcher = watcher;\n      watcher.on(\"change\", function (type, filename) {\n        var _iterator = _createForOfIteratorHelper(_this.watchers),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var w = _step.value;\n            w.emit(\"change\", type, filename);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      });\n      watcher.on(\"error\", function (error) {\n        var _iterator2 = _createForOfIteratorHelper(_this.watchers),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var w = _step2.value;\n            w.emit(\"error\", error);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      });\n    } catch (err) {\n      process.nextTick(function () {\n        var _iterator3 = _createForOfIteratorHelper(_this.watchers),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var w = _step3.value;\n            w.emit(\"error\", err);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      });\n    }\n\n    watcherCount++;\n  }\n\n  _createClass(DirectWatcher, [{\n    key: \"add\",\n    value: function add(watcher) {\n      underlyingWatcher.set(watcher, this);\n      this.watchers.add(watcher);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(watcher) {\n      this.watchers.delete(watcher);\n\n      if (this.watchers.size === 0) {\n        directWatchers.delete(this.filePath);\n        watcherCount--;\n        if (this.watcher) this.watcher.close();\n      }\n    }\n  }, {\n    key: \"getWatchers\",\n    value: function getWatchers() {\n      return this.watchers;\n    }\n  }]);\n\n  return DirectWatcher;\n}();\n\nvar RecursiveWatcher = /*#__PURE__*/function () {\n  function RecursiveWatcher(rootPath) {\n    var _this2 = this;\n\n    _classCallCheck(this, RecursiveWatcher);\n\n    this.rootPath = rootPath;\n    /** @type {Map<Watcher, string>} */\n\n    this.mapWatcherToPath = new Map();\n    /** @type {Map<string, Set<Watcher>>} */\n\n    this.mapPathToWatchers = new Map();\n    this.watcher = undefined;\n\n    try {\n      var watcher = fs.watch(rootPath, {\n        recursive: true\n      });\n      this.watcher = watcher;\n      watcher.on(\"change\", function (type, filename) {\n        if (!filename) {\n          if (recursiveWatcherLogging) {\n            process.stderr.write(\"[watchpack] dispatch \".concat(type, \" event in recursive watcher (\").concat(_this2.rootPath, \") to all watchers\\n\"));\n          }\n\n          var _iterator4 = _createForOfIteratorHelper(_this2.mapWatcherToPath.keys()),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var w = _step4.value;\n              w.emit(\"change\", type);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        } else {\n          var dir = path.dirname(filename);\n\n          var watchers = _this2.mapPathToWatchers.get(dir);\n\n          if (recursiveWatcherLogging) {\n            process.stderr.write(\"[watchpack] dispatch \".concat(type, \" event in recursive watcher (\").concat(_this2.rootPath, \") for '\").concat(filename, \"' to \").concat(watchers ? watchers.size : 0, \" watchers\\n\"));\n          }\n\n          if (watchers === undefined) return;\n\n          var _iterator5 = _createForOfIteratorHelper(watchers),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _w = _step5.value;\n\n              _w.emit(\"change\", type, path.basename(filename));\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      });\n      watcher.on(\"error\", function (error) {\n        var _iterator6 = _createForOfIteratorHelper(_this2.mapWatcherToPath.keys()),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var w = _step6.value;\n            w.emit(\"error\", error);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      });\n    } catch (err) {\n      process.nextTick(function () {\n        var _iterator7 = _createForOfIteratorHelper(_this2.mapWatcherToPath.keys()),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var w = _step7.value;\n            w.emit(\"error\", err);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      });\n    }\n\n    watcherCount++;\n\n    if (recursiveWatcherLogging) {\n      process.stderr.write(\"[watchpack] created recursive watcher at \".concat(rootPath, \"\\n\"));\n    }\n  }\n\n  _createClass(RecursiveWatcher, [{\n    key: \"add\",\n    value: function add(filePath, watcher) {\n      underlyingWatcher.set(watcher, this);\n      var subpath = filePath.slice(this.rootPath.length + 1) || \".\";\n      this.mapWatcherToPath.set(watcher, subpath);\n      var set = this.mapPathToWatchers.get(subpath);\n\n      if (set === undefined) {\n        var newSet = new Set();\n        newSet.add(watcher);\n        this.mapPathToWatchers.set(subpath, newSet);\n      } else {\n        set.add(watcher);\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(watcher) {\n      var subpath = this.mapWatcherToPath.get(watcher);\n      if (!subpath) return;\n      this.mapWatcherToPath.delete(watcher);\n      var set = this.mapPathToWatchers.get(subpath);\n      set.delete(watcher);\n\n      if (set.size === 0) {\n        this.mapPathToWatchers.delete(subpath);\n      }\n\n      if (this.mapWatcherToPath.size === 0) {\n        recursiveWatchers.delete(this.rootPath);\n        watcherCount--;\n        if (this.watcher) this.watcher.close();\n\n        if (recursiveWatcherLogging) {\n          process.stderr.write(\"[watchpack] closed recursive watcher at \".concat(this.rootPath, \"\\n\"));\n        }\n      }\n    }\n  }, {\n    key: \"getWatchers\",\n    value: function getWatchers() {\n      return this.mapWatcherToPath;\n    }\n  }]);\n\n  return RecursiveWatcher;\n}();\n\nvar Watcher = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Watcher, _EventEmitter);\n\n  var _super = _createSuper(Watcher);\n\n  function Watcher() {\n    _classCallCheck(this, Watcher);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Watcher, [{\n    key: \"close\",\n    value: function close() {\n      if (pendingWatchers.has(this)) {\n        pendingWatchers.delete(this);\n        return;\n      }\n\n      var watcher = underlyingWatcher.get(this);\n      watcher.remove(this);\n      underlyingWatcher.delete(this);\n    }\n  }]);\n\n  return Watcher;\n}(EventEmitter);\n\nvar createDirectWatcher = function createDirectWatcher(filePath) {\n  var existing = directWatchers.get(filePath);\n  if (existing !== undefined) return existing;\n  var w = new DirectWatcher(filePath);\n  directWatchers.set(filePath, w);\n  return w;\n};\n\nvar createRecursiveWatcher = function createRecursiveWatcher(rootPath) {\n  var existing = recursiveWatchers.get(rootPath);\n  if (existing !== undefined) return existing;\n  var w = new RecursiveWatcher(rootPath);\n  recursiveWatchers.set(rootPath, w);\n  return w;\n};\n\nvar execute = function execute() {\n  /** @type {Map<string, Watcher[] | Watcher>} */\n  var map = new Map();\n\n  var addWatcher = function addWatcher(watcher, filePath) {\n    var entry = map.get(filePath);\n\n    if (entry === undefined) {\n      map.set(filePath, watcher);\n    } else if (Array.isArray(entry)) {\n      entry.push(watcher);\n    } else {\n      map.set(filePath, [entry, watcher]);\n    }\n  };\n\n  var _iterator8 = _createForOfIteratorHelper(pendingWatchers),\n      _step8;\n\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var _step8$value = _slicedToArray(_step8.value, 2),\n          watcher = _step8$value[0],\n          _filePath = _step8$value[1];\n\n      addWatcher(watcher, _filePath);\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n\n  pendingWatchers.clear(); // Fast case when we are not reaching the limit\n\n  if (!SUPPORTS_RECURSIVE_WATCHING || watcherLimit - watcherCount >= map.size) {\n    // Create watchers for all entries in the map\n    var _iterator9 = _createForOfIteratorHelper(map),\n        _step9;\n\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var _step9$value = _slicedToArray(_step9.value, 2),\n            filePath = _step9$value[0],\n            entry = _step9$value[1];\n\n        var w = createDirectWatcher(filePath);\n\n        if (Array.isArray(entry)) {\n          var _iterator10 = _createForOfIteratorHelper(entry),\n              _step10;\n\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var item = _step10.value;\n              w.add(item);\n            }\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n        } else {\n          w.add(entry);\n        }\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n\n    return;\n  } // Reconsider existing watchers to improving watch plan\n\n\n  var _iterator11 = _createForOfIteratorHelper(recursiveWatchers.values()),\n      _step11;\n\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var _watcher = _step11.value;\n\n      var _iterator14 = _createForOfIteratorHelper(_watcher.getWatchers()),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var _step14$value = _slicedToArray(_step14.value, 2),\n              _w2 = _step14$value[0],\n              subpath = _step14$value[1];\n\n          addWatcher(_w2, path.join(_watcher.rootPath, subpath));\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n\n  var _iterator12 = _createForOfIteratorHelper(directWatchers.values()),\n      _step12;\n\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var _watcher2 = _step12.value;\n\n      var _iterator15 = _createForOfIteratorHelper(_watcher2.getWatchers()),\n          _step15;\n\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var _w3 = _step15.value;\n          addWatcher(_w3, _watcher2.filePath);\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n    } // Merge map entries to keep watcher limit\n    // Create a 10% buffer to be able to enter fast case more often\n\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n\n  var plan = reducePlan(map, watcherLimit * 0.9); // Update watchers for all entries in the map\n\n  var _iterator13 = _createForOfIteratorHelper(plan),\n      _step13;\n\n  try {\n    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n      var _step13$value = _slicedToArray(_step13.value, 2),\n          _filePath2 = _step13$value[0],\n          _entry = _step13$value[1];\n\n      if (_entry.size === 1) {\n        var _iterator16 = _createForOfIteratorHelper(_entry),\n            _step16;\n\n        try {\n          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n            var _step16$value = _slicedToArray(_step16.value, 2),\n                _watcher3 = _step16$value[0],\n                _filePath3 = _step16$value[1];\n\n            var _w4 = createDirectWatcher(_filePath3);\n\n            var old = underlyingWatcher.get(_watcher3);\n            if (old === _w4) continue;\n\n            _w4.add(_watcher3);\n\n            if (old !== undefined) old.remove(_watcher3);\n          }\n        } catch (err) {\n          _iterator16.e(err);\n        } finally {\n          _iterator16.f();\n        }\n      } else {\n        var filePaths = new Set(_entry.values());\n\n        if (filePaths.size > 1) {\n          var _w5 = createRecursiveWatcher(_filePath2);\n\n          var _iterator17 = _createForOfIteratorHelper(_entry),\n              _step17;\n\n          try {\n            for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n              var _step17$value = _slicedToArray(_step17.value, 2),\n                  _watcher4 = _step17$value[0],\n                  watcherPath = _step17$value[1];\n\n              var _old = underlyingWatcher.get(_watcher4);\n\n              if (_old === _w5) continue;\n\n              _w5.add(watcherPath, _watcher4);\n\n              if (_old !== undefined) _old.remove(_watcher4);\n            }\n          } catch (err) {\n            _iterator17.e(err);\n          } finally {\n            _iterator17.f();\n          }\n        } else {\n          var _iterator18 = _createForOfIteratorHelper(filePaths),\n              _step18;\n\n          try {\n            for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n              var _filePath4 = _step18.value;\n\n              var _w6 = createDirectWatcher(_filePath4);\n\n              var _iterator19 = _createForOfIteratorHelper(_entry.keys()),\n                  _step19;\n\n              try {\n                for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                  var _watcher5 = _step19.value;\n\n                  var _old2 = underlyingWatcher.get(_watcher5);\n\n                  if (_old2 === _w6) continue;\n\n                  _w6.add(_watcher5);\n\n                  if (_old2 !== undefined) _old2.remove(_watcher5);\n                }\n              } catch (err) {\n                _iterator19.e(err);\n              } finally {\n                _iterator19.f();\n              }\n            }\n          } catch (err) {\n            _iterator18.e(err);\n          } finally {\n            _iterator18.f();\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator13.e(err);\n  } finally {\n    _iterator13.f();\n  }\n};\n\nexports.watch = function (filePath) {\n  var watcher = new Watcher(); // Find an existing watcher\n\n  var directWatcher = directWatchers.get(filePath);\n\n  if (directWatcher !== undefined) {\n    directWatcher.add(watcher);\n    return watcher;\n  }\n\n  var current = filePath;\n\n  for (;;) {\n    var recursiveWatcher = recursiveWatchers.get(current);\n\n    if (recursiveWatcher !== undefined) {\n      recursiveWatcher.add(filePath, watcher);\n      return watcher;\n    }\n\n    var parent = path.dirname(current);\n    if (parent === current) break;\n    current = parent;\n  } // Queue up watcher for creation\n\n\n  pendingWatchers.set(watcher, filePath);\n  if (!isBatch) execute();\n  return watcher;\n};\n\nexports.batch = function (fn) {\n  isBatch = true;\n\n  try {\n    fn();\n  } finally {\n    isBatch = false;\n    execute();\n  }\n};\n\nexports.getNumberOfWatchers = function () {\n  return watcherCount;\n};","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/watchpack/lib/watchEventSource.js"],"names":["fs","require","path","EventEmitter","reducePlan","IS_OSX","platform","IS_WIN","SUPPORTS_RECURSIVE_WATCHING","watcherLimit","process","env","WATCHPACK_WATCHER_LIMIT","recursiveWatcherLogging","WATCHPACK_RECURSIVE_WATCHER_LOGGING","isBatch","watcherCount","pendingWatchers","Map","recursiveWatchers","directWatchers","underlyingWatcher","DirectWatcher","filePath","watchers","Set","watcher","undefined","watch","on","type","filename","w","emit","error","err","nextTick","set","add","delete","size","close","RecursiveWatcher","rootPath","mapWatcherToPath","mapPathToWatchers","recursive","stderr","write","keys","dir","dirname","get","basename","subpath","slice","length","newSet","Watcher","has","remove","createDirectWatcher","existing","createRecursiveWatcher","execute","map","addWatcher","entry","Array","isArray","push","clear","item","values","getWatchers","join","plan","old","filePaths","watcherPath","exports","directWatcher","current","recursiveWatcher","parent","batch","fn","getNumberOfWatchers"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst { EventEmitter } = require(\"events\");\nconst reducePlan = require(\"./reducePlan\");\n\nconst IS_OSX = require(\"os\").platform() === \"darwin\";\nconst IS_WIN = require(\"os\").platform() === \"win32\";\nconst SUPPORTS_RECURSIVE_WATCHING = IS_OSX || IS_WIN;\n\nconst watcherLimit =\n\t+process.env.WATCHPACK_WATCHER_LIMIT || (IS_OSX ? 2000 : 10000);\n\nconst recursiveWatcherLogging = !!process.env\n\t.WATCHPACK_RECURSIVE_WATCHER_LOGGING;\n\nlet isBatch = false;\nlet watcherCount = 0;\n\n/** @type {Map<Watcher, string>} */\nconst pendingWatchers = new Map();\n\n/** @type {Map<string, RecursiveWatcher>} */\nconst recursiveWatchers = new Map();\n\n/** @type {Map<string, DirectWatcher>} */\nconst directWatchers = new Map();\n\n/** @type {Map<Watcher, RecursiveWatcher | DirectWatcher>} */\nconst underlyingWatcher = new Map();\n\nclass DirectWatcher {\n\tconstructor(filePath) {\n\t\tthis.filePath = filePath;\n\t\tthis.watchers = new Set();\n\t\tthis.watcher = undefined;\n\t\ttry {\n\t\t\tconst watcher = fs.watch(filePath);\n\t\t\tthis.watcher = watcher;\n\t\t\twatcher.on(\"change\", (type, filename) => {\n\t\t\t\tfor (const w of this.watchers) {\n\t\t\t\t\tw.emit(\"change\", type, filename);\n\t\t\t\t}\n\t\t\t});\n\t\t\twatcher.on(\"error\", error => {\n\t\t\t\tfor (const w of this.watchers) {\n\t\t\t\t\tw.emit(\"error\", error);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tfor (const w of this.watchers) {\n\t\t\t\t\tw.emit(\"error\", err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\twatcherCount++;\n\t}\n\n\tadd(watcher) {\n\t\tunderlyingWatcher.set(watcher, this);\n\t\tthis.watchers.add(watcher);\n\t}\n\n\tremove(watcher) {\n\t\tthis.watchers.delete(watcher);\n\t\tif (this.watchers.size === 0) {\n\t\t\tdirectWatchers.delete(this.filePath);\n\t\t\twatcherCount--;\n\t\t\tif (this.watcher) this.watcher.close();\n\t\t}\n\t}\n\n\tgetWatchers() {\n\t\treturn this.watchers;\n\t}\n}\n\nclass RecursiveWatcher {\n\tconstructor(rootPath) {\n\t\tthis.rootPath = rootPath;\n\t\t/** @type {Map<Watcher, string>} */\n\t\tthis.mapWatcherToPath = new Map();\n\t\t/** @type {Map<string, Set<Watcher>>} */\n\t\tthis.mapPathToWatchers = new Map();\n\t\tthis.watcher = undefined;\n\t\ttry {\n\t\t\tconst watcher = fs.watch(rootPath, {\n\t\t\t\trecursive: true\n\t\t\t});\n\t\t\tthis.watcher = watcher;\n\t\t\twatcher.on(\"change\", (type, filename) => {\n\t\t\t\tif (!filename) {\n\t\t\t\t\tif (recursiveWatcherLogging) {\n\t\t\t\t\t\tprocess.stderr.write(\n\t\t\t\t\t\t\t`[watchpack] dispatch ${type} event in recursive watcher (${\n\t\t\t\t\t\t\t\tthis.rootPath\n\t\t\t\t\t\t\t}) to all watchers\\n`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\n\t\t\t\t\t\tw.emit(\"change\", type);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst dir = path.dirname(filename);\n\t\t\t\t\tconst watchers = this.mapPathToWatchers.get(dir);\n\t\t\t\t\tif (recursiveWatcherLogging) {\n\t\t\t\t\t\tprocess.stderr.write(\n\t\t\t\t\t\t\t`[watchpack] dispatch ${type} event in recursive watcher (${\n\t\t\t\t\t\t\t\tthis.rootPath\n\t\t\t\t\t\t\t}) for '${filename}' to ${\n\t\t\t\t\t\t\t\twatchers ? watchers.size : 0\n\t\t\t\t\t\t\t} watchers\\n`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (watchers === undefined) return;\n\t\t\t\t\tfor (const w of watchers) {\n\t\t\t\t\t\tw.emit(\"change\", type, path.basename(filename));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\twatcher.on(\"error\", error => {\n\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\n\t\t\t\t\tw.emit(\"error\", error);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\n\t\t\t\t\tw.emit(\"error\", err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\twatcherCount++;\n\t\tif (recursiveWatcherLogging) {\n\t\t\tprocess.stderr.write(\n\t\t\t\t`[watchpack] created recursive watcher at ${rootPath}\\n`\n\t\t\t);\n\t\t}\n\t}\n\n\tadd(filePath, watcher) {\n\t\tunderlyingWatcher.set(watcher, this);\n\t\tconst subpath = filePath.slice(this.rootPath.length + 1) || \".\";\n\t\tthis.mapWatcherToPath.set(watcher, subpath);\n\t\tconst set = this.mapPathToWatchers.get(subpath);\n\t\tif (set === undefined) {\n\t\t\tconst newSet = new Set();\n\t\t\tnewSet.add(watcher);\n\t\t\tthis.mapPathToWatchers.set(subpath, newSet);\n\t\t} else {\n\t\t\tset.add(watcher);\n\t\t}\n\t}\n\n\tremove(watcher) {\n\t\tconst subpath = this.mapWatcherToPath.get(watcher);\n\t\tif (!subpath) return;\n\t\tthis.mapWatcherToPath.delete(watcher);\n\t\tconst set = this.mapPathToWatchers.get(subpath);\n\t\tset.delete(watcher);\n\t\tif (set.size === 0) {\n\t\t\tthis.mapPathToWatchers.delete(subpath);\n\t\t}\n\t\tif (this.mapWatcherToPath.size === 0) {\n\t\t\trecursiveWatchers.delete(this.rootPath);\n\t\t\twatcherCount--;\n\t\t\tif (this.watcher) this.watcher.close();\n\t\t\tif (recursiveWatcherLogging) {\n\t\t\t\tprocess.stderr.write(\n\t\t\t\t\t`[watchpack] closed recursive watcher at ${this.rootPath}\\n`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tgetWatchers() {\n\t\treturn this.mapWatcherToPath;\n\t}\n}\n\nclass Watcher extends EventEmitter {\n\tclose() {\n\t\tif (pendingWatchers.has(this)) {\n\t\t\tpendingWatchers.delete(this);\n\t\t\treturn;\n\t\t}\n\t\tconst watcher = underlyingWatcher.get(this);\n\t\twatcher.remove(this);\n\t\tunderlyingWatcher.delete(this);\n\t}\n}\n\nconst createDirectWatcher = filePath => {\n\tconst existing = directWatchers.get(filePath);\n\tif (existing !== undefined) return existing;\n\tconst w = new DirectWatcher(filePath);\n\tdirectWatchers.set(filePath, w);\n\treturn w;\n};\n\nconst createRecursiveWatcher = rootPath => {\n\tconst existing = recursiveWatchers.get(rootPath);\n\tif (existing !== undefined) return existing;\n\tconst w = new RecursiveWatcher(rootPath);\n\trecursiveWatchers.set(rootPath, w);\n\treturn w;\n};\n\nconst execute = () => {\n\t/** @type {Map<string, Watcher[] | Watcher>} */\n\tconst map = new Map();\n\tconst addWatcher = (watcher, filePath) => {\n\t\tconst entry = map.get(filePath);\n\t\tif (entry === undefined) {\n\t\t\tmap.set(filePath, watcher);\n\t\t} else if (Array.isArray(entry)) {\n\t\t\tentry.push(watcher);\n\t\t} else {\n\t\t\tmap.set(filePath, [entry, watcher]);\n\t\t}\n\t};\n\tfor (const [watcher, filePath] of pendingWatchers) {\n\t\taddWatcher(watcher, filePath);\n\t}\n\tpendingWatchers.clear();\n\n\t// Fast case when we are not reaching the limit\n\tif (!SUPPORTS_RECURSIVE_WATCHING || watcherLimit - watcherCount >= map.size) {\n\t\t// Create watchers for all entries in the map\n\t\tfor (const [filePath, entry] of map) {\n\t\t\tconst w = createDirectWatcher(filePath);\n\t\t\tif (Array.isArray(entry)) {\n\t\t\t\tfor (const item of entry) w.add(item);\n\t\t\t} else {\n\t\t\t\tw.add(entry);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t// Reconsider existing watchers to improving watch plan\n\tfor (const watcher of recursiveWatchers.values()) {\n\t\tfor (const [w, subpath] of watcher.getWatchers()) {\n\t\t\taddWatcher(w, path.join(watcher.rootPath, subpath));\n\t\t}\n\t}\n\tfor (const watcher of directWatchers.values()) {\n\t\tfor (const w of watcher.getWatchers()) {\n\t\t\taddWatcher(w, watcher.filePath);\n\t\t}\n\t}\n\n\t// Merge map entries to keep watcher limit\n\t// Create a 10% buffer to be able to enter fast case more often\n\tconst plan = reducePlan(map, watcherLimit * 0.9);\n\n\t// Update watchers for all entries in the map\n\tfor (const [filePath, entry] of plan) {\n\t\tif (entry.size === 1) {\n\t\t\tfor (const [watcher, filePath] of entry) {\n\t\t\t\tconst w = createDirectWatcher(filePath);\n\t\t\t\tconst old = underlyingWatcher.get(watcher);\n\t\t\t\tif (old === w) continue;\n\t\t\t\tw.add(watcher);\n\t\t\t\tif (old !== undefined) old.remove(watcher);\n\t\t\t}\n\t\t} else {\n\t\t\tconst filePaths = new Set(entry.values());\n\t\t\tif (filePaths.size > 1) {\n\t\t\t\tconst w = createRecursiveWatcher(filePath);\n\t\t\t\tfor (const [watcher, watcherPath] of entry) {\n\t\t\t\t\tconst old = underlyingWatcher.get(watcher);\n\t\t\t\t\tif (old === w) continue;\n\t\t\t\t\tw.add(watcherPath, watcher);\n\t\t\t\t\tif (old !== undefined) old.remove(watcher);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const filePath of filePaths) {\n\t\t\t\t\tconst w = createDirectWatcher(filePath);\n\t\t\t\t\tfor (const watcher of entry.keys()) {\n\t\t\t\t\t\tconst old = underlyingWatcher.get(watcher);\n\t\t\t\t\t\tif (old === w) continue;\n\t\t\t\t\t\tw.add(watcher);\n\t\t\t\t\t\tif (old !== undefined) old.remove(watcher);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nexports.watch = filePath => {\n\tconst watcher = new Watcher();\n\t// Find an existing watcher\n\tconst directWatcher = directWatchers.get(filePath);\n\tif (directWatcher !== undefined) {\n\t\tdirectWatcher.add(watcher);\n\t\treturn watcher;\n\t}\n\tlet current = filePath;\n\tfor (;;) {\n\t\tconst recursiveWatcher = recursiveWatchers.get(current);\n\t\tif (recursiveWatcher !== undefined) {\n\t\t\trecursiveWatcher.add(filePath, watcher);\n\t\t\treturn watcher;\n\t\t}\n\t\tconst parent = path.dirname(current);\n\t\tif (parent === current) break;\n\t\tcurrent = parent;\n\t}\n\t// Queue up watcher for creation\n\tpendingWatchers.set(watcher, filePath);\n\tif (!isBatch) execute();\n\treturn watcher;\n};\n\nexports.batch = fn => {\n\tisBatch = true;\n\ttry {\n\t\tfn();\n\t} finally {\n\t\tisBatch = false;\n\t\texecute();\n\t}\n};\n\nexports.getNumberOfWatchers = () => {\n\treturn watcherCount;\n};\n"]},"metadata":{},"sourceType":"script"}