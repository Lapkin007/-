{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.set.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.map.js\");\n\nrequire(\"core-js/modules/es.object.freeze.js\");\n\nrequire(\"core-js/modules/es.array.from.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nvar fs = require(\"fs\");\n\nvar path = require(\"path\"); // macOS, Linux, and Windows all rely on these errors\n\n\nvar EXPECTED_ERRORS = new Set([\"EINVAL\", \"ENOENT\"]); // On Windows there is also this error in some cases\n\nif (process.platform === \"win32\") EXPECTED_ERRORS.add(\"UNKNOWN\");\n\nvar LinkResolver = /*#__PURE__*/function () {\n  function LinkResolver() {\n    _classCallCheck(this, LinkResolver);\n\n    this.cache = new Map();\n  }\n  /**\n   * @param {string} file path to file or directory\n   * @returns {string[]} array of file and all symlinks contributed in the resolving process (first item is the resolved file)\n   */\n\n\n  _createClass(LinkResolver, [{\n    key: \"resolve\",\n    value: function resolve(file) {\n      var cacheEntry = this.cache.get(file);\n\n      if (cacheEntry !== undefined) {\n        return cacheEntry;\n      }\n\n      var parent = path.dirname(file);\n\n      if (parent === file) {\n        // At root of filesystem there can't be a link\n        var result = Object.freeze([file]);\n        this.cache.set(file, result);\n        return result;\n      } // resolve the parent directory to find links there and get the real path\n\n\n      var parentResolved = this.resolve(parent);\n      var realFile = file; // is the parent directory really somewhere else?\n\n      if (parentResolved[0] !== parent) {\n        // get the real location of file\n        var basename = path.basename(file);\n        realFile = path.resolve(parentResolved[0], basename);\n      } // try to read the link content\n\n\n      try {\n        var linkContent = fs.readlinkSync(realFile); // resolve the link content relative to the parent directory\n\n        var resolvedLink = path.resolve(parentResolved[0], linkContent); // recursive resolve the link content for more links in the structure\n\n        var linkResolved = this.resolve(resolvedLink); // merge parent and link resolve results\n\n        var _result;\n\n        if (linkResolved.length > 1 && parentResolved.length > 1) {\n          // when both contain links we need to duplicate them with a Set\n          var resultSet = new Set(linkResolved); // add the link\n\n          resultSet.add(realFile); // add all symlinks of the parent\n\n          for (var i = 1; i < parentResolved.length; i++) {\n            resultSet.add(parentResolved[i]);\n          }\n\n          _result = Object.freeze(Array.from(resultSet));\n        } else if (parentResolved.length > 1) {\n          // we have links in the parent but not for the link content location\n          _result = parentResolved.slice();\n          _result[0] = linkResolved[0]; // add the link\n\n          _result.push(realFile);\n\n          Object.freeze(_result);\n        } else if (linkResolved.length > 1) {\n          // we can return the link content location result\n          _result = linkResolved.slice(); // add the link\n\n          _result.push(realFile);\n\n          Object.freeze(_result);\n        } else {\n          // neither link content location nor parent have links\n          // this link is the only link here\n          _result = Object.freeze([// the resolve real location\n          linkResolved[0], // add the link\n          realFile]);\n        }\n\n        this.cache.set(file, _result);\n        return _result;\n      } catch (e) {\n        if (!EXPECTED_ERRORS.has(e.code)) {\n          throw e;\n        } // no link\n\n\n        var _result2 = parentResolved.slice();\n\n        _result2[0] = realFile;\n        Object.freeze(_result2);\n        this.cache.set(file, _result2);\n        return _result2;\n      }\n    }\n  }]);\n\n  return LinkResolver;\n}();\n\nmodule.exports = LinkResolver;","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/watchpack/lib/LinkResolver.js"],"names":["fs","require","path","EXPECTED_ERRORS","Set","process","platform","add","LinkResolver","cache","Map","file","cacheEntry","get","undefined","parent","dirname","result","Object","freeze","set","parentResolved","resolve","realFile","basename","linkContent","readlinkSync","resolvedLink","linkResolved","length","resultSet","i","Array","from","slice","push","e","has","code","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\n// macOS, Linux, and Windows all rely on these errors\nconst EXPECTED_ERRORS = new Set([\"EINVAL\", \"ENOENT\"]);\n\n// On Windows there is also this error in some cases\nif (process.platform === \"win32\") EXPECTED_ERRORS.add(\"UNKNOWN\");\n\nclass LinkResolver {\n\tconstructor() {\n\t\tthis.cache = new Map();\n\t}\n\n\t/**\n\t * @param {string} file path to file or directory\n\t * @returns {string[]} array of file and all symlinks contributed in the resolving process (first item is the resolved file)\n\t */\n\tresolve(file) {\n\t\tconst cacheEntry = this.cache.get(file);\n\t\tif (cacheEntry !== undefined) {\n\t\t\treturn cacheEntry;\n\t\t}\n\t\tconst parent = path.dirname(file);\n\t\tif (parent === file) {\n\t\t\t// At root of filesystem there can't be a link\n\t\t\tconst result = Object.freeze([file]);\n\t\t\tthis.cache.set(file, result);\n\t\t\treturn result;\n\t\t}\n\t\t// resolve the parent directory to find links there and get the real path\n\t\tconst parentResolved = this.resolve(parent);\n\t\tlet realFile = file;\n\n\t\t// is the parent directory really somewhere else?\n\t\tif (parentResolved[0] !== parent) {\n\t\t\t// get the real location of file\n\t\t\tconst basename = path.basename(file);\n\t\t\trealFile = path.resolve(parentResolved[0], basename);\n\t\t}\n\t\t// try to read the link content\n\t\ttry {\n\t\t\tconst linkContent = fs.readlinkSync(realFile);\n\n\t\t\t// resolve the link content relative to the parent directory\n\t\t\tconst resolvedLink = path.resolve(parentResolved[0], linkContent);\n\n\t\t\t// recursive resolve the link content for more links in the structure\n\t\t\tconst linkResolved = this.resolve(resolvedLink);\n\n\t\t\t// merge parent and link resolve results\n\t\t\tlet result;\n\t\t\tif (linkResolved.length > 1 && parentResolved.length > 1) {\n\t\t\t\t// when both contain links we need to duplicate them with a Set\n\t\t\t\tconst resultSet = new Set(linkResolved);\n\t\t\t\t// add the link\n\t\t\t\tresultSet.add(realFile);\n\t\t\t\t// add all symlinks of the parent\n\t\t\t\tfor (let i = 1; i < parentResolved.length; i++) {\n\t\t\t\t\tresultSet.add(parentResolved[i]);\n\t\t\t\t}\n\t\t\t\tresult = Object.freeze(Array.from(resultSet));\n\t\t\t} else if (parentResolved.length > 1) {\n\t\t\t\t// we have links in the parent but not for the link content location\n\t\t\t\tresult = parentResolved.slice();\n\t\t\t\tresult[0] = linkResolved[0];\n\t\t\t\t// add the link\n\t\t\t\tresult.push(realFile);\n\t\t\t\tObject.freeze(result);\n\t\t\t} else if (linkResolved.length > 1) {\n\t\t\t\t// we can return the link content location result\n\t\t\t\tresult = linkResolved.slice();\n\t\t\t\t// add the link\n\t\t\t\tresult.push(realFile);\n\t\t\t\tObject.freeze(result);\n\t\t\t} else {\n\t\t\t\t// neither link content location nor parent have links\n\t\t\t\t// this link is the only link here\n\t\t\t\tresult = Object.freeze([\n\t\t\t\t\t// the resolve real location\n\t\t\t\t\tlinkResolved[0],\n\t\t\t\t\t// add the link\n\t\t\t\t\trealFile\n\t\t\t\t]);\n\t\t\t}\n\t\t\tthis.cache.set(file, result);\n\t\t\treturn result;\n\t\t} catch (e) {\n\t\t\tif (!EXPECTED_ERRORS.has(e.code)) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\t// no link\n\t\t\tconst result = parentResolved.slice();\n\t\t\tresult[0] = realFile;\n\t\t\tObject.freeze(result);\n\t\t\tthis.cache.set(file, result);\n\t\t\treturn result;\n\t\t}\n\t}\n}\nmodule.exports = LinkResolver;\n"]},"metadata":{},"sourceType":"script"}