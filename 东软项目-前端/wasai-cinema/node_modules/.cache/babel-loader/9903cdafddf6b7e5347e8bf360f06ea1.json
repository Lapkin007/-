{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _slicedToArray = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nrequire(\"regenerator-runtime/runtime.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.string.split.js\");\n\nrequire(\"core-js/modules/es.array.splice.js\");\n\nrequire(\"core-js/modules/es.string.trim.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.string.match.js\");\n\nrequire(\"core-js/modules/es.object.entries.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nvar _require = require(\"net\"),\n    isIP = _require.isIP;\n\nvar _require2 = require(\"os\"),\n    networkInterfaces = _require2.networkInterfaces;\n\nvar execa = require(\"execa\");\n\nvar gwArgs = \"path Win32_NetworkAdapterConfiguration where IPEnabled=true get DefaultIPGateway,GatewayCostMetric,IPConnectionMetric,Index /format:table\".split(\" \");\n\nvar ifArgs = function ifArgs(index) {\n  return \"path Win32_NetworkAdapter where Index=\".concat(index, \" get NetConnectionID,MACAddress /format:table\").split(\" \");\n};\n\nvar spawnOpts = {\n  windowsHide: true\n}; // Parsing tables like this. The final metric is GatewayCostMetric + IPConnectionMetric\n//\n// DefaultIPGateway             GatewayCostMetric  Index  IPConnectionMetric\n// {\"1.2.3.4\", \"2001:db8::1\"}   {0, 256}           12     25\n// {\"2.3.4.5\"}                  {25}               12     55\n\nfunction parseGwTable(gwTable, family) {\n  var bestGw = null,\n      bestMetric = null,\n      bestId = null;\n\n  var _iterator = _createForOfIteratorHelper((gwTable || \"\").trim().split(/\\r?\\n/).splice(1)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var line = _step.value;\n      line = line.trim();\n\n      var _ref = /({.+?}) +?({.+?}) +?([0-9]+) +?([0-9]+)/g.exec(line) || [],\n          _ref2 = _slicedToArray(_ref, 5),\n          _ = _ref2[0],\n          gwArr = _ref2[1],\n          gwCostsArr = _ref2[2],\n          id = _ref2[3],\n          ipMetric = _ref2[4];\n\n      if (!gwArr) continue;\n      var gateways = (gwArr.match(/\"(.+?)\"/g) || []).map(function (match) {\n        return match.substring(1, match.length - 1);\n      });\n      var gatewayCosts = gwCostsArr.match(/[0-9]+/g) || [];\n\n      for (var _i = 0, _Object$entries = Object.entries(gateways); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n            index = _Object$entries$_i[0],\n            gateway = _Object$entries$_i[1];\n\n        if (!gateway || \"v\".concat(isIP(gateway)) !== family) continue;\n        var metric = parseInt(gatewayCosts[index]) + parseInt(ipMetric);\n\n        if (!bestGw || metric < bestMetric) {\n          bestGw = gateway;\n          bestMetric = metric;\n          bestId = id;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (bestGw) return [bestGw, bestId];\n}\n\nfunction parseIfTable(ifTable) {\n  var line = (ifTable || \"\").trim().split(\"\\n\")[1];\n\n  var _line$trim$split = line.trim().split(/\\s+/),\n      _line$trim$split2 = _slicedToArray(_line$trim$split, 2),\n      mac = _line$trim$split2[0],\n      name = _line$trim$split2[1];\n\n  mac = mac.toLowerCase(); // try to get the interface name by matching the mac to os.networkInterfaces to avoid wmic's encoding issues\n  // https://github.com/silverwind/default-gateway/issues/14\n\n  for (var _i2 = 0, _Object$entries2 = Object.entries(networkInterfaces()); _i2 < _Object$entries2.length; _i2++) {\n    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n        osname = _Object$entries2$_i[0],\n        addrs = _Object$entries2$_i[1];\n\n    var _iterator2 = _createForOfIteratorHelper(addrs),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var addr = _step2.value;\n\n        if (addr && addr.mac && addr.mac.toLowerCase() === mac) {\n          return osname;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  return name;\n}\n\nvar promise = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(family) {\n    var _yield$execa, stdout, _ref4, _ref5, gateway, id, name, _yield$execa2, _stdout;\n\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return execa(\"wmic\", gwArgs, spawnOpts);\n\n          case 2:\n            _yield$execa = _context.sent;\n            stdout = _yield$execa.stdout;\n            _ref4 = parseGwTable(stdout, family) || [], _ref5 = _slicedToArray(_ref4, 2), gateway = _ref5[0], id = _ref5[1];\n\n            if (gateway) {\n              _context.next = 7;\n              break;\n            }\n\n            throw new Error(\"Unable to determine default gateway\");\n\n          case 7:\n            if (!id) {\n              _context.next = 13;\n              break;\n            }\n\n            _context.next = 10;\n            return execa(\"wmic\", ifArgs(id), spawnOpts);\n\n          case 10:\n            _yield$execa2 = _context.sent;\n            _stdout = _yield$execa2.stdout;\n            name = parseIfTable(_stdout);\n\n          case 13:\n            return _context.abrupt(\"return\", {\n              gateway: gateway,\n              interface: name ? name : null\n            });\n\n          case 14:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function promise(_x) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar sync = function sync(family) {\n  var _execa$sync = execa.sync(\"wmic\", gwArgs, spawnOpts),\n      stdout = _execa$sync.stdout;\n\n  var _ref6 = parseGwTable(stdout, family) || [],\n      _ref7 = _slicedToArray(_ref6, 2),\n      gateway = _ref7[0],\n      id = _ref7[1];\n\n  if (!gateway) {\n    throw new Error(\"Unable to determine default gateway\");\n  }\n\n  var name;\n\n  if (id) {\n    var _execa$sync2 = execa.sync(\"wmic\", ifArgs(id), spawnOpts),\n        _stdout2 = _execa$sync2.stdout;\n\n    name = parseIfTable(_stdout2);\n  }\n\n  return {\n    gateway: gateway,\n    interface: name ? name : null\n  };\n};\n\nmodule.exports.v4 = function () {\n  return promise(\"v4\");\n};\n\nmodule.exports.v6 = function () {\n  return promise(\"v6\");\n};\n\nmodule.exports.v4.sync = function () {\n  return sync(\"v4\");\n};\n\nmodule.exports.v6.sync = function () {\n  return sync(\"v6\");\n};","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/default-gateway/win32.js"],"names":["require","isIP","networkInterfaces","execa","gwArgs","split","ifArgs","index","spawnOpts","windowsHide","parseGwTable","gwTable","family","bestGw","bestMetric","bestId","trim","splice","line","exec","_","gwArr","gwCostsArr","id","ipMetric","gateways","match","map","substring","length","gatewayCosts","Object","entries","gateway","metric","parseInt","parseIfTable","ifTable","mac","name","toLowerCase","osname","addrs","addr","promise","stdout","Error","interface","sync","module","exports","v4","v6"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst {isIP} = require(\"net\");\nconst {networkInterfaces} = require(\"os\");\nconst execa = require(\"execa\");\n\nconst gwArgs = \"path Win32_NetworkAdapterConfiguration where IPEnabled=true get DefaultIPGateway,GatewayCostMetric,IPConnectionMetric,Index /format:table\".split(\" \");\nconst ifArgs = index => `path Win32_NetworkAdapter where Index=${index} get NetConnectionID,MACAddress /format:table`.split(\" \");\n\nconst spawnOpts = {\n  windowsHide: true,\n};\n\n// Parsing tables like this. The final metric is GatewayCostMetric + IPConnectionMetric\n//\n// DefaultIPGateway             GatewayCostMetric  Index  IPConnectionMetric\n// {\"1.2.3.4\", \"2001:db8::1\"}   {0, 256}           12     25\n// {\"2.3.4.5\"}                  {25}               12     55\nfunction parseGwTable(gwTable, family) {\n  let [bestGw, bestMetric, bestId] = [null, null, null];\n\n  for (let line of (gwTable || \"\").trim().split(/\\r?\\n/).splice(1)) {\n    line = line.trim();\n    const [_, gwArr, gwCostsArr, id, ipMetric] = /({.+?}) +?({.+?}) +?([0-9]+) +?([0-9]+)/g.exec(line) || [];\n    if (!gwArr) continue;\n\n    const gateways = (gwArr.match(/\"(.+?)\"/g) || []).map(match => match.substring(1, match.length - 1));\n    const gatewayCosts = (gwCostsArr.match(/[0-9]+/g) || []);\n\n    for (const [index, gateway] of Object.entries(gateways)) {\n      if (!gateway || `v${isIP(gateway)}` !== family) continue;\n\n      const metric = parseInt(gatewayCosts[index]) + parseInt(ipMetric);\n      if (!bestGw || metric < bestMetric) {\n        [bestGw, bestMetric, bestId] = [gateway, metric, id];\n      }\n    }\n  }\n\n  if (bestGw) return [bestGw, bestId];\n}\n\nfunction parseIfTable(ifTable) {\n  const line = (ifTable || \"\").trim().split(\"\\n\")[1];\n\n  let [mac, name] = line.trim().split(/\\s+/);\n  mac = mac.toLowerCase();\n\n  // try to get the interface name by matching the mac to os.networkInterfaces to avoid wmic's encoding issues\n  // https://github.com/silverwind/default-gateway/issues/14\n  for (const [osname, addrs] of Object.entries(networkInterfaces())) {\n    for (const addr of addrs) {\n      if (addr && addr.mac && addr.mac.toLowerCase() === mac) {\n        return osname;\n      }\n    }\n  }\n  return name;\n}\n\nconst promise = async family => {\n  const {stdout} = await execa(\"wmic\", gwArgs, spawnOpts);\n  const [gateway, id] = parseGwTable(stdout, family) || [];\n\n  if (!gateway) {\n    throw new Error(\"Unable to determine default gateway\");\n  }\n\n  let name;\n  if (id) {\n    const {stdout} = await execa(\"wmic\", ifArgs(id), spawnOpts);\n    name = parseIfTable(stdout);\n  }\n\n  return {gateway, interface: name ? name : null};\n};\n\nconst sync = family => {\n  const {stdout} = execa.sync(\"wmic\", gwArgs, spawnOpts);\n  const [gateway, id] = parseGwTable(stdout, family) || [];\n\n  if (!gateway) {\n    throw new Error(\"Unable to determine default gateway\");\n  }\n\n  let name;\n  if (id) {\n    const {stdout} = execa.sync(\"wmic\", ifArgs(id), spawnOpts);\n    name = parseIfTable(stdout);\n  }\n\n  return {gateway, interface: name ? name : null};\n};\n\nmodule.exports.v4 = () => promise(\"v4\");\nmodule.exports.v6 = () => promise(\"v6\");\n\nmodule.exports.v4.sync = () => sync(\"v4\");\nmodule.exports.v6.sync = () => sync(\"v6\");\n"]},"metadata":{},"sourceType":"script"}