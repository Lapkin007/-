{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _typeof = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/typeof.js\").default;\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nrequire(\"core-js/modules/es.map.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.json.stringify.js\");\n\nvar Source = require(\"./Source\");\n\nvar streamChunksOfSourceMap = require(\"./helpers/streamChunksOfSourceMap\");\n\nvar streamChunksOfRawSource = require(\"./helpers/streamChunksOfRawSource\");\n\nvar streamAndGetSourceAndMap = require(\"./helpers/streamAndGetSourceAndMap\");\n\nvar mapToBufferedMap = function mapToBufferedMap(map) {\n  if (_typeof(map) !== \"object\" || !map) return map;\n  var bufferedMap = Object.assign({}, map);\n\n  if (map.mappings) {\n    bufferedMap.mappings = Buffer.from(map.mappings, \"utf-8\");\n  }\n\n  if (map.sourcesContent) {\n    bufferedMap.sourcesContent = map.sourcesContent.map(function (str) {\n      return str && Buffer.from(str, \"utf-8\");\n    });\n  }\n\n  return bufferedMap;\n};\n\nvar bufferedMapToMap = function bufferedMapToMap(bufferedMap) {\n  if (_typeof(bufferedMap) !== \"object\" || !bufferedMap) return bufferedMap;\n  var map = Object.assign({}, bufferedMap);\n\n  if (bufferedMap.mappings) {\n    map.mappings = bufferedMap.mappings.toString(\"utf-8\");\n  }\n\n  if (bufferedMap.sourcesContent) {\n    map.sourcesContent = bufferedMap.sourcesContent.map(function (buffer) {\n      return buffer && buffer.toString(\"utf-8\");\n    });\n  }\n\n  return map;\n};\n\nvar CachedSource = /*#__PURE__*/function (_Source) {\n  _inherits(CachedSource, _Source);\n\n  var _super = _createSuper(CachedSource);\n\n  function CachedSource(source, cachedData) {\n    var _this;\n\n    _classCallCheck(this, CachedSource);\n\n    _this = _super.call(this);\n    _this._source = source;\n    _this._cachedSourceType = cachedData ? cachedData.source : undefined;\n    _this._cachedSource = undefined;\n    _this._cachedBuffer = cachedData ? cachedData.buffer : undefined;\n    _this._cachedSize = cachedData ? cachedData.size : undefined;\n    _this._cachedMaps = cachedData ? cachedData.maps : new Map();\n    _this._cachedHashUpdate = cachedData ? cachedData.hash : undefined;\n    return _this;\n  }\n\n  _createClass(CachedSource, [{\n    key: \"getCachedData\",\n    value: function getCachedData() {\n      var bufferedMaps = new Map();\n\n      var _iterator = _createForOfIteratorHelper(this._cachedMaps),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var pair = _step.value;\n          var cacheEntry = pair[1];\n\n          if (cacheEntry.bufferedMap === undefined) {\n            cacheEntry.bufferedMap = mapToBufferedMap(this._getMapFromCacheEntry(cacheEntry));\n          }\n\n          bufferedMaps.set(pair[0], {\n            map: undefined,\n            bufferedMap: cacheEntry.bufferedMap\n          });\n        } // We don't want to cache strings\n        // So if we have a caches sources\n        // create a buffer from it and only store\n        // if it was a Buffer or string\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (this._cachedSource) {\n        this.buffer();\n      }\n\n      return {\n        buffer: this._cachedBuffer,\n        source: this._cachedSourceType !== undefined ? this._cachedSourceType : typeof this._cachedSource === \"string\" ? true : Buffer.isBuffer(this._cachedSource) ? false : undefined,\n        size: this._cachedSize,\n        maps: bufferedMaps,\n        hash: this._cachedHashUpdate\n      };\n    }\n  }, {\n    key: \"originalLazy\",\n    value: function originalLazy() {\n      return this._source;\n    }\n  }, {\n    key: \"original\",\n    value: function original() {\n      if (typeof this._source === \"function\") this._source = this._source();\n      return this._source;\n    }\n  }, {\n    key: \"source\",\n    value: function source() {\n      var source = this._getCachedSource();\n\n      if (source !== undefined) return source;\n      return this._cachedSource = this.original().source();\n    }\n  }, {\n    key: \"_getMapFromCacheEntry\",\n    value: function _getMapFromCacheEntry(cacheEntry) {\n      if (cacheEntry.map !== undefined) {\n        return cacheEntry.map;\n      } else if (cacheEntry.bufferedMap !== undefined) {\n        return cacheEntry.map = bufferedMapToMap(cacheEntry.bufferedMap);\n      }\n    }\n  }, {\n    key: \"_getCachedSource\",\n    value: function _getCachedSource() {\n      if (this._cachedSource !== undefined) return this._cachedSource;\n\n      if (this._cachedBuffer && this._cachedSourceType !== undefined) {\n        return this._cachedSource = this._cachedSourceType ? this._cachedBuffer.toString(\"utf-8\") : this._cachedBuffer;\n      }\n    }\n  }, {\n    key: \"buffer\",\n    value: function buffer() {\n      if (this._cachedBuffer !== undefined) return this._cachedBuffer;\n\n      if (this._cachedSource !== undefined) {\n        if (Buffer.isBuffer(this._cachedSource)) {\n          return this._cachedBuffer = this._cachedSource;\n        }\n\n        return this._cachedBuffer = Buffer.from(this._cachedSource, \"utf-8\");\n      }\n\n      if (typeof this.original().buffer === \"function\") {\n        return this._cachedBuffer = this.original().buffer();\n      }\n\n      var bufferOrString = this.source();\n\n      if (Buffer.isBuffer(bufferOrString)) {\n        return this._cachedBuffer = bufferOrString;\n      }\n\n      return this._cachedBuffer = Buffer.from(bufferOrString, \"utf-8\");\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      if (this._cachedSize !== undefined) return this._cachedSize;\n\n      if (this._cachedBuffer !== undefined) {\n        return this._cachedSize = this._cachedBuffer.length;\n      }\n\n      var source = this._getCachedSource();\n\n      if (source !== undefined) {\n        return this._cachedSize = Buffer.byteLength(source);\n      }\n\n      return this._cachedSize = this.original().size();\n    }\n  }, {\n    key: \"sourceAndMap\",\n    value: function sourceAndMap(options) {\n      var key = options ? JSON.stringify(options) : \"{}\";\n\n      var cacheEntry = this._cachedMaps.get(key); // Look for a cached map\n\n\n      if (cacheEntry !== undefined) {\n        // We have a cached map in some representation\n        var _map = this._getMapFromCacheEntry(cacheEntry); // Either get the cached source or compute it\n\n\n        return {\n          source: this.source(),\n          map: _map\n        };\n      } // Look for a cached source\n\n\n      var source = this._getCachedSource(); // Compute the map\n\n\n      var map;\n\n      if (source !== undefined) {\n        map = this.original().map(options);\n      } else {\n        // Compute the source and map together.\n        var sourceAndMap = this.original().sourceAndMap(options);\n        source = sourceAndMap.source;\n        map = sourceAndMap.map;\n        this._cachedSource = source;\n      }\n\n      this._cachedMaps.set(key, {\n        map: map,\n        bufferedMap: undefined\n      });\n\n      return {\n        source: source,\n        map: map\n      };\n    }\n  }, {\n    key: \"streamChunks\",\n    value: function streamChunks(options, onChunk, onSource, onName) {\n      var key = options ? JSON.stringify(options) : \"{}\";\n\n      if (this._cachedMaps.has(key) && (this._cachedBuffer !== undefined || this._cachedSource !== undefined)) {\n        var _this$sourceAndMap = this.sourceAndMap(options),\n            _source = _this$sourceAndMap.source,\n            _map2 = _this$sourceAndMap.map;\n\n        if (_map2) {\n          return streamChunksOfSourceMap(_source, _map2, onChunk, onSource, onName, !!(options && options.finalSource), true);\n        } else {\n          return streamChunksOfRawSource(_source, onChunk, onSource, onName, !!(options && options.finalSource));\n        }\n      }\n\n      var _streamAndGetSourceAn = streamAndGetSourceAndMap(this.original(), options, onChunk, onSource, onName),\n          result = _streamAndGetSourceAn.result,\n          source = _streamAndGetSourceAn.source,\n          map = _streamAndGetSourceAn.map;\n\n      this._cachedSource = source;\n\n      this._cachedMaps.set(key, {\n        map: map,\n        bufferedMap: undefined\n      });\n\n      return result;\n    }\n  }, {\n    key: \"map\",\n    value: function map(options) {\n      var key = options ? JSON.stringify(options) : \"{}\";\n\n      var cacheEntry = this._cachedMaps.get(key);\n\n      if (cacheEntry !== undefined) {\n        return this._getMapFromCacheEntry(cacheEntry);\n      }\n\n      var map = this.original().map(options);\n\n      this._cachedMaps.set(key, {\n        map: map,\n        bufferedMap: undefined\n      });\n\n      return map;\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      if (this._cachedHashUpdate !== undefined) {\n        var _iterator2 = _createForOfIteratorHelper(this._cachedHashUpdate),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var item = _step2.value;\n            hash.update(item);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        return;\n      }\n\n      var _update = [];\n      var currentString = undefined;\n      var tracker = {\n        update: function update(item) {\n          if (typeof item === \"string\" && item.length < 10240) {\n            if (currentString === undefined) {\n              currentString = item;\n            } else {\n              currentString += item;\n\n              if (currentString.length > 102400) {\n                _update.push(Buffer.from(currentString));\n\n                currentString = undefined;\n              }\n            }\n          } else {\n            if (currentString !== undefined) {\n              _update.push(Buffer.from(currentString));\n\n              currentString = undefined;\n            }\n\n            _update.push(item);\n          }\n        }\n      };\n      this.original().updateHash(tracker);\n\n      if (currentString !== undefined) {\n        _update.push(Buffer.from(currentString));\n      }\n\n      for (var _i = 0, _update2 = _update; _i < _update2.length; _i++) {\n        var _item = _update2[_i];\n        hash.update(_item);\n      }\n\n      this._cachedHashUpdate = _update;\n    }\n  }]);\n\n  return CachedSource;\n}(Source);\n\nmodule.exports = CachedSource;","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/webpack-sources/lib/CachedSource.js"],"names":["Source","require","streamChunksOfSourceMap","streamChunksOfRawSource","streamAndGetSourceAndMap","mapToBufferedMap","map","bufferedMap","Object","assign","mappings","Buffer","from","sourcesContent","str","bufferedMapToMap","toString","buffer","CachedSource","source","cachedData","_source","_cachedSourceType","undefined","_cachedSource","_cachedBuffer","_cachedSize","size","_cachedMaps","maps","Map","_cachedHashUpdate","hash","bufferedMaps","pair","cacheEntry","_getMapFromCacheEntry","set","isBuffer","_getCachedSource","original","bufferOrString","length","byteLength","options","key","JSON","stringify","get","sourceAndMap","onChunk","onSource","onName","has","finalSource","result","item","update","currentString","tracker","push","updateHash","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Source = require(\"./Source\");\nconst streamChunksOfSourceMap = require(\"./helpers/streamChunksOfSourceMap\");\nconst streamChunksOfRawSource = require(\"./helpers/streamChunksOfRawSource\");\nconst streamAndGetSourceAndMap = require(\"./helpers/streamAndGetSourceAndMap\");\n\nconst mapToBufferedMap = map => {\n\tif (typeof map !== \"object\" || !map) return map;\n\tconst bufferedMap = Object.assign({}, map);\n\tif (map.mappings) {\n\t\tbufferedMap.mappings = Buffer.from(map.mappings, \"utf-8\");\n\t}\n\tif (map.sourcesContent) {\n\t\tbufferedMap.sourcesContent = map.sourcesContent.map(\n\t\t\tstr => str && Buffer.from(str, \"utf-8\")\n\t\t);\n\t}\n\treturn bufferedMap;\n};\n\nconst bufferedMapToMap = bufferedMap => {\n\tif (typeof bufferedMap !== \"object\" || !bufferedMap) return bufferedMap;\n\tconst map = Object.assign({}, bufferedMap);\n\tif (bufferedMap.mappings) {\n\t\tmap.mappings = bufferedMap.mappings.toString(\"utf-8\");\n\t}\n\tif (bufferedMap.sourcesContent) {\n\t\tmap.sourcesContent = bufferedMap.sourcesContent.map(\n\t\t\tbuffer => buffer && buffer.toString(\"utf-8\")\n\t\t);\n\t}\n\treturn map;\n};\n\nclass CachedSource extends Source {\n\tconstructor(source, cachedData) {\n\t\tsuper();\n\t\tthis._source = source;\n\t\tthis._cachedSourceType = cachedData ? cachedData.source : undefined;\n\t\tthis._cachedSource = undefined;\n\t\tthis._cachedBuffer = cachedData ? cachedData.buffer : undefined;\n\t\tthis._cachedSize = cachedData ? cachedData.size : undefined;\n\t\tthis._cachedMaps = cachedData ? cachedData.maps : new Map();\n\t\tthis._cachedHashUpdate = cachedData ? cachedData.hash : undefined;\n\t}\n\n\tgetCachedData() {\n\t\tconst bufferedMaps = new Map();\n\t\tfor (const pair of this._cachedMaps) {\n\t\t\tlet cacheEntry = pair[1];\n\t\t\tif (cacheEntry.bufferedMap === undefined) {\n\t\t\t\tcacheEntry.bufferedMap = mapToBufferedMap(\n\t\t\t\t\tthis._getMapFromCacheEntry(cacheEntry)\n\t\t\t\t);\n\t\t\t}\n\t\t\tbufferedMaps.set(pair[0], {\n\t\t\t\tmap: undefined,\n\t\t\t\tbufferedMap: cacheEntry.bufferedMap\n\t\t\t});\n\t\t}\n\t\t// We don't want to cache strings\n\t\t// So if we have a caches sources\n\t\t// create a buffer from it and only store\n\t\t// if it was a Buffer or string\n\t\tif (this._cachedSource) {\n\t\t\tthis.buffer();\n\t\t}\n\t\treturn {\n\t\t\tbuffer: this._cachedBuffer,\n\t\t\tsource:\n\t\t\t\tthis._cachedSourceType !== undefined\n\t\t\t\t\t? this._cachedSourceType\n\t\t\t\t\t: typeof this._cachedSource === \"string\"\n\t\t\t\t\t? true\n\t\t\t\t\t: Buffer.isBuffer(this._cachedSource)\n\t\t\t\t\t? false\n\t\t\t\t\t: undefined,\n\t\t\tsize: this._cachedSize,\n\t\t\tmaps: bufferedMaps,\n\t\t\thash: this._cachedHashUpdate\n\t\t};\n\t}\n\n\toriginalLazy() {\n\t\treturn this._source;\n\t}\n\n\toriginal() {\n\t\tif (typeof this._source === \"function\") this._source = this._source();\n\t\treturn this._source;\n\t}\n\n\tsource() {\n\t\tconst source = this._getCachedSource();\n\t\tif (source !== undefined) return source;\n\t\treturn (this._cachedSource = this.original().source());\n\t}\n\n\t_getMapFromCacheEntry(cacheEntry) {\n\t\tif (cacheEntry.map !== undefined) {\n\t\t\treturn cacheEntry.map;\n\t\t} else if (cacheEntry.bufferedMap !== undefined) {\n\t\t\treturn (cacheEntry.map = bufferedMapToMap(cacheEntry.bufferedMap));\n\t\t}\n\t}\n\n\t_getCachedSource() {\n\t\tif (this._cachedSource !== undefined) return this._cachedSource;\n\t\tif (this._cachedBuffer && this._cachedSourceType !== undefined) {\n\t\t\treturn (this._cachedSource = this._cachedSourceType\n\t\t\t\t? this._cachedBuffer.toString(\"utf-8\")\n\t\t\t\t: this._cachedBuffer);\n\t\t}\n\t}\n\n\tbuffer() {\n\t\tif (this._cachedBuffer !== undefined) return this._cachedBuffer;\n\t\tif (this._cachedSource !== undefined) {\n\t\t\tif (Buffer.isBuffer(this._cachedSource)) {\n\t\t\t\treturn (this._cachedBuffer = this._cachedSource);\n\t\t\t}\n\t\t\treturn (this._cachedBuffer = Buffer.from(this._cachedSource, \"utf-8\"));\n\t\t}\n\t\tif (typeof this.original().buffer === \"function\") {\n\t\t\treturn (this._cachedBuffer = this.original().buffer());\n\t\t}\n\t\tconst bufferOrString = this.source();\n\t\tif (Buffer.isBuffer(bufferOrString)) {\n\t\t\treturn (this._cachedBuffer = bufferOrString);\n\t\t}\n\t\treturn (this._cachedBuffer = Buffer.from(bufferOrString, \"utf-8\"));\n\t}\n\n\tsize() {\n\t\tif (this._cachedSize !== undefined) return this._cachedSize;\n\t\tif (this._cachedBuffer !== undefined) {\n\t\t\treturn (this._cachedSize = this._cachedBuffer.length);\n\t\t}\n\t\tconst source = this._getCachedSource();\n\t\tif (source !== undefined) {\n\t\t\treturn (this._cachedSize = Buffer.byteLength(source));\n\t\t}\n\t\treturn (this._cachedSize = this.original().size());\n\t}\n\n\tsourceAndMap(options) {\n\t\tconst key = options ? JSON.stringify(options) : \"{}\";\n\t\tconst cacheEntry = this._cachedMaps.get(key);\n\t\t// Look for a cached map\n\t\tif (cacheEntry !== undefined) {\n\t\t\t// We have a cached map in some representation\n\t\t\tconst map = this._getMapFromCacheEntry(cacheEntry);\n\t\t\t// Either get the cached source or compute it\n\t\t\treturn { source: this.source(), map };\n\t\t}\n\t\t// Look for a cached source\n\t\tlet source = this._getCachedSource();\n\t\t// Compute the map\n\t\tlet map;\n\t\tif (source !== undefined) {\n\t\t\tmap = this.original().map(options);\n\t\t} else {\n\t\t\t// Compute the source and map together.\n\t\t\tconst sourceAndMap = this.original().sourceAndMap(options);\n\t\t\tsource = sourceAndMap.source;\n\t\t\tmap = sourceAndMap.map;\n\t\t\tthis._cachedSource = source;\n\t\t}\n\t\tthis._cachedMaps.set(key, {\n\t\t\tmap,\n\t\t\tbufferedMap: undefined\n\t\t});\n\t\treturn { source, map };\n\t}\n\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tconst key = options ? JSON.stringify(options) : \"{}\";\n\t\tif (\n\t\t\tthis._cachedMaps.has(key) &&\n\t\t\t(this._cachedBuffer !== undefined || this._cachedSource !== undefined)\n\t\t) {\n\t\t\tconst { source, map } = this.sourceAndMap(options);\n\t\t\tif (map) {\n\t\t\t\treturn streamChunksOfSourceMap(\n\t\t\t\t\tsource,\n\t\t\t\t\tmap,\n\t\t\t\t\tonChunk,\n\t\t\t\t\tonSource,\n\t\t\t\t\tonName,\n\t\t\t\t\t!!(options && options.finalSource),\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\treturn streamChunksOfRawSource(\n\t\t\t\t\tsource,\n\t\t\t\t\tonChunk,\n\t\t\t\t\tonSource,\n\t\t\t\t\tonName,\n\t\t\t\t\t!!(options && options.finalSource)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tconst { result, source, map } = streamAndGetSourceAndMap(\n\t\t\tthis.original(),\n\t\t\toptions,\n\t\t\tonChunk,\n\t\t\tonSource,\n\t\t\tonName\n\t\t);\n\t\tthis._cachedSource = source;\n\t\tthis._cachedMaps.set(key, {\n\t\t\tmap,\n\t\t\tbufferedMap: undefined\n\t\t});\n\t\treturn result;\n\t}\n\n\tmap(options) {\n\t\tconst key = options ? JSON.stringify(options) : \"{}\";\n\t\tconst cacheEntry = this._cachedMaps.get(key);\n\t\tif (cacheEntry !== undefined) {\n\t\t\treturn this._getMapFromCacheEntry(cacheEntry);\n\t\t}\n\t\tconst map = this.original().map(options);\n\t\tthis._cachedMaps.set(key, {\n\t\t\tmap,\n\t\t\tbufferedMap: undefined\n\t\t});\n\t\treturn map;\n\t}\n\n\tupdateHash(hash) {\n\t\tif (this._cachedHashUpdate !== undefined) {\n\t\t\tfor (const item of this._cachedHashUpdate) hash.update(item);\n\t\t\treturn;\n\t\t}\n\t\tconst update = [];\n\t\tlet currentString = undefined;\n\t\tconst tracker = {\n\t\t\tupdate: item => {\n\t\t\t\tif (typeof item === \"string\" && item.length < 10240) {\n\t\t\t\t\tif (currentString === undefined) {\n\t\t\t\t\t\tcurrentString = item;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentString += item;\n\t\t\t\t\t\tif (currentString.length > 102400) {\n\t\t\t\t\t\t\tupdate.push(Buffer.from(currentString));\n\t\t\t\t\t\t\tcurrentString = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (currentString !== undefined) {\n\t\t\t\t\t\tupdate.push(Buffer.from(currentString));\n\t\t\t\t\t\tcurrentString = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tupdate.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthis.original().updateHash(tracker);\n\t\tif (currentString !== undefined) {\n\t\t\tupdate.push(Buffer.from(currentString));\n\t\t}\n\t\tfor (const item of update) hash.update(item);\n\t\tthis._cachedHashUpdate = update;\n\t}\n}\n\nmodule.exports = CachedSource;\n"]},"metadata":{},"sourceType":"script"}