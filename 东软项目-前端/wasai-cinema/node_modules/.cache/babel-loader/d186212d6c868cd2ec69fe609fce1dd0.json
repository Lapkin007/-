{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _typeof = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/typeof.js\").default;\n\nvar _toArray = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/toArray.js\").default;\n\nvar _slicedToArray = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _asyncToGenerator = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _objectSpread = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nrequire(\"regenerator-runtime/runtime.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.array.filter.js\");\n\nrequire(\"core-js/modules/es.string.starts-with.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nvar path = require('path');\n\nvar childProcess = require('child_process');\n\nvar crossSpawn = require('cross-spawn');\n\nvar stripFinalNewline = require('strip-final-newline');\n\nvar npmRunPath = require('npm-run-path');\n\nvar onetime = require('onetime');\n\nvar makeError = require('./lib/error');\n\nvar normalizeStdio = require('./lib/stdio');\n\nvar _require = require('./lib/kill'),\n    spawnedKill = _require.spawnedKill,\n    spawnedCancel = _require.spawnedCancel,\n    setupTimeout = _require.setupTimeout,\n    validateTimeout = _require.validateTimeout,\n    setExitHandler = _require.setExitHandler;\n\nvar _require2 = require('./lib/stream'),\n    handleInput = _require2.handleInput,\n    getSpawnedResult = _require2.getSpawnedResult,\n    makeAllStream = _require2.makeAllStream,\n    validateInputSync = _require2.validateInputSync;\n\nvar _require3 = require('./lib/promise'),\n    mergePromise = _require3.mergePromise,\n    getSpawnedPromise = _require3.getSpawnedPromise;\n\nvar _require4 = require('./lib/command'),\n    joinCommand = _require4.joinCommand,\n    parseCommand = _require4.parseCommand,\n    getEscapedCommand = _require4.getEscapedCommand;\n\nvar DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;\n\nvar getEnv = function getEnv(_ref) {\n  var envOption = _ref.env,\n      extendEnv = _ref.extendEnv,\n      preferLocal = _ref.preferLocal,\n      localDir = _ref.localDir,\n      execPath = _ref.execPath;\n  var env = extendEnv ? _objectSpread(_objectSpread({}, process.env), envOption) : envOption;\n\n  if (preferLocal) {\n    return npmRunPath.env({\n      env: env,\n      cwd: localDir,\n      execPath: execPath\n    });\n  }\n\n  return env;\n};\n\nvar handleArguments = function handleArguments(file, args) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var parsed = crossSpawn._parse(file, args, options);\n\n  file = parsed.command;\n  args = parsed.args;\n  options = parsed.options;\n  options = _objectSpread({\n    maxBuffer: DEFAULT_MAX_BUFFER,\n    buffer: true,\n    stripFinalNewline: true,\n    extendEnv: true,\n    preferLocal: false,\n    localDir: options.cwd || process.cwd(),\n    execPath: process.execPath,\n    encoding: 'utf8',\n    reject: true,\n    cleanup: true,\n    all: false,\n    windowsHide: true\n  }, options);\n  options.env = getEnv(options);\n  options.stdio = normalizeStdio(options);\n\n  if (process.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {\n    // #116\n    args.unshift('/q');\n  }\n\n  return {\n    file: file,\n    args: args,\n    options: options,\n    parsed: parsed\n  };\n};\n\nvar handleOutput = function handleOutput(options, value, error) {\n  if (typeof value !== 'string' && !Buffer.isBuffer(value)) {\n    // When `execa.sync()` errors, we normalize it to '' to mimic `execa()`\n    return error === undefined ? undefined : '';\n  }\n\n  if (options.stripFinalNewline) {\n    return stripFinalNewline(value);\n  }\n\n  return value;\n};\n\nvar execa = function execa(file, args, options) {\n  var parsed = handleArguments(file, args, options);\n  var command = joinCommand(file, args);\n  var escapedCommand = getEscapedCommand(file, args);\n  validateTimeout(parsed.options);\n  var spawned;\n\n  try {\n    spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);\n  } catch (error) {\n    // Ensure the returned error is always both a promise and a child process\n    var dummySpawned = new childProcess.ChildProcess();\n    var errorPromise = Promise.reject(makeError({\n      error: error,\n      stdout: '',\n      stderr: '',\n      all: '',\n      command: command,\n      escapedCommand: escapedCommand,\n      parsed: parsed,\n      timedOut: false,\n      isCanceled: false,\n      killed: false\n    }));\n    return mergePromise(dummySpawned, errorPromise);\n  }\n\n  var spawnedPromise = getSpawnedPromise(spawned);\n  var timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);\n  var processDone = setExitHandler(spawned, parsed.options, timedPromise);\n  var context = {\n    isCanceled: false\n  };\n  spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));\n  spawned.cancel = spawnedCancel.bind(null, spawned, context);\n\n  var handlePromise = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n      var _yield$getSpawnedResu, _yield$getSpawnedResu2, _yield$getSpawnedResu3, error, exitCode, signal, timedOut, stdoutResult, stderrResult, allResult, stdout, stderr, all, returnedError;\n\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return getSpawnedResult(spawned, parsed.options, processDone);\n\n            case 2:\n              _yield$getSpawnedResu = _context.sent;\n              _yield$getSpawnedResu2 = _slicedToArray(_yield$getSpawnedResu, 4);\n              _yield$getSpawnedResu3 = _yield$getSpawnedResu2[0];\n              error = _yield$getSpawnedResu3.error;\n              exitCode = _yield$getSpawnedResu3.exitCode;\n              signal = _yield$getSpawnedResu3.signal;\n              timedOut = _yield$getSpawnedResu3.timedOut;\n              stdoutResult = _yield$getSpawnedResu2[1];\n              stderrResult = _yield$getSpawnedResu2[2];\n              allResult = _yield$getSpawnedResu2[3];\n              stdout = handleOutput(parsed.options, stdoutResult);\n              stderr = handleOutput(parsed.options, stderrResult);\n              all = handleOutput(parsed.options, allResult);\n\n              if (!(error || exitCode !== 0 || signal !== null)) {\n                _context.next = 20;\n                break;\n              }\n\n              returnedError = makeError({\n                error: error,\n                exitCode: exitCode,\n                signal: signal,\n                stdout: stdout,\n                stderr: stderr,\n                all: all,\n                command: command,\n                escapedCommand: escapedCommand,\n                parsed: parsed,\n                timedOut: timedOut,\n                isCanceled: context.isCanceled,\n                killed: spawned.killed\n              });\n\n              if (parsed.options.reject) {\n                _context.next = 19;\n                break;\n              }\n\n              return _context.abrupt(\"return\", returnedError);\n\n            case 19:\n              throw returnedError;\n\n            case 20:\n              return _context.abrupt(\"return\", {\n                command: command,\n                escapedCommand: escapedCommand,\n                exitCode: 0,\n                stdout: stdout,\n                stderr: stderr,\n                all: all,\n                failed: false,\n                timedOut: false,\n                isCanceled: false,\n                killed: false\n              });\n\n            case 21:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function handlePromise() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  var handlePromiseOnce = onetime(handlePromise);\n  handleInput(spawned, parsed.options.input);\n  spawned.all = makeAllStream(spawned, parsed.options);\n  return mergePromise(spawned, handlePromiseOnce);\n};\n\nmodule.exports = execa;\n\nmodule.exports.sync = function (file, args, options) {\n  var parsed = handleArguments(file, args, options);\n  var command = joinCommand(file, args);\n  var escapedCommand = getEscapedCommand(file, args);\n  validateInputSync(parsed.options);\n  var result;\n\n  try {\n    result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);\n  } catch (error) {\n    throw makeError({\n      error: error,\n      stdout: '',\n      stderr: '',\n      all: '',\n      command: command,\n      escapedCommand: escapedCommand,\n      parsed: parsed,\n      timedOut: false,\n      isCanceled: false,\n      killed: false\n    });\n  }\n\n  var stdout = handleOutput(parsed.options, result.stdout, result.error);\n  var stderr = handleOutput(parsed.options, result.stderr, result.error);\n\n  if (result.error || result.status !== 0 || result.signal !== null) {\n    var error = makeError({\n      stdout: stdout,\n      stderr: stderr,\n      error: result.error,\n      signal: result.signal,\n      exitCode: result.status,\n      command: command,\n      escapedCommand: escapedCommand,\n      parsed: parsed,\n      timedOut: result.error && result.error.code === 'ETIMEDOUT',\n      isCanceled: false,\n      killed: result.signal !== null\n    });\n\n    if (!parsed.options.reject) {\n      return error;\n    }\n\n    throw error;\n  }\n\n  return {\n    command: command,\n    escapedCommand: escapedCommand,\n    exitCode: 0,\n    stdout: stdout,\n    stderr: stderr,\n    failed: false,\n    timedOut: false,\n    isCanceled: false,\n    killed: false\n  };\n};\n\nmodule.exports.command = function (command, options) {\n  var _parseCommand = parseCommand(command),\n      _parseCommand2 = _toArray(_parseCommand),\n      file = _parseCommand2[0],\n      args = _parseCommand2.slice(1);\n\n  return execa(file, args, options);\n};\n\nmodule.exports.commandSync = function (command, options) {\n  var _parseCommand3 = parseCommand(command),\n      _parseCommand4 = _toArray(_parseCommand3),\n      file = _parseCommand4[0],\n      args = _parseCommand4.slice(1);\n\n  return execa.sync(file, args, options);\n};\n\nmodule.exports.node = function (scriptPath, args) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (args && !Array.isArray(args) && _typeof(args) === 'object') {\n    options = args;\n    args = [];\n  }\n\n  var stdio = normalizeStdio.node(options);\n  var defaultExecArgv = process.execArgv.filter(function (arg) {\n    return !arg.startsWith('--inspect');\n  });\n  var _options = options,\n      _options$nodePath = _options.nodePath,\n      nodePath = _options$nodePath === void 0 ? process.execPath : _options$nodePath,\n      _options$nodeOptions = _options.nodeOptions,\n      nodeOptions = _options$nodeOptions === void 0 ? defaultExecArgv : _options$nodeOptions;\n  return execa(nodePath, [].concat(_toConsumableArray(nodeOptions), [scriptPath], _toConsumableArray(Array.isArray(args) ? args : [])), _objectSpread(_objectSpread({}, options), {}, {\n    stdin: undefined,\n    stdout: undefined,\n    stderr: undefined,\n    stdio: stdio,\n    shell: false\n  }));\n};","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/default-gateway/node_modules/execa/index.js"],"names":["path","require","childProcess","crossSpawn","stripFinalNewline","npmRunPath","onetime","makeError","normalizeStdio","spawnedKill","spawnedCancel","setupTimeout","validateTimeout","setExitHandler","handleInput","getSpawnedResult","makeAllStream","validateInputSync","mergePromise","getSpawnedPromise","joinCommand","parseCommand","getEscapedCommand","DEFAULT_MAX_BUFFER","getEnv","envOption","env","extendEnv","preferLocal","localDir","execPath","process","cwd","handleArguments","file","args","options","parsed","_parse","command","maxBuffer","buffer","encoding","reject","cleanup","all","windowsHide","stdio","platform","basename","unshift","handleOutput","value","error","Buffer","isBuffer","undefined","execa","escapedCommand","spawned","spawn","dummySpawned","ChildProcess","errorPromise","Promise","stdout","stderr","timedOut","isCanceled","killed","spawnedPromise","timedPromise","processDone","context","kill","bind","cancel","handlePromise","exitCode","signal","stdoutResult","stderrResult","allResult","returnedError","failed","handlePromiseOnce","input","module","exports","sync","result","spawnSync","status","code","commandSync","node","scriptPath","Array","isArray","defaultExecArgv","execArgv","filter","arg","startsWith","nodePath","nodeOptions","stdin","shell"],"mappings":"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","sourcesContent":["'use strict';\nconst path = require('path');\nconst childProcess = require('child_process');\nconst crossSpawn = require('cross-spawn');\nconst stripFinalNewline = require('strip-final-newline');\nconst npmRunPath = require('npm-run-path');\nconst onetime = require('onetime');\nconst makeError = require('./lib/error');\nconst normalizeStdio = require('./lib/stdio');\nconst {spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler} = require('./lib/kill');\nconst {handleInput, getSpawnedResult, makeAllStream, validateInputSync} = require('./lib/stream');\nconst {mergePromise, getSpawnedPromise} = require('./lib/promise');\nconst {joinCommand, parseCommand, getEscapedCommand} = require('./lib/command');\n\nconst DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;\n\nconst getEnv = ({env: envOption, extendEnv, preferLocal, localDir, execPath}) => {\n\tconst env = extendEnv ? {...process.env, ...envOption} : envOption;\n\n\tif (preferLocal) {\n\t\treturn npmRunPath.env({env, cwd: localDir, execPath});\n\t}\n\n\treturn env;\n};\n\nconst handleArguments = (file, args, options = {}) => {\n\tconst parsed = crossSpawn._parse(file, args, options);\n\tfile = parsed.command;\n\targs = parsed.args;\n\toptions = parsed.options;\n\n\toptions = {\n\t\tmaxBuffer: DEFAULT_MAX_BUFFER,\n\t\tbuffer: true,\n\t\tstripFinalNewline: true,\n\t\textendEnv: true,\n\t\tpreferLocal: false,\n\t\tlocalDir: options.cwd || process.cwd(),\n\t\texecPath: process.execPath,\n\t\tencoding: 'utf8',\n\t\treject: true,\n\t\tcleanup: true,\n\t\tall: false,\n\t\twindowsHide: true,\n\t\t...options\n\t};\n\n\toptions.env = getEnv(options);\n\n\toptions.stdio = normalizeStdio(options);\n\n\tif (process.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {\n\t\t// #116\n\t\targs.unshift('/q');\n\t}\n\n\treturn {file, args, options, parsed};\n};\n\nconst handleOutput = (options, value, error) => {\n\tif (typeof value !== 'string' && !Buffer.isBuffer(value)) {\n\t\t// When `execa.sync()` errors, we normalize it to '' to mimic `execa()`\n\t\treturn error === undefined ? undefined : '';\n\t}\n\n\tif (options.stripFinalNewline) {\n\t\treturn stripFinalNewline(value);\n\t}\n\n\treturn value;\n};\n\nconst execa = (file, args, options) => {\n\tconst parsed = handleArguments(file, args, options);\n\tconst command = joinCommand(file, args);\n\tconst escapedCommand = getEscapedCommand(file, args);\n\n\tvalidateTimeout(parsed.options);\n\n\tlet spawned;\n\ttry {\n\t\tspawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);\n\t} catch (error) {\n\t\t// Ensure the returned error is always both a promise and a child process\n\t\tconst dummySpawned = new childProcess.ChildProcess();\n\t\tconst errorPromise = Promise.reject(makeError({\n\t\t\terror,\n\t\t\tstdout: '',\n\t\t\tstderr: '',\n\t\t\tall: '',\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tparsed,\n\t\t\ttimedOut: false,\n\t\t\tisCanceled: false,\n\t\t\tkilled: false\n\t\t}));\n\t\treturn mergePromise(dummySpawned, errorPromise);\n\t}\n\n\tconst spawnedPromise = getSpawnedPromise(spawned);\n\tconst timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);\n\tconst processDone = setExitHandler(spawned, parsed.options, timedPromise);\n\n\tconst context = {isCanceled: false};\n\n\tspawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));\n\tspawned.cancel = spawnedCancel.bind(null, spawned, context);\n\n\tconst handlePromise = async () => {\n\t\tconst [{error, exitCode, signal, timedOut}, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);\n\t\tconst stdout = handleOutput(parsed.options, stdoutResult);\n\t\tconst stderr = handleOutput(parsed.options, stderrResult);\n\t\tconst all = handleOutput(parsed.options, allResult);\n\n\t\tif (error || exitCode !== 0 || signal !== null) {\n\t\t\tconst returnedError = makeError({\n\t\t\t\terror,\n\t\t\t\texitCode,\n\t\t\t\tsignal,\n\t\t\t\tstdout,\n\t\t\t\tstderr,\n\t\t\t\tall,\n\t\t\t\tcommand,\n\t\t\t\tescapedCommand,\n\t\t\t\tparsed,\n\t\t\t\ttimedOut,\n\t\t\t\tisCanceled: context.isCanceled,\n\t\t\t\tkilled: spawned.killed\n\t\t\t});\n\n\t\t\tif (!parsed.options.reject) {\n\t\t\t\treturn returnedError;\n\t\t\t}\n\n\t\t\tthrow returnedError;\n\t\t}\n\n\t\treturn {\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\texitCode: 0,\n\t\t\tstdout,\n\t\t\tstderr,\n\t\t\tall,\n\t\t\tfailed: false,\n\t\t\ttimedOut: false,\n\t\t\tisCanceled: false,\n\t\t\tkilled: false\n\t\t};\n\t};\n\n\tconst handlePromiseOnce = onetime(handlePromise);\n\n\thandleInput(spawned, parsed.options.input);\n\n\tspawned.all = makeAllStream(spawned, parsed.options);\n\n\treturn mergePromise(spawned, handlePromiseOnce);\n};\n\nmodule.exports = execa;\n\nmodule.exports.sync = (file, args, options) => {\n\tconst parsed = handleArguments(file, args, options);\n\tconst command = joinCommand(file, args);\n\tconst escapedCommand = getEscapedCommand(file, args);\n\n\tvalidateInputSync(parsed.options);\n\n\tlet result;\n\ttry {\n\t\tresult = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);\n\t} catch (error) {\n\t\tthrow makeError({\n\t\t\terror,\n\t\t\tstdout: '',\n\t\t\tstderr: '',\n\t\t\tall: '',\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tparsed,\n\t\t\ttimedOut: false,\n\t\t\tisCanceled: false,\n\t\t\tkilled: false\n\t\t});\n\t}\n\n\tconst stdout = handleOutput(parsed.options, result.stdout, result.error);\n\tconst stderr = handleOutput(parsed.options, result.stderr, result.error);\n\n\tif (result.error || result.status !== 0 || result.signal !== null) {\n\t\tconst error = makeError({\n\t\t\tstdout,\n\t\t\tstderr,\n\t\t\terror: result.error,\n\t\t\tsignal: result.signal,\n\t\t\texitCode: result.status,\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tparsed,\n\t\t\ttimedOut: result.error && result.error.code === 'ETIMEDOUT',\n\t\t\tisCanceled: false,\n\t\t\tkilled: result.signal !== null\n\t\t});\n\n\t\tif (!parsed.options.reject) {\n\t\t\treturn error;\n\t\t}\n\n\t\tthrow error;\n\t}\n\n\treturn {\n\t\tcommand,\n\t\tescapedCommand,\n\t\texitCode: 0,\n\t\tstdout,\n\t\tstderr,\n\t\tfailed: false,\n\t\ttimedOut: false,\n\t\tisCanceled: false,\n\t\tkilled: false\n\t};\n};\n\nmodule.exports.command = (command, options) => {\n\tconst [file, ...args] = parseCommand(command);\n\treturn execa(file, args, options);\n};\n\nmodule.exports.commandSync = (command, options) => {\n\tconst [file, ...args] = parseCommand(command);\n\treturn execa.sync(file, args, options);\n};\n\nmodule.exports.node = (scriptPath, args, options = {}) => {\n\tif (args && !Array.isArray(args) && typeof args === 'object') {\n\t\toptions = args;\n\t\targs = [];\n\t}\n\n\tconst stdio = normalizeStdio.node(options);\n\tconst defaultExecArgv = process.execArgv.filter(arg => !arg.startsWith('--inspect'));\n\n\tconst {\n\t\tnodePath = process.execPath,\n\t\tnodeOptions = defaultExecArgv\n\t} = options;\n\n\treturn execa(\n\t\tnodePath,\n\t\t[\n\t\t\t...nodeOptions,\n\t\t\tscriptPath,\n\t\t\t...(Array.isArray(args) ? args : [])\n\t\t],\n\t\t{\n\t\t\t...options,\n\t\t\tstdin: undefined,\n\t\t\tstdout: undefined,\n\t\t\tstderr: undefined,\n\t\t\tstdio,\n\t\t\tshell: false\n\t\t}\n\t);\n};\n"]},"metadata":{},"sourceType":"script"}