{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.includes.js\");\n\nrequire(\"core-js/modules/es.string.includes.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.regexp.test.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.string.starts-with.js\");\n\nrequire(\"core-js/modules/es.array.filter.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.string.ends-with.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\n\nvar path = require(\"path\");\n\nvar globParent = require(\"glob-parent\");\n\nvar micromatch = require(\"micromatch\");\n\nvar GLOBSTAR = '**';\nvar ESCAPE_SYMBOL = '\\\\';\nvar COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\nvar REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[[^[]*]/;\nvar REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\([^(]*\\|[^|]*\\)/;\nvar GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\([^(]*\\)/;\nvar BRACE_EXPANSION_SEPARATORS_RE = /,|\\.\\./;\n\nfunction isStaticPattern(pattern) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return !isDynamicPattern(pattern, options);\n}\n\nexports.isStaticPattern = isStaticPattern;\n\nfunction isDynamicPattern(pattern) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  /**\n   * A special case with an empty string is necessary for matching patterns that start with a forward slash.\n   * An empty string cannot be a dynamic pattern.\n   * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\n   */\n  if (pattern === '') {\n    return false;\n  }\n  /**\n   * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\n   * filepath directly (without read directory).\n   */\n\n\n  if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\n    return true;\n  }\n\n  if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n\n  if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n\n  if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.isDynamicPattern = isDynamicPattern;\n\nfunction hasBraceExpansion(pattern) {\n  var openingBraceIndex = pattern.indexOf('{');\n\n  if (openingBraceIndex === -1) {\n    return false;\n  }\n\n  var closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);\n\n  if (closingBraceIndex === -1) {\n    return false;\n  }\n\n  var braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);\n  return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);\n}\n\nfunction convertToPositivePattern(pattern) {\n  return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\n}\n\nexports.convertToPositivePattern = convertToPositivePattern;\n\nfunction convertToNegativePattern(pattern) {\n  return '!' + pattern;\n}\n\nexports.convertToNegativePattern = convertToNegativePattern;\n\nfunction isNegativePattern(pattern) {\n  return pattern.startsWith('!') && pattern[1] !== '(';\n}\n\nexports.isNegativePattern = isNegativePattern;\n\nfunction isPositivePattern(pattern) {\n  return !isNegativePattern(pattern);\n}\n\nexports.isPositivePattern = isPositivePattern;\n\nfunction getNegativePatterns(patterns) {\n  return patterns.filter(isNegativePattern);\n}\n\nexports.getNegativePatterns = getNegativePatterns;\n\nfunction getPositivePatterns(patterns) {\n  return patterns.filter(isPositivePattern);\n}\n\nexports.getPositivePatterns = getPositivePatterns;\n/**\n * Returns patterns that can be applied inside the current directory.\n *\n * @example\n * // ['./*', '*', 'a/*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\n\nfunction getPatternsInsideCurrentDirectory(patterns) {\n  return patterns.filter(function (pattern) {\n    return !isPatternRelatedToParentDirectory(pattern);\n  });\n}\n\nexports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;\n/**\n * Returns patterns to be expanded relative to (outside) the current directory.\n *\n * @example\n * // ['../*', './../*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\n\nfunction getPatternsOutsideCurrentDirectory(patterns) {\n  return patterns.filter(isPatternRelatedToParentDirectory);\n}\n\nexports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;\n\nfunction isPatternRelatedToParentDirectory(pattern) {\n  return pattern.startsWith('..') || pattern.startsWith('./..');\n}\n\nexports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;\n\nfunction getBaseDirectory(pattern) {\n  return globParent(pattern, {\n    flipBackslashes: false\n  });\n}\n\nexports.getBaseDirectory = getBaseDirectory;\n\nfunction hasGlobStar(pattern) {\n  return pattern.includes(GLOBSTAR);\n}\n\nexports.hasGlobStar = hasGlobStar;\n\nfunction endsWithSlashGlobStar(pattern) {\n  return pattern.endsWith('/' + GLOBSTAR);\n}\n\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\n\nfunction isAffectDepthOfReadingPattern(pattern) {\n  var basename = path.basename(pattern);\n  return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\n}\n\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\n\nfunction expandPatternsWithBraceExpansion(patterns) {\n  return patterns.reduce(function (collection, pattern) {\n    return collection.concat(expandBraceExpansion(pattern));\n  }, []);\n}\n\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\n\nfunction expandBraceExpansion(pattern) {\n  return micromatch.braces(pattern, {\n    expand: true,\n    nodupes: true\n  });\n}\n\nexports.expandBraceExpansion = expandBraceExpansion;\n\nfunction getPatternParts(pattern, options) {\n  var _micromatch$scan = micromatch.scan(pattern, Object.assign(Object.assign({}, options), {\n    parts: true\n  })),\n      parts = _micromatch$scan.parts;\n  /**\n   * The scan method returns an empty array in some cases.\n   * See micromatch/picomatch#58 for more details.\n   */\n\n\n  if (parts.length === 0) {\n    parts = [pattern];\n  }\n  /**\n   * The scan method does not return an empty part for the pattern with a forward slash.\n   * This is another part of micromatch/picomatch#58.\n   */\n\n\n  if (parts[0].startsWith('/')) {\n    parts[0] = parts[0].slice(1);\n    parts.unshift('');\n  }\n\n  return parts;\n}\n\nexports.getPatternParts = getPatternParts;\n\nfunction makeRe(pattern, options) {\n  return micromatch.makeRe(pattern, options);\n}\n\nexports.makeRe = makeRe;\n\nfunction convertPatternsToRe(patterns, options) {\n  return patterns.map(function (pattern) {\n    return makeRe(pattern, options);\n  });\n}\n\nexports.convertPatternsToRe = convertPatternsToRe;\n\nfunction matchAny(entry, patternsRe) {\n  return patternsRe.some(function (patternRe) {\n    return patternRe.test(entry);\n  });\n}\n\nexports.matchAny = matchAny;","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/fast-glob/out/utils/pattern.js"],"names":["Object","defineProperty","exports","value","matchAny","convertPatternsToRe","makeRe","getPatternParts","expandBraceExpansion","expandPatternsWithBraceExpansion","isAffectDepthOfReadingPattern","endsWithSlashGlobStar","hasGlobStar","getBaseDirectory","isPatternRelatedToParentDirectory","getPatternsOutsideCurrentDirectory","getPatternsInsideCurrentDirectory","getPositivePatterns","getNegativePatterns","isPositivePattern","isNegativePattern","convertToNegativePattern","convertToPositivePattern","isDynamicPattern","isStaticPattern","path","require","globParent","micromatch","GLOBSTAR","ESCAPE_SYMBOL","COMMON_GLOB_SYMBOLS_RE","REGEX_CHARACTER_CLASS_SYMBOLS_RE","REGEX_GROUP_SYMBOLS_RE","GLOB_EXTENSION_SYMBOLS_RE","BRACE_EXPANSION_SEPARATORS_RE","pattern","options","caseSensitiveMatch","includes","test","extglob","braceExpansion","hasBraceExpansion","openingBraceIndex","indexOf","closingBraceIndex","braceContent","slice","startsWith","patterns","filter","flipBackslashes","endsWith","basename","reduce","collection","concat","braces","expand","nodupes","scan","assign","parts","length","unshift","map","entry","patternsRe","some","patternRe"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,QAAR,GAAmBF,OAAO,CAACG,mBAAR,GAA8BH,OAAO,CAACI,MAAR,GAAiBJ,OAAO,CAACK,eAAR,GAA0BL,OAAO,CAACM,oBAAR,GAA+BN,OAAO,CAACO,gCAAR,GAA2CP,OAAO,CAACQ,6BAAR,GAAwCR,OAAO,CAACS,qBAAR,GAAgCT,OAAO,CAACU,WAAR,GAAsBV,OAAO,CAACW,gBAAR,GAA2BX,OAAO,CAACY,iCAAR,GAA4CZ,OAAO,CAACa,kCAAR,GAA6Cb,OAAO,CAACc,iCAAR,GAA4Cd,OAAO,CAACe,mBAAR,GAA8Bf,OAAO,CAACgB,mBAAR,GAA8BhB,OAAO,CAACiB,iBAAR,GAA4BjB,OAAO,CAACkB,iBAAR,GAA4BlB,OAAO,CAACmB,wBAAR,GAAmCnB,OAAO,CAACoB,wBAAR,GAAmCpB,OAAO,CAACqB,gBAAR,GAA2BrB,OAAO,CAACsB,eAAR,GAA0B,KAAK,CAAxpB;;AACA,IAAMC,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,IAAMC,UAAU,GAAGD,OAAO,CAAC,aAAD,CAA1B;;AACA,IAAME,UAAU,GAAGF,OAAO,CAAC,YAAD,CAA1B;;AACA,IAAMG,QAAQ,GAAG,IAAjB;AACA,IAAMC,aAAa,GAAG,IAAtB;AACA,IAAMC,sBAAsB,GAAG,SAA/B;AACA,IAAMC,gCAAgC,GAAG,UAAzC;AACA,IAAMC,sBAAsB,GAAG,gCAA/B;AACA,IAAMC,yBAAyB,GAAG,kBAAlC;AACA,IAAMC,6BAA6B,GAAG,QAAtC;;AACA,SAASX,eAAT,CAAyBY,OAAzB,EAAgD;AAAA,MAAdC,OAAc,uEAAJ,EAAI;AAC5C,SAAO,CAACd,gBAAgB,CAACa,OAAD,EAAUC,OAAV,CAAxB;AACH;;AACDnC,OAAO,CAACsB,eAAR,GAA0BA,eAA1B;;AACA,SAASD,gBAAT,CAA0Ba,OAA1B,EAAiD;AAAA,MAAdC,OAAc,uEAAJ,EAAI;;AAC7C;AACJ;AACA;AACA;AACA;AACI,MAAID,OAAO,KAAK,EAAhB,EAAoB;AAChB,WAAO,KAAP;AACH;AACD;AACJ;AACA;AACA;;;AACI,MAAIC,OAAO,CAACC,kBAAR,KAA+B,KAA/B,IAAwCF,OAAO,CAACG,QAAR,CAAiBT,aAAjB,CAA5C,EAA6E;AACzE,WAAO,IAAP;AACH;;AACD,MAAIC,sBAAsB,CAACS,IAAvB,CAA4BJ,OAA5B,KAAwCJ,gCAAgC,CAACQ,IAAjC,CAAsCJ,OAAtC,CAAxC,IAA0FH,sBAAsB,CAACO,IAAvB,CAA4BJ,OAA5B,CAA9F,EAAoI;AAChI,WAAO,IAAP;AACH;;AACD,MAAIC,OAAO,CAACI,OAAR,KAAoB,KAApB,IAA6BP,yBAAyB,CAACM,IAA1B,CAA+BJ,OAA/B,CAAjC,EAA0E;AACtE,WAAO,IAAP;AACH;;AACD,MAAIC,OAAO,CAACK,cAAR,KAA2B,KAA3B,IAAoCC,iBAAiB,CAACP,OAAD,CAAzD,EAAoE;AAChE,WAAO,IAAP;AACH;;AACD,SAAO,KAAP;AACH;;AACDlC,OAAO,CAACqB,gBAAR,GAA2BA,gBAA3B;;AACA,SAASoB,iBAAT,CAA2BP,OAA3B,EAAoC;AAChC,MAAMQ,iBAAiB,GAAGR,OAAO,CAACS,OAAR,CAAgB,GAAhB,CAA1B;;AACA,MAAID,iBAAiB,KAAK,CAAC,CAA3B,EAA8B;AAC1B,WAAO,KAAP;AACH;;AACD,MAAME,iBAAiB,GAAGV,OAAO,CAACS,OAAR,CAAgB,GAAhB,EAAqBD,iBAAiB,GAAG,CAAzC,CAA1B;;AACA,MAAIE,iBAAiB,KAAK,CAAC,CAA3B,EAA8B;AAC1B,WAAO,KAAP;AACH;;AACD,MAAMC,YAAY,GAAGX,OAAO,CAACY,KAAR,CAAcJ,iBAAd,EAAiCE,iBAAjC,CAArB;AACA,SAAOX,6BAA6B,CAACK,IAA9B,CAAmCO,YAAnC,CAAP;AACH;;AACD,SAASzB,wBAAT,CAAkCc,OAAlC,EAA2C;AACvC,SAAOhB,iBAAiB,CAACgB,OAAD,CAAjB,GAA6BA,OAAO,CAACY,KAAR,CAAc,CAAd,CAA7B,GAAgDZ,OAAvD;AACH;;AACDlC,OAAO,CAACoB,wBAAR,GAAmCA,wBAAnC;;AACA,SAASD,wBAAT,CAAkCe,OAAlC,EAA2C;AACvC,SAAO,MAAMA,OAAb;AACH;;AACDlC,OAAO,CAACmB,wBAAR,GAAmCA,wBAAnC;;AACA,SAASD,iBAAT,CAA2BgB,OAA3B,EAAoC;AAChC,SAAOA,OAAO,CAACa,UAAR,CAAmB,GAAnB,KAA2Bb,OAAO,CAAC,CAAD,CAAP,KAAe,GAAjD;AACH;;AACDlC,OAAO,CAACkB,iBAAR,GAA4BA,iBAA5B;;AACA,SAASD,iBAAT,CAA2BiB,OAA3B,EAAoC;AAChC,SAAO,CAAChB,iBAAiB,CAACgB,OAAD,CAAzB;AACH;;AACDlC,OAAO,CAACiB,iBAAR,GAA4BA,iBAA5B;;AACA,SAASD,mBAAT,CAA6BgC,QAA7B,EAAuC;AACnC,SAAOA,QAAQ,CAACC,MAAT,CAAgB/B,iBAAhB,CAAP;AACH;;AACDlB,OAAO,CAACgB,mBAAR,GAA8BA,mBAA9B;;AACA,SAASD,mBAAT,CAA6BiC,QAA7B,EAAuC;AACnC,SAAOA,QAAQ,CAACC,MAAT,CAAgBhC,iBAAhB,CAAP;AACH;;AACDjB,OAAO,CAACe,mBAAR,GAA8BA,mBAA9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,iCAAT,CAA2CkC,QAA3C,EAAqD;AACjD,SAAOA,QAAQ,CAACC,MAAT,CAAgB,UAACf,OAAD;AAAA,WAAa,CAACtB,iCAAiC,CAACsB,OAAD,CAA/C;AAAA,GAAhB,CAAP;AACH;;AACDlC,OAAO,CAACc,iCAAR,GAA4CA,iCAA5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,kCAAT,CAA4CmC,QAA5C,EAAsD;AAClD,SAAOA,QAAQ,CAACC,MAAT,CAAgBrC,iCAAhB,CAAP;AACH;;AACDZ,OAAO,CAACa,kCAAR,GAA6CA,kCAA7C;;AACA,SAASD,iCAAT,CAA2CsB,OAA3C,EAAoD;AAChD,SAAOA,OAAO,CAACa,UAAR,CAAmB,IAAnB,KAA4Bb,OAAO,CAACa,UAAR,CAAmB,MAAnB,CAAnC;AACH;;AACD/C,OAAO,CAACY,iCAAR,GAA4CA,iCAA5C;;AACA,SAASD,gBAAT,CAA0BuB,OAA1B,EAAmC;AAC/B,SAAOT,UAAU,CAACS,OAAD,EAAU;AAAEgB,IAAAA,eAAe,EAAE;AAAnB,GAAV,CAAjB;AACH;;AACDlD,OAAO,CAACW,gBAAR,GAA2BA,gBAA3B;;AACA,SAASD,WAAT,CAAqBwB,OAArB,EAA8B;AAC1B,SAAOA,OAAO,CAACG,QAAR,CAAiBV,QAAjB,CAAP;AACH;;AACD3B,OAAO,CAACU,WAAR,GAAsBA,WAAtB;;AACA,SAASD,qBAAT,CAA+ByB,OAA/B,EAAwC;AACpC,SAAOA,OAAO,CAACiB,QAAR,CAAiB,MAAMxB,QAAvB,CAAP;AACH;;AACD3B,OAAO,CAACS,qBAAR,GAAgCA,qBAAhC;;AACA,SAASD,6BAAT,CAAuC0B,OAAvC,EAAgD;AAC5C,MAAMkB,QAAQ,GAAG7B,IAAI,CAAC6B,QAAL,CAAclB,OAAd,CAAjB;AACA,SAAOzB,qBAAqB,CAACyB,OAAD,CAArB,IAAkCZ,eAAe,CAAC8B,QAAD,CAAxD;AACH;;AACDpD,OAAO,CAACQ,6BAAR,GAAwCA,6BAAxC;;AACA,SAASD,gCAAT,CAA0CyC,QAA1C,EAAoD;AAChD,SAAOA,QAAQ,CAACK,MAAT,CAAgB,UAACC,UAAD,EAAapB,OAAb,EAAyB;AAC5C,WAAOoB,UAAU,CAACC,MAAX,CAAkBjD,oBAAoB,CAAC4B,OAAD,CAAtC,CAAP;AACH,GAFM,EAEJ,EAFI,CAAP;AAGH;;AACDlC,OAAO,CAACO,gCAAR,GAA2CA,gCAA3C;;AACA,SAASD,oBAAT,CAA8B4B,OAA9B,EAAuC;AACnC,SAAOR,UAAU,CAAC8B,MAAX,CAAkBtB,OAAlB,EAA2B;AAC9BuB,IAAAA,MAAM,EAAE,IADsB;AAE9BC,IAAAA,OAAO,EAAE;AAFqB,GAA3B,CAAP;AAIH;;AACD1D,OAAO,CAACM,oBAAR,GAA+BA,oBAA/B;;AACA,SAASD,eAAT,CAAyB6B,OAAzB,EAAkCC,OAAlC,EAA2C;AACvC,yBAAgBT,UAAU,CAACiC,IAAX,CAAgBzB,OAAhB,EAAyBpC,MAAM,CAAC8D,MAAP,CAAc9D,MAAM,CAAC8D,MAAP,CAAc,EAAd,EAAkBzB,OAAlB,CAAd,EAA0C;AAAE0B,IAAAA,KAAK,EAAE;AAAT,GAA1C,CAAzB,CAAhB;AAAA,MAAMA,KAAN,oBAAMA,KAAN;AACA;AACJ;AACA;AACA;;;AACI,MAAIA,KAAK,CAACC,MAAN,KAAiB,CAArB,EAAwB;AACpBD,IAAAA,KAAK,GAAG,CAAC3B,OAAD,CAAR;AACH;AACD;AACJ;AACA;AACA;;;AACI,MAAI2B,KAAK,CAAC,CAAD,CAAL,CAASd,UAAT,CAAoB,GAApB,CAAJ,EAA8B;AAC1Bc,IAAAA,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAL,CAASf,KAAT,CAAe,CAAf,CAAX;AACAe,IAAAA,KAAK,CAACE,OAAN,CAAc,EAAd;AACH;;AACD,SAAOF,KAAP;AACH;;AACD7D,OAAO,CAACK,eAAR,GAA0BA,eAA1B;;AACA,SAASD,MAAT,CAAgB8B,OAAhB,EAAyBC,OAAzB,EAAkC;AAC9B,SAAOT,UAAU,CAACtB,MAAX,CAAkB8B,OAAlB,EAA2BC,OAA3B,CAAP;AACH;;AACDnC,OAAO,CAACI,MAAR,GAAiBA,MAAjB;;AACA,SAASD,mBAAT,CAA6B6C,QAA7B,EAAuCb,OAAvC,EAAgD;AAC5C,SAAOa,QAAQ,CAACgB,GAAT,CAAa,UAAC9B,OAAD;AAAA,WAAa9B,MAAM,CAAC8B,OAAD,EAAUC,OAAV,CAAnB;AAAA,GAAb,CAAP;AACH;;AACDnC,OAAO,CAACG,mBAAR,GAA8BA,mBAA9B;;AACA,SAASD,QAAT,CAAkB+D,KAAlB,EAAyBC,UAAzB,EAAqC;AACjC,SAAOA,UAAU,CAACC,IAAX,CAAgB,UAACC,SAAD;AAAA,WAAeA,SAAS,CAAC9B,IAAV,CAAe2B,KAAf,CAAf;AAAA,GAAhB,CAAP;AACH;;AACDjE,OAAO,CAACE,QAAR,GAAmBA,QAAnB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\nconst path = require(\"path\");\nconst globParent = require(\"glob-parent\");\nconst micromatch = require(\"micromatch\");\nconst GLOBSTAR = '**';\nconst ESCAPE_SYMBOL = '\\\\';\nconst COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\nconst REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[[^[]*]/;\nconst REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\([^(]*\\|[^|]*\\)/;\nconst GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\([^(]*\\)/;\nconst BRACE_EXPANSION_SEPARATORS_RE = /,|\\.\\./;\nfunction isStaticPattern(pattern, options = {}) {\n    return !isDynamicPattern(pattern, options);\n}\nexports.isStaticPattern = isStaticPattern;\nfunction isDynamicPattern(pattern, options = {}) {\n    /**\n     * A special case with an empty string is necessary for matching patterns that start with a forward slash.\n     * An empty string cannot be a dynamic pattern.\n     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\n     */\n    if (pattern === '') {\n        return false;\n    }\n    /**\n     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\n     * filepath directly (without read directory).\n     */\n    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\n        return true;\n    }\n    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\n        return true;\n    }\n    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\n        return true;\n    }\n    if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {\n        return true;\n    }\n    return false;\n}\nexports.isDynamicPattern = isDynamicPattern;\nfunction hasBraceExpansion(pattern) {\n    const openingBraceIndex = pattern.indexOf('{');\n    if (openingBraceIndex === -1) {\n        return false;\n    }\n    const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);\n    if (closingBraceIndex === -1) {\n        return false;\n    }\n    const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);\n    return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);\n}\nfunction convertToPositivePattern(pattern) {\n    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\n}\nexports.convertToPositivePattern = convertToPositivePattern;\nfunction convertToNegativePattern(pattern) {\n    return '!' + pattern;\n}\nexports.convertToNegativePattern = convertToNegativePattern;\nfunction isNegativePattern(pattern) {\n    return pattern.startsWith('!') && pattern[1] !== '(';\n}\nexports.isNegativePattern = isNegativePattern;\nfunction isPositivePattern(pattern) {\n    return !isNegativePattern(pattern);\n}\nexports.isPositivePattern = isPositivePattern;\nfunction getNegativePatterns(patterns) {\n    return patterns.filter(isNegativePattern);\n}\nexports.getNegativePatterns = getNegativePatterns;\nfunction getPositivePatterns(patterns) {\n    return patterns.filter(isPositivePattern);\n}\nexports.getPositivePatterns = getPositivePatterns;\n/**\n * Returns patterns that can be applied inside the current directory.\n *\n * @example\n * // ['./*', '*', 'a/*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\nfunction getPatternsInsideCurrentDirectory(patterns) {\n    return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));\n}\nexports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;\n/**\n * Returns patterns to be expanded relative to (outside) the current directory.\n *\n * @example\n * // ['../*', './../*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\nfunction getPatternsOutsideCurrentDirectory(patterns) {\n    return patterns.filter(isPatternRelatedToParentDirectory);\n}\nexports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;\nfunction isPatternRelatedToParentDirectory(pattern) {\n    return pattern.startsWith('..') || pattern.startsWith('./..');\n}\nexports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;\nfunction getBaseDirectory(pattern) {\n    return globParent(pattern, { flipBackslashes: false });\n}\nexports.getBaseDirectory = getBaseDirectory;\nfunction hasGlobStar(pattern) {\n    return pattern.includes(GLOBSTAR);\n}\nexports.hasGlobStar = hasGlobStar;\nfunction endsWithSlashGlobStar(pattern) {\n    return pattern.endsWith('/' + GLOBSTAR);\n}\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\nfunction isAffectDepthOfReadingPattern(pattern) {\n    const basename = path.basename(pattern);\n    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\n}\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\nfunction expandPatternsWithBraceExpansion(patterns) {\n    return patterns.reduce((collection, pattern) => {\n        return collection.concat(expandBraceExpansion(pattern));\n    }, []);\n}\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\nfunction expandBraceExpansion(pattern) {\n    return micromatch.braces(pattern, {\n        expand: true,\n        nodupes: true\n    });\n}\nexports.expandBraceExpansion = expandBraceExpansion;\nfunction getPatternParts(pattern, options) {\n    let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));\n    /**\n     * The scan method returns an empty array in some cases.\n     * See micromatch/picomatch#58 for more details.\n     */\n    if (parts.length === 0) {\n        parts = [pattern];\n    }\n    /**\n     * The scan method does not return an empty part for the pattern with a forward slash.\n     * This is another part of micromatch/picomatch#58.\n     */\n    if (parts[0].startsWith('/')) {\n        parts[0] = parts[0].slice(1);\n        parts.unshift('');\n    }\n    return parts;\n}\nexports.getPatternParts = getPatternParts;\nfunction makeRe(pattern, options) {\n    return micromatch.makeRe(pattern, options);\n}\nexports.makeRe = makeRe;\nfunction convertPatternsToRe(patterns, options) {\n    return patterns.map((pattern) => makeRe(pattern, options));\n}\nexports.convertPatternsToRe = convertPatternsToRe;\nfunction matchAny(entry, patternsRe) {\n    return patternsRe.some((patternRe) => patternRe.test(entry));\n}\nexports.matchAny = matchAny;\n"]},"metadata":{},"sourceType":"script"}