{"ast":null,"code":"/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Readable$\" }] */\n'use strict';\n\nvar _slicedToArray = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _defineProperty = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\n\nvar _createForOfIteratorHelper = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _objectSpread = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _typeof = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/typeof.js\").default;\n\nvar _classCallCheck = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _assertThisInitialized = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\n\nvar _inherits = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nrequire(\"core-js/modules/es.array.includes.js\");\n\nrequire(\"core-js/modules/es.string.includes.js\");\n\nrequire(\"core-js/modules/es.array.join.js\");\n\nrequire(\"core-js/modules/es.object.keys.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nrequire(\"core-js/modules/es.set.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.string.starts-with.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.string.search.js\");\n\nrequire(\"core-js/modules/es.regexp.test.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.string.split.js\");\n\nrequire(\"core-js/modules/es.object.entries.js\");\n\nvar EventEmitter = require('events');\n\nvar https = require('https');\n\nvar http = require('http');\n\nvar net = require('net');\n\nvar tls = require('tls');\n\nvar _require = require('crypto'),\n    randomBytes = _require.randomBytes,\n    createHash = _require.createHash;\n\nvar _require2 = require('stream'),\n    Readable = _require2.Readable;\n\nvar _require3 = require('url'),\n    URL = _require3.URL;\n\nvar PerMessageDeflate = require('./permessage-deflate');\n\nvar Receiver = require('./receiver');\n\nvar Sender = require('./sender');\n\nvar _require4 = require('./constants'),\n    BINARY_TYPES = _require4.BINARY_TYPES,\n    EMPTY_BUFFER = _require4.EMPTY_BUFFER,\n    GUID = _require4.GUID,\n    kForOnEventAttribute = _require4.kForOnEventAttribute,\n    kListener = _require4.kListener,\n    kStatusCode = _require4.kStatusCode,\n    kWebSocket = _require4.kWebSocket,\n    NOOP = _require4.NOOP;\n\nvar _require5 = require('./event-target'),\n    _require5$EventTarget = _require5.EventTarget,\n    addEventListener = _require5$EventTarget.addEventListener,\n    removeEventListener = _require5$EventTarget.removeEventListener;\n\nvar _require6 = require('./extension'),\n    format = _require6.format,\n    parse = _require6.parse;\n\nvar _require7 = require('./buffer-util'),\n    toBuffer = _require7.toBuffer;\n\nvar readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nvar subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\nvar protocolVersions = [8, 13];\nvar closeTimeout = 30 * 1000;\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\n\nvar WebSocket = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(WebSocket, _EventEmitter);\n\n  var _super = _createSuper(WebSocket);\n\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  function WebSocket(address, protocols, options) {\n    var _this;\n\n    _classCallCheck(this, WebSocket);\n\n    _this = _super.call(this);\n    _this._binaryType = BINARY_TYPES[0];\n    _this._closeCode = 1006;\n    _this._closeFrameReceived = false;\n    _this._closeFrameSent = false;\n    _this._closeMessage = EMPTY_BUFFER;\n    _this._closeTimer = null;\n    _this._extensions = {};\n    _this._paused = false;\n    _this._protocol = '';\n    _this._readyState = WebSocket.CONNECTING;\n    _this._receiver = null;\n    _this._sender = null;\n    _this._socket = null;\n\n    if (address !== null) {\n      _this._bufferedAmount = 0;\n      _this._isServer = false;\n      _this._redirects = 0;\n\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (_typeof(protocols) === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n\n      initAsClient(_assertThisInitialized(_this), address, protocols, options);\n    } else {\n      _this._isServer = true;\n    }\n\n    return _this;\n  }\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n\n\n  _createClass(WebSocket, [{\n    key: \"binaryType\",\n    get: function get() {\n      return this._binaryType;\n    },\n    set: function set(type) {\n      if (!BINARY_TYPES.includes(type)) return;\n      this._binaryType = type; //\n      // Allow to change `binaryType` on the fly.\n      //\n\n      if (this._receiver) this._receiver._binaryType = type;\n    }\n    /**\n     * @type {Number}\n     */\n\n  }, {\n    key: \"bufferedAmount\",\n    get: function get() {\n      if (!this._socket) return this._bufferedAmount;\n      return this._socket._writableState.length + this._sender._bufferedBytes;\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"extensions\",\n    get: function get() {\n      return Object.keys(this._extensions).join();\n    }\n    /**\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"isPaused\",\n    get: function get() {\n      return this._paused;\n    }\n    /**\n     * @type {Function}\n     */\n\n    /* istanbul ignore next */\n\n  }, {\n    key: \"onclose\",\n    get: function get() {\n      return null;\n    }\n    /**\n     * @type {Function}\n     */\n\n    /* istanbul ignore next */\n\n  }, {\n    key: \"onerror\",\n    get: function get() {\n      return null;\n    }\n    /**\n     * @type {Function}\n     */\n\n    /* istanbul ignore next */\n\n  }, {\n    key: \"onopen\",\n    get: function get() {\n      return null;\n    }\n    /**\n     * @type {Function}\n     */\n\n    /* istanbul ignore next */\n\n  }, {\n    key: \"onmessage\",\n    get: function get() {\n      return null;\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"protocol\",\n    get: function get() {\n      return this._protocol;\n    }\n    /**\n     * @type {Number}\n     */\n\n  }, {\n    key: \"readyState\",\n    get: function get() {\n      return this._readyState;\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"url\",\n    get: function get() {\n      return this._url;\n    }\n    /**\n     * Set up the socket and the internal resources.\n     *\n     * @param {(net.Socket|tls.Socket)} socket The network socket between the\n     *     server and client\n     * @param {Buffer} head The first packet of the upgraded stream\n     * @param {Object} options Options object\n     * @param {Function} [options.generateMask] The function used to generate the\n     *     masking key\n     * @param {Number} [options.maxPayload=0] The maximum allowed message size\n     * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n     *     not to skip UTF-8 validation for text and close messages\n     * @private\n     */\n\n  }, {\n    key: \"setSocket\",\n    value: function setSocket(socket, head, options) {\n      var receiver = new Receiver({\n        binaryType: this.binaryType,\n        extensions: this._extensions,\n        isServer: this._isServer,\n        maxPayload: options.maxPayload,\n        skipUTF8Validation: options.skipUTF8Validation\n      });\n      this._sender = new Sender(socket, this._extensions, options.generateMask);\n      this._receiver = receiver;\n      this._socket = socket;\n      receiver[kWebSocket] = this;\n      socket[kWebSocket] = this;\n      receiver.on('conclude', receiverOnConclude);\n      receiver.on('drain', receiverOnDrain);\n      receiver.on('error', receiverOnError);\n      receiver.on('message', receiverOnMessage);\n      receiver.on('ping', receiverOnPing);\n      receiver.on('pong', receiverOnPong);\n      socket.setTimeout(0);\n      socket.setNoDelay();\n      if (head.length > 0) socket.unshift(head);\n      socket.on('close', socketOnClose);\n      socket.on('data', socketOnData);\n      socket.on('end', socketOnEnd);\n      socket.on('error', socketOnError);\n      this._readyState = WebSocket.OPEN;\n      this.emit('open');\n    }\n    /**\n     * Emit the `'close'` event.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"emitClose\",\n    value: function emitClose() {\n      if (!this._socket) {\n        this._readyState = WebSocket.CLOSED;\n        this.emit('close', this._closeCode, this._closeMessage);\n        return;\n      }\n\n      if (this._extensions[PerMessageDeflate.extensionName]) {\n        this._extensions[PerMessageDeflate.extensionName].cleanup();\n      }\n\n      this._receiver.removeAllListeners();\n\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n    }\n    /**\n     * Start a closing handshake.\n     *\n     *          +----------+   +-----------+   +----------+\n     *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n     *    |     +----------+   +-----------+   +----------+     |\n     *          +----------+   +-----------+         |\n     * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n     *          +----------+   +-----------+   |\n     *    |           |                        |   +---+        |\n     *                +------------------------+-->|fin| - - - -\n     *    |         +---+                      |   +---+\n     *     - - - - -|fin|<---------------------+\n     *              +---+\n     *\n     * @param {Number} [code] Status code explaining why the connection is closing\n     * @param {(String|Buffer)} [data] The reason why the connection is\n     *     closing\n     * @public\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(code, data) {\n      var _this2 = this;\n\n      if (this.readyState === WebSocket.CLOSED) return;\n\n      if (this.readyState === WebSocket.CONNECTING) {\n        var msg = 'WebSocket was closed before the connection was established';\n        return abortHandshake(this, this._req, msg);\n      }\n\n      if (this.readyState === WebSocket.CLOSING) {\n        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n          this._socket.end();\n        }\n\n        return;\n      }\n\n      this._readyState = WebSocket.CLOSING;\n\n      this._sender.close(code, data, !this._isServer, function (err) {\n        //\n        // This error is handled by the `'error'` listener on the socket. We only\n        // want to know if the close frame has been sent here.\n        //\n        if (err) return;\n        _this2._closeFrameSent = true;\n\n        if (_this2._closeFrameReceived || _this2._receiver._writableState.errorEmitted) {\n          _this2._socket.end();\n        }\n      }); //\n      // Specify a timeout for the closing handshake to complete.\n      //\n\n\n      this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);\n    }\n    /**\n     * Pause the socket.\n     *\n     * @public\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n        return;\n      }\n\n      this._paused = true;\n\n      this._socket.pause();\n    }\n    /**\n     * Send a ping.\n     *\n     * @param {*} [data] The data to send\n     * @param {Boolean} [mask] Indicates whether or not to mask `data`\n     * @param {Function} [cb] Callback which is executed when the ping is sent\n     * @public\n     */\n\n  }, {\n    key: \"ping\",\n    value: function ping(data, mask, cb) {\n      if (this.readyState === WebSocket.CONNECTING) {\n        throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n      }\n\n      if (typeof data === 'function') {\n        cb = data;\n        data = mask = undefined;\n      } else if (typeof mask === 'function') {\n        cb = mask;\n        mask = undefined;\n      }\n\n      if (typeof data === 'number') data = data.toString();\n\n      if (this.readyState !== WebSocket.OPEN) {\n        sendAfterClose(this, data, cb);\n        return;\n      }\n\n      if (mask === undefined) mask = !this._isServer;\n\n      this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n    }\n    /**\n     * Send a pong.\n     *\n     * @param {*} [data] The data to send\n     * @param {Boolean} [mask] Indicates whether or not to mask `data`\n     * @param {Function} [cb] Callback which is executed when the pong is sent\n     * @public\n     */\n\n  }, {\n    key: \"pong\",\n    value: function pong(data, mask, cb) {\n      if (this.readyState === WebSocket.CONNECTING) {\n        throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n      }\n\n      if (typeof data === 'function') {\n        cb = data;\n        data = mask = undefined;\n      } else if (typeof mask === 'function') {\n        cb = mask;\n        mask = undefined;\n      }\n\n      if (typeof data === 'number') data = data.toString();\n\n      if (this.readyState !== WebSocket.OPEN) {\n        sendAfterClose(this, data, cb);\n        return;\n      }\n\n      if (mask === undefined) mask = !this._isServer;\n\n      this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n    }\n    /**\n     * Resume the socket.\n     *\n     * @public\n     */\n\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n        return;\n      }\n\n      this._paused = false;\n      if (!this._receiver._writableState.needDrain) this._socket.resume();\n    }\n    /**\n     * Send a data message.\n     *\n     * @param {*} data The message to send\n     * @param {Object} [options] Options object\n     * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n     *     text\n     * @param {Boolean} [options.compress] Specifies whether or not to compress\n     *     `data`\n     * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n     *     last one\n     * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n     * @param {Function} [cb] Callback which is executed when data is written out\n     * @public\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(data, options, cb) {\n      if (this.readyState === WebSocket.CONNECTING) {\n        throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n      }\n\n      if (typeof options === 'function') {\n        cb = options;\n        options = {};\n      }\n\n      if (typeof data === 'number') data = data.toString();\n\n      if (this.readyState !== WebSocket.OPEN) {\n        sendAfterClose(this, data, cb);\n        return;\n      }\n\n      var opts = _objectSpread({\n        binary: typeof data !== 'string',\n        mask: !this._isServer,\n        compress: true,\n        fin: true\n      }, options);\n\n      if (!this._extensions[PerMessageDeflate.extensionName]) {\n        opts.compress = false;\n      }\n\n      this._sender.send(data || EMPTY_BUFFER, opts, cb);\n    }\n    /**\n     * Forcibly close the connection.\n     *\n     * @public\n     */\n\n  }, {\n    key: \"terminate\",\n    value: function terminate() {\n      if (this.readyState === WebSocket.CLOSED) return;\n\n      if (this.readyState === WebSocket.CONNECTING) {\n        var msg = 'WebSocket was closed before the connection was established';\n        return abortHandshake(this, this._req, msg);\n      }\n\n      if (this._socket) {\n        this._readyState = WebSocket.CLOSING;\n\n        this._socket.destroy();\n      }\n    }\n  }]);\n\n  return WebSocket;\n}(EventEmitter);\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\n\n\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\n\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\n\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\n\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\n\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\n\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\n\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\n\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n['binaryType', 'bufferedAmount', 'extensions', 'isPaused', 'protocol', 'readyState', 'url'].forEach(function (property) {\n  Object.defineProperty(WebSocket.prototype, property, {\n    enumerable: true\n  });\n}); //\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n\n['open', 'error', 'close', 'message'].forEach(function (method) {\n  Object.defineProperty(WebSocket.prototype, \"on\".concat(method), {\n    enumerable: true,\n    get: function get() {\n      var _iterator = _createForOfIteratorHelper(this.listeners(method)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var listener = _step.value;\n          if (listener[kForOnEventAttribute]) return listener[kListener];\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return null;\n    },\n    set: function set(handler) {\n      var _iterator2 = _createForOfIteratorHelper(this.listeners(method)),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var listener = _step2.value;\n\n          if (listener[kForOnEventAttribute]) {\n            this.removeListener(method, listener);\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (typeof handler !== 'function') return;\n      this.addEventListener(method, handler, _defineProperty({}, kForOnEventAttribute, true));\n    }\n  });\n});\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\nmodule.exports = WebSocket;\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\n\nfunction initAsClient(websocket, address, protocols, options) {\n  var opts = _objectSpread(_objectSpread({\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10\n  }, options), {}, {\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: undefined,\n    host: undefined,\n    path: undefined,\n    port: undefined\n  });\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\"Unsupported protocol version: \".concat(opts.protocolVersion, \" \") + \"(supported versions: \".concat(protocolVersions.join(', '), \")\"));\n  }\n\n  var parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket._url = address.href;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(\"Invalid URL: \".concat(address));\n    }\n\n    websocket._url = address;\n  }\n\n  var isSecure = parsedUrl.protocol === 'wss:';\n  var isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n  var invalidURLMessage;\n\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isUnixSocket) {\n    invalidURLMessage = 'The URL\\'s protocol must be one of \"ws:\", \"wss:\", or \"ws+unix:\"';\n  } else if (isUnixSocket && !parsedUrl.pathname) {\n    invalidURLMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidURLMessage = 'The URL contains a fragment identifier';\n  }\n\n  if (invalidURLMessage) {\n    var err = new SyntaxError(invalidURLMessage);\n\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n\n  var defaultPort = isSecure ? 443 : 80;\n  var key = randomBytes(16).toString('base64');\n  var get = isSecure ? https.get : http.get;\n  var protocolSet = new Set();\n  var perMessageDeflate;\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n  opts.headers = _objectSpread({\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket'\n  }, opts.headers);\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);\n    opts.headers['Sec-WebSocket-Extensions'] = format(_defineProperty({}, PerMessageDeflate.extensionName, perMessageDeflate.offer()));\n  }\n\n  if (protocols.length) {\n    var _iterator3 = _createForOfIteratorHelper(protocols),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var protocol = _step3.value;\n\n        if (typeof protocol !== 'string' || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n          throw new SyntaxError('An invalid or duplicated subprotocol was specified');\n        }\n\n        protocolSet.add(protocol);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = \"\".concat(parsedUrl.username, \":\").concat(parsedUrl.password);\n  }\n\n  if (isUnixSocket) {\n    var parts = opts.path.split(':');\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalHost = parsedUrl.host;\n      var headers = options && options.headers; //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n\n      options = _objectSpread(_objectSpread({}, options), {}, {\n        headers: {}\n      });\n\n      if (headers) {\n        for (var _i = 0, _Object$entries = Object.entries(headers); _i < _Object$entries.length; _i++) {\n          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n              _key = _Object$entries$_i[0],\n              value = _Object$entries$_i[1];\n\n          options.headers[_key.toLowerCase()] = value;\n        }\n      }\n    } else if (parsedUrl.host !== websocket._originalHost) {\n      //\n      // Match curl 7.77.0 behavior and drop the following headers. These\n      // headers are also dropped when following a redirect to a subdomain.\n      //\n      delete opts.headers.authorization;\n      delete opts.headers.cookie;\n      delete opts.headers.host;\n      opts.auth = undefined;\n    } //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n\n\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization = 'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n  }\n\n  var req = websocket._req = get(opts);\n\n  if (opts.timeout) {\n    req.on('timeout', function () {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', function (err) {\n    if (req === null || req.aborted) return;\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n  req.on('response', function (res) {\n    var location = res.headers.location;\n    var statusCode = res.statusCode;\n\n    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n      var addr;\n\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        var _err = new SyntaxError(\"Invalid URL: \".concat(location));\n\n        emitErrorAndClose(websocket, _err);\n        return;\n      }\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(websocket, req, \"Unexpected server response: \".concat(res.statusCode));\n    }\n  });\n  req.on('upgrade', function (res, socket, head) {\n    websocket.emit('upgrade', res); //\n    // The user may have closed the connection from a listener of the `upgrade`\n    // event.\n    //\n\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n    req = websocket._req = null;\n    var digest = createHash('sha1').update(key + GUID).digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    var serverProt = res.headers['sec-websocket-protocol'];\n    var protError;\n\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n    var secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        var message = 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      var extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        var _message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, _message);\n        return;\n      }\n\n      var extensionNames = Object.keys(extensions);\n\n      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {\n        var _message2 = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, _message2);\n        return;\n      }\n\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        var _message3 = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, _message3);\n        return;\n      }\n\n      websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n    }\n\n    websocket.setSocket(socket, head, {\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n}\n/**\n * Emit the `'error'` and `'close'` event.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\n\n\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\n\n\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\n\n\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\n\n\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n  var err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    stream.once('abort', websocket.emitClose.bind(websocket));\n    websocket.emit('error', err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\n\n\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    var length = toBuffer(data).length; //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n\n    if (websocket._socket) websocket._sender._bufferedBytes += length;else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    var err = new Error(\"WebSocket is not open: readyState \".concat(websocket.readyState, \" \") + \"(\".concat(readyStates[websocket.readyState], \")\"));\n    cb(err);\n  }\n}\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\n\n\nfunction receiverOnConclude(code, reason) {\n  var websocket = this[kWebSocket];\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n\n  process.nextTick(resume, websocket._socket);\n  if (code === 1005) websocket.close();else websocket.close(code, reason);\n}\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\n\n\nfunction receiverOnDrain() {\n  var websocket = this[kWebSocket];\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\n\n\nfunction receiverOnError(err) {\n  var websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData); //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n\n\n    process.nextTick(resume, websocket._socket);\n    websocket.close(err[kStatusCode]);\n  }\n\n  websocket.emit('error', err);\n}\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\n\n\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\n\n\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\n\n\nfunction receiverOnPing(data) {\n  var websocket = this[kWebSocket];\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\n\n\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\n\n\nfunction resume(stream) {\n  stream.resume();\n}\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\n\n\nfunction socketOnClose() {\n  var websocket = this[kWebSocket];\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n  websocket._readyState = WebSocket.CLOSING;\n  var chunk; //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n\n  if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n  clearTimeout(websocket._closeTimer);\n\n  if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\n\n\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\n\n\nfunction socketOnEnd() {\n  var websocket = this[kWebSocket];\n  websocket._readyState = WebSocket.CLOSING;\n\n  websocket._receiver.end();\n\n  this.end();\n}\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\n\n\nfunction socketOnError() {\n  var websocket = this[kWebSocket];\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/webpack-dev-server/node_modules/ws/lib/websocket.js"],"names":["EventEmitter","require","https","http","net","tls","randomBytes","createHash","Readable","URL","PerMessageDeflate","Receiver","Sender","BINARY_TYPES","EMPTY_BUFFER","GUID","kForOnEventAttribute","kListener","kStatusCode","kWebSocket","NOOP","EventTarget","addEventListener","removeEventListener","format","parse","toBuffer","readyStates","subprotocolRegex","protocolVersions","closeTimeout","WebSocket","address","protocols","options","_binaryType","_closeCode","_closeFrameReceived","_closeFrameSent","_closeMessage","_closeTimer","_extensions","_paused","_protocol","_readyState","CONNECTING","_receiver","_sender","_socket","_bufferedAmount","_isServer","_redirects","undefined","Array","isArray","initAsClient","type","includes","_writableState","length","_bufferedBytes","Object","keys","join","_url","socket","head","receiver","binaryType","extensions","isServer","maxPayload","skipUTF8Validation","generateMask","on","receiverOnConclude","receiverOnDrain","receiverOnError","receiverOnMessage","receiverOnPing","receiverOnPong","setTimeout","setNoDelay","unshift","socketOnClose","socketOnData","socketOnEnd","socketOnError","OPEN","emit","CLOSED","extensionName","cleanup","removeAllListeners","code","data","readyState","msg","abortHandshake","_req","CLOSING","errorEmitted","end","close","err","destroy","bind","pause","mask","cb","Error","toString","sendAfterClose","ping","pong","needDrain","resume","opts","binary","compress","fin","send","defineProperty","enumerable","value","indexOf","prototype","forEach","property","method","get","listeners","listener","set","handler","removeListener","module","exports","websocket","protocolVersion","perMessageDeflate","followRedirects","maxRedirects","createConnection","socketPath","hostname","protocol","timeout","host","path","port","RangeError","parsedUrl","href","e","SyntaxError","isSecure","isUnixSocket","invalidURLMessage","pathname","hash","emitErrorAndClose","defaultPort","key","protocolSet","Set","tlsConnect","netConnect","startsWith","slice","headers","Connection","Upgrade","search","handshakeTimeout","offer","test","has","add","origin","Origin","username","password","auth","parts","split","_originalHost","entries","toLowerCase","authorization","cookie","Buffer","from","req","aborted","res","location","statusCode","abort","addr","digest","update","serverProt","protError","size","secWebSocketExtensions","message","extensionNames","accept","setSocket","emitClose","connect","servername","isIP","stream","captureStackTrace","setHeader","destroyed","once","reason","process","nextTick","isPaused","receiverOnFinish","isBinary","chunk","_readableState","endEmitted","read","write","clearTimeout","finished"],"mappings":"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","sourcesContent":["/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Readable$\" }] */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst https = require('https');\nconst http = require('http');\nconst net = require('net');\nconst tls = require('tls');\nconst { randomBytes, createHash } = require('crypto');\nconst { Readable } = require('stream');\nconst { URL } = require('url');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst Receiver = require('./receiver');\nconst Sender = require('./sender');\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = require('./constants');\nconst {\n  EventTarget: { addEventListener, removeEventListener }\n} = require('./event-target');\nconst { format, parse } = require('./extension');\nconst { toBuffer } = require('./buffer-util');\n\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n\n    this._sender = new Sender(socket, this._extensions, options.generateMask);\n    this._receiver = receiver;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    socket.setTimeout(0);\n    socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (\n        this._closeFrameSent &&\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\n      ) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (\n        this._closeFrameReceived ||\n        this._receiver._writableState.errorEmitted\n      ) {\n        this._socket.end();\n      }\n    });\n\n    //\n    // Specify a timeout for the closing handshake to complete.\n    //\n    this._closeTimer = setTimeout(\n      this._socket.destroy.bind(this._socket),\n      closeTimeout\n    );\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n[\n  'binaryType',\n  'bufferedAmount',\n  'extensions',\n  'isPaused',\n  'protocol',\n  'readyState',\n  'url'\n].forEach((property) => {\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n\n      if (typeof handler !== 'function') return;\n\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: undefined,\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket._url = address.href;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n\n    websocket._url = address;\n  }\n\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n  let invalidURLMessage;\n\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isUnixSocket) {\n    invalidURLMessage =\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", or \"ws+unix:\"';\n  } else if (isUnixSocket && !parsedUrl.pathname) {\n    invalidURLMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidURLMessage = 'The URL contains a fragment identifier';\n  }\n\n  if (invalidURLMessage) {\n    const err = new SyntaxError(invalidURLMessage);\n\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const get = isSecure ? https.get : http.get;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket',\n    ...opts.headers\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (\n        typeof protocol !== 'string' ||\n        !subprotocolRegex.test(protocol) ||\n        protocolSet.has(protocol)\n      ) {\n        throw new SyntaxError(\n          'An invalid or duplicated subprotocol was specified'\n        );\n      }\n\n      protocolSet.add(protocol);\n    }\n\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalHost = parsedUrl.host;\n\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = { ...options, headers: {} };\n\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (parsedUrl.host !== websocket._originalHost) {\n      //\n      // Match curl 7.77.0 behavior and drop the following headers. These\n      // headers are also dropped when following a redirect to a subdomain.\n      //\n      delete opts.headers.authorization;\n      delete opts.headers.cookie;\n      delete opts.headers.host;\n      opts.auth = undefined;\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization =\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n  }\n\n  let req = (websocket._req = get(opts));\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (req === null || req.aborted) return;\n\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      let addr;\n\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the `upgrade`\n    // event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message =\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\n          'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (\n        extensionNames.length !== 1 ||\n        extensionNames[0] !== PerMessageDeflate.extensionName\n      ) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      websocket._extensions[PerMessageDeflate.extensionName] =\n        perMessageDeflate;\n    }\n\n    websocket.setSocket(socket, head, {\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n}\n\n/**\n * Emit the `'error'` and `'close'` event.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    stream.once('abort', websocket.emitClose.bind(websocket));\n    websocket.emit('error', err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    cb(err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n\n    websocket.close(err[kStatusCode]);\n  }\n\n  websocket.emit('error', err);\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n\n  websocket._readyState = WebSocket.CLOSING;\n\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (\n    !this._readableState.endEmitted &&\n    !websocket._closeFrameReceived &&\n    !websocket._receiver._writableState.errorEmitted &&\n    (chunk = websocket._socket.read()) !== null\n  ) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}