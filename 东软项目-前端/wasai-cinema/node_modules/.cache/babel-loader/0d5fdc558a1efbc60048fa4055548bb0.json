{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.string.replace.js\");\n\nvar Source = require(\"./Source\");\n\nvar RawSource = require(\"./RawSource\");\n\nvar _streamChunks = require(\"./helpers/streamChunks\");\n\nvar _require = require(\"./helpers/getFromStreamChunks\"),\n    getMap = _require.getMap,\n    getSourceAndMap = _require.getSourceAndMap;\n\nvar REPLACE_REGEX = /\\n(?=.|\\s)/g;\n\nvar PrefixSource = /*#__PURE__*/function (_Source) {\n  _inherits(PrefixSource, _Source);\n\n  var _super = _createSuper(PrefixSource);\n\n  function PrefixSource(prefix, source) {\n    var _this;\n\n    _classCallCheck(this, PrefixSource);\n\n    _this = _super.call(this);\n    _this._source = typeof source === \"string\" || Buffer.isBuffer(source) ? new RawSource(source, true) : source;\n    _this._prefix = prefix;\n    return _this;\n  }\n\n  _createClass(PrefixSource, [{\n    key: \"getPrefix\",\n    value: function getPrefix() {\n      return this._prefix;\n    }\n  }, {\n    key: \"original\",\n    value: function original() {\n      return this._source;\n    }\n  }, {\n    key: \"source\",\n    value: function source() {\n      var node = this._source.source();\n\n      var prefix = this._prefix;\n      return prefix + node.replace(REPLACE_REGEX, \"\\n\" + prefix);\n    } // TODO efficient buffer() implementation\n\n  }, {\n    key: \"map\",\n    value: function map(options) {\n      return getMap(this, options);\n    }\n  }, {\n    key: \"sourceAndMap\",\n    value: function sourceAndMap(options) {\n      return getSourceAndMap(this, options);\n    }\n  }, {\n    key: \"streamChunks\",\n    value: function streamChunks(options, onChunk, onSource, onName) {\n      var prefix = this._prefix;\n      var prefixOffset = prefix.length;\n      var linesOnly = !!(options && options.columns === false);\n\n      var _streamChunks2 = _streamChunks(this._source, options, function (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) {\n        if (generatedColumn !== 0) {\n          // In the middle of the line, we just adject the column\n          generatedColumn += prefixOffset;\n        } else if (chunk !== undefined) {\n          // At the start of the line, when we have source content\n          // add the prefix as generated mapping\n          // (in lines only mode we just add it to the original mapping\n          // for performance reasons)\n          if (linesOnly || sourceIndex < 0) {\n            chunk = prefix + chunk;\n          } else if (prefixOffset > 0) {\n            onChunk(prefix, generatedLine, generatedColumn, -1, -1, -1, -1);\n            generatedColumn += prefixOffset;\n          }\n        } else if (!linesOnly) {\n          // Without source content, we only need to adject the column info\n          // expect in lines only mode where prefix is added to original mapping\n          generatedColumn += prefixOffset;\n        }\n\n        onChunk(chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex);\n      }, onSource, onName),\n          generatedLine = _streamChunks2.generatedLine,\n          generatedColumn = _streamChunks2.generatedColumn,\n          source = _streamChunks2.source;\n\n      return {\n        generatedLine: generatedLine,\n        generatedColumn: generatedColumn === 0 ? 0 : prefixOffset + generatedColumn,\n        source: source !== undefined ? prefix + source.replace(REPLACE_REGEX, \"\\n\" + prefix) : undefined\n      };\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      hash.update(\"PrefixSource\");\n\n      this._source.updateHash(hash);\n\n      hash.update(this._prefix);\n    }\n  }]);\n\n  return PrefixSource;\n}(Source);\n\nmodule.exports = PrefixSource;","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/webpack-sources/lib/PrefixSource.js"],"names":["Source","require","RawSource","streamChunks","getMap","getSourceAndMap","REPLACE_REGEX","PrefixSource","prefix","source","_source","Buffer","isBuffer","_prefix","node","replace","options","onChunk","onSource","onName","prefixOffset","length","linesOnly","columns","chunk","generatedLine","generatedColumn","sourceIndex","originalLine","originalColumn","nameIndex","undefined","hash","update","updateHash","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAEA,IAAMA,MAAM,GAAGC,OAAO,CAAC,UAAD,CAAtB;;AACA,IAAMC,SAAS,GAAGD,OAAO,CAAC,aAAD,CAAzB;;AACA,IAAME,aAAY,GAAGF,OAAO,CAAC,wBAAD,CAA5B;;AACA,eAAoCA,OAAO,CAAC,+BAAD,CAA3C;AAAA,IAAQG,MAAR,YAAQA,MAAR;AAAA,IAAgBC,eAAhB,YAAgBA,eAAhB;;AAEA,IAAMC,aAAa,GAAG,aAAtB;;IAEMC,Y;;;;;AACL,wBAAYC,MAAZ,EAAoBC,MAApB,EAA4B;AAAA;;AAAA;;AAC3B;AACA,UAAKC,OAAL,GACC,OAAOD,MAAP,KAAkB,QAAlB,IAA8BE,MAAM,CAACC,QAAP,CAAgBH,MAAhB,CAA9B,GACG,IAAIP,SAAJ,CAAcO,MAAd,EAAsB,IAAtB,CADH,GAEGA,MAHJ;AAIA,UAAKI,OAAL,GAAeL,MAAf;AAN2B;AAO3B;;;;WAED,qBAAY;AACX,aAAO,KAAKK,OAAZ;AACA;;;WAED,oBAAW;AACV,aAAO,KAAKH,OAAZ;AACA;;;WAED,kBAAS;AACR,UAAMI,IAAI,GAAG,KAAKJ,OAAL,CAAaD,MAAb,EAAb;;AACA,UAAMD,MAAM,GAAG,KAAKK,OAApB;AACA,aAAOL,MAAM,GAAGM,IAAI,CAACC,OAAL,CAAaT,aAAb,EAA4B,OAAOE,MAAnC,CAAhB;AACA,K,CAED;;;;WAEA,aAAIQ,OAAJ,EAAa;AACZ,aAAOZ,MAAM,CAAC,IAAD,EAAOY,OAAP,CAAb;AACA;;;WAED,sBAAaA,OAAb,EAAsB;AACrB,aAAOX,eAAe,CAAC,IAAD,EAAOW,OAAP,CAAtB;AACA;;;WAED,sBAAaA,OAAb,EAAsBC,OAAtB,EAA+BC,QAA/B,EAAyCC,MAAzC,EAAiD;AAChD,UAAMX,MAAM,GAAG,KAAKK,OAApB;AACA,UAAMO,YAAY,GAAGZ,MAAM,CAACa,MAA5B;AACA,UAAMC,SAAS,GAAG,CAAC,EAAEN,OAAO,IAAIA,OAAO,CAACO,OAAR,KAAoB,KAAjC,CAAnB;;AACA,2BAAmDpB,aAAY,CAC9D,KAAKO,OADyD,EAE9DM,OAF8D,EAG9D,UACCQ,KADD,EAECC,aAFD,EAGCC,eAHD,EAICC,WAJD,EAKCC,YALD,EAMCC,cAND,EAOCC,SAPD,EAQK;AACJ,YAAIJ,eAAe,KAAK,CAAxB,EAA2B;AAC1B;AACAA,UAAAA,eAAe,IAAIN,YAAnB;AACA,SAHD,MAGO,IAAII,KAAK,KAAKO,SAAd,EAAyB;AAC/B;AACA;AACA;AACA;AACA,cAAIT,SAAS,IAAIK,WAAW,GAAG,CAA/B,EAAkC;AACjCH,YAAAA,KAAK,GAAGhB,MAAM,GAAGgB,KAAjB;AACA,WAFD,MAEO,IAAIJ,YAAY,GAAG,CAAnB,EAAsB;AAC5BH,YAAAA,OAAO,CAACT,MAAD,EAASiB,aAAT,EAAwBC,eAAxB,EAAyC,CAAC,CAA1C,EAA6C,CAAC,CAA9C,EAAiD,CAAC,CAAlD,EAAqD,CAAC,CAAtD,CAAP;AACAA,YAAAA,eAAe,IAAIN,YAAnB;AACA;AACD,SAXM,MAWA,IAAI,CAACE,SAAL,EAAgB;AACtB;AACA;AACAI,UAAAA,eAAe,IAAIN,YAAnB;AACA;;AACDH,QAAAA,OAAO,CACNO,KADM,EAENC,aAFM,EAGNC,eAHM,EAINC,WAJM,EAKNC,YALM,EAMNC,cANM,EAONC,SAPM,CAAP;AASA,OAxC6D,EAyC9DZ,QAzC8D,EA0C9DC,MA1C8D,CAA/D;AAAA,UAAQM,aAAR,kBAAQA,aAAR;AAAA,UAAuBC,eAAvB,kBAAuBA,eAAvB;AAAA,UAAwCjB,MAAxC,kBAAwCA,MAAxC;;AA4CA,aAAO;AACNgB,QAAAA,aAAa,EAAbA,aADM;AAENC,QAAAA,eAAe,EACdA,eAAe,KAAK,CAApB,GAAwB,CAAxB,GAA4BN,YAAY,GAAGM,eAHtC;AAINjB,QAAAA,MAAM,EACLA,MAAM,KAAKsB,SAAX,GACGvB,MAAM,GAAGC,MAAM,CAACM,OAAP,CAAeT,aAAf,EAA8B,OAAOE,MAArC,CADZ,GAEGuB;AAPE,OAAP;AASA;;;WAED,oBAAWC,IAAX,EAAiB;AAChBA,MAAAA,IAAI,CAACC,MAAL,CAAY,cAAZ;;AACA,WAAKvB,OAAL,CAAawB,UAAb,CAAwBF,IAAxB;;AACAA,MAAAA,IAAI,CAACC,MAAL,CAAY,KAAKpB,OAAjB;AACA;;;;EAjGyBb,M;;AAoG3BmC,MAAM,CAACC,OAAP,GAAiB7B,YAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Source = require(\"./Source\");\nconst RawSource = require(\"./RawSource\");\nconst streamChunks = require(\"./helpers/streamChunks\");\nconst { getMap, getSourceAndMap } = require(\"./helpers/getFromStreamChunks\");\n\nconst REPLACE_REGEX = /\\n(?=.|\\s)/g;\n\nclass PrefixSource extends Source {\n\tconstructor(prefix, source) {\n\t\tsuper();\n\t\tthis._source =\n\t\t\ttypeof source === \"string\" || Buffer.isBuffer(source)\n\t\t\t\t? new RawSource(source, true)\n\t\t\t\t: source;\n\t\tthis._prefix = prefix;\n\t}\n\n\tgetPrefix() {\n\t\treturn this._prefix;\n\t}\n\n\toriginal() {\n\t\treturn this._source;\n\t}\n\n\tsource() {\n\t\tconst node = this._source.source();\n\t\tconst prefix = this._prefix;\n\t\treturn prefix + node.replace(REPLACE_REGEX, \"\\n\" + prefix);\n\t}\n\n\t// TODO efficient buffer() implementation\n\n\tmap(options) {\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tconst prefix = this._prefix;\n\t\tconst prefixOffset = prefix.length;\n\t\tconst linesOnly = !!(options && options.columns === false);\n\t\tconst { generatedLine, generatedColumn, source } = streamChunks(\n\t\t\tthis._source,\n\t\t\toptions,\n\t\t\t(\n\t\t\t\tchunk,\n\t\t\t\tgeneratedLine,\n\t\t\t\tgeneratedColumn,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\tnameIndex\n\t\t\t) => {\n\t\t\t\tif (generatedColumn !== 0) {\n\t\t\t\t\t// In the middle of the line, we just adject the column\n\t\t\t\t\tgeneratedColumn += prefixOffset;\n\t\t\t\t} else if (chunk !== undefined) {\n\t\t\t\t\t// At the start of the line, when we have source content\n\t\t\t\t\t// add the prefix as generated mapping\n\t\t\t\t\t// (in lines only mode we just add it to the original mapping\n\t\t\t\t\t// for performance reasons)\n\t\t\t\t\tif (linesOnly || sourceIndex < 0) {\n\t\t\t\t\t\tchunk = prefix + chunk;\n\t\t\t\t\t} else if (prefixOffset > 0) {\n\t\t\t\t\t\tonChunk(prefix, generatedLine, generatedColumn, -1, -1, -1, -1);\n\t\t\t\t\t\tgeneratedColumn += prefixOffset;\n\t\t\t\t\t}\n\t\t\t\t} else if (!linesOnly) {\n\t\t\t\t\t// Without source content, we only need to adject the column info\n\t\t\t\t\t// expect in lines only mode where prefix is added to original mapping\n\t\t\t\t\tgeneratedColumn += prefixOffset;\n\t\t\t\t}\n\t\t\t\tonChunk(\n\t\t\t\t\tchunk,\n\t\t\t\t\tgeneratedLine,\n\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\toriginalLine,\n\t\t\t\t\toriginalColumn,\n\t\t\t\t\tnameIndex\n\t\t\t\t);\n\t\t\t},\n\t\t\tonSource,\n\t\t\tonName\n\t\t);\n\t\treturn {\n\t\t\tgeneratedLine,\n\t\t\tgeneratedColumn:\n\t\t\t\tgeneratedColumn === 0 ? 0 : prefixOffset + generatedColumn,\n\t\t\tsource:\n\t\t\t\tsource !== undefined\n\t\t\t\t\t? prefix + source.replace(REPLACE_REGEX, \"\\n\" + prefix)\n\t\t\t\t\t: undefined\n\t\t};\n\t}\n\n\tupdateHash(hash) {\n\t\thash.update(\"PrefixSource\");\n\t\tthis._source.updateHash(hash);\n\t\thash.update(this._prefix);\n\t}\n}\n\nmodule.exports = PrefixSource;\n"]},"metadata":{},"sourceType":"script"}