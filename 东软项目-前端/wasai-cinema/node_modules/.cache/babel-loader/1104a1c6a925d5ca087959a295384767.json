{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _get = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/get.js\").default;\n\nvar _getPrototypeOf = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\n\nvar _inherits = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _typeof = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/typeof.js\").default;\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/es.weak-map.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptor.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.set.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importAssertions = importAssertions;\n\nvar _acorn = _interopRequireWildcard(require(\"acorn\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar leftCurlyBrace = \"{\".charCodeAt(0);\nvar space = \" \".charCodeAt(0);\nvar keyword = \"assert\";\nvar FUNC_STATEMENT = 1,\n    FUNC_HANGING_STATEMENT = 2,\n    FUNC_NULLABLE_ID = 4;\n\nfunction importAssertions(Parser) {\n  // Use supplied version acorn version if present, to avoid\n  // reference mismatches due to different acorn versions. This\n  // allows this plugin to be used with Rollup which supplies\n  // its own internal version of acorn and thereby sidesteps\n  // the package manager.\n  var acorn = Parser.acorn || _acorn;\n  var tt = acorn.tokTypes,\n      TokenType = acorn.TokenType;\n  return /*#__PURE__*/function (_Parser) {\n    _inherits(_class, _Parser);\n\n    var _super = _createSuper(_class);\n\n    function _class() {\n      var _this;\n\n      _classCallCheck(this, _class);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _super.call.apply(_super, [this].concat(args));\n      _this.assertToken = new TokenType(keyword);\n      return _this;\n    }\n\n    _createClass(_class, [{\n      key: \"_codeAt\",\n      value: function _codeAt(i) {\n        return this.input.charCodeAt(i);\n      }\n    }, {\n      key: \"_eat\",\n      value: function _eat(t) {\n        if (this.type !== t) {\n          this.unexpected();\n        }\n\n        this.next();\n      }\n    }, {\n      key: \"readToken\",\n      value: function readToken(code) {\n        var i = 0;\n\n        for (; i < keyword.length; i++) {\n          if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {\n            return _get(_getPrototypeOf(_class.prototype), \"readToken\", this).call(this, code);\n          }\n        } // ensure that the keyword is at the correct location\n        // ie `assert{...` or `assert {...`\n\n\n        for (;; i++) {\n          if (this._codeAt(this.pos + i) === leftCurlyBrace) {\n            // Found '{'\n            break;\n          } else if (this._codeAt(this.pos + i) === space) {\n            // white space is allowed between `assert` and `{`, so continue.\n            continue;\n          } else {\n            return _get(_getPrototypeOf(_class.prototype), \"readToken\", this).call(this, code);\n          }\n        } // If we're inside a dynamic import expression we'll parse\n        // the `assert` keyword as a standard object property name\n        // ie `import(\"\"./foo.json\", { assert: { type: \"json\" } })`\n\n\n        if (this.type.label === \"{\") {\n          return _get(_getPrototypeOf(_class.prototype), \"readToken\", this).call(this, code);\n        }\n\n        this.pos += keyword.length;\n        return this.finishToken(this.assertToken);\n      }\n    }, {\n      key: \"parseDynamicImport\",\n      value: function parseDynamicImport(node) {\n        this.next(); // skip `(`\n        // Parse node.source.\n\n        node.source = this.parseMaybeAssign();\n\n        if (this.eat(tt.comma)) {\n          var obj = this.parseObj(false);\n          node.arguments = [obj];\n        }\n\n        this._eat(tt.parenR);\n\n        return this.finishNode(node, \"ImportExpression\");\n      } // ported from acorn/src/statement.js pp.parseExport\n\n    }, {\n      key: \"parseExport\",\n      value: function parseExport(node, exports) {\n        this.next(); // export * from '...'\n\n        if (this.eat(tt.star)) {\n          if (this.options.ecmaVersion >= 11) {\n            if (this.eatContextual(\"as\")) {\n              node.exported = this.parseIdent(true);\n              this.checkExport(exports, node.exported.name, this.lastTokStart);\n            } else {\n              node.exported = null;\n            }\n          }\n\n          this.expectContextual(\"from\");\n\n          if (this.type !== tt.string) {\n            this.unexpected();\n          }\n\n          node.source = this.parseExprAtom();\n\n          if (this.type === this.assertToken) {\n            this.next();\n            var assertions = this.parseImportAssertions();\n\n            if (assertions) {\n              node.assertions = assertions;\n            }\n          }\n\n          this.semicolon();\n          return this.finishNode(node, \"ExportAllDeclaration\");\n        }\n\n        if (this.eat(tt._default)) {\n          // export default ...\n          this.checkExport(exports, \"default\", this.lastTokStart);\n          var isAsync;\n\n          if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n            var fNode = this.startNode();\n            this.next();\n\n            if (isAsync) {\n              this.next();\n            }\n\n            node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n          } else if (this.type === tt._class) {\n            var cNode = this.startNode();\n            node.declaration = this.parseClass(cNode, \"nullableID\");\n          } else {\n            node.declaration = this.parseMaybeAssign();\n            this.semicolon();\n          }\n\n          return this.finishNode(node, \"ExportDefaultDeclaration\");\n        } // export var|const|let|function|class ...\n\n\n        if (this.shouldParseExportStatement()) {\n          node.declaration = this.parseStatement(null);\n\n          if (node.declaration.type === \"VariableDeclaration\") {\n            this.checkVariableExport(exports, node.declaration.declarations);\n          } else {\n            this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n          }\n\n          node.specifiers = [];\n          node.source = null;\n        } else {\n          // export { x, y as z } [from '...']\n          node.declaration = null;\n          node.specifiers = this.parseExportSpecifiers(exports);\n\n          if (this.eatContextual(\"from\")) {\n            if (this.type !== tt.string) {\n              this.unexpected();\n            }\n\n            node.source = this.parseExprAtom();\n\n            if (this.type === this.assertToken) {\n              this.next();\n\n              var _assertions = this.parseImportAssertions();\n\n              if (_assertions) {\n                node.assertions = _assertions;\n              }\n            }\n          } else {\n            for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n              // check for keywords used as local names\n              var spec = list[i];\n              this.checkUnreserved(spec.local); // check if export is defined\n\n              this.checkLocalExport(spec.local);\n            }\n\n            node.source = null;\n          }\n\n          this.semicolon();\n        }\n\n        return this.finishNode(node, \"ExportNamedDeclaration\");\n      }\n    }, {\n      key: \"parseImport\",\n      value: function parseImport(node) {\n        this.next(); // import '...'\n\n        if (this.type === tt.string) {\n          node.specifiers = [];\n          node.source = this.parseExprAtom();\n        } else {\n          node.specifiers = this.parseImportSpecifiers();\n          this.expectContextual(\"from\");\n          node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n        }\n\n        if (this.type === this.assertToken) {\n          this.next();\n          var assertions = this.parseImportAssertions();\n\n          if (assertions) {\n            node.assertions = assertions;\n          }\n        }\n\n        this.semicolon();\n        return this.finishNode(node, \"ImportDeclaration\");\n      }\n    }, {\n      key: \"parseImportAssertions\",\n      value: function parseImportAssertions() {\n        this._eat(tt.braceL);\n\n        var attrs = this.parseAssertEntries();\n\n        this._eat(tt.braceR);\n\n        return attrs;\n      }\n    }, {\n      key: \"parseAssertEntries\",\n      value: function parseAssertEntries() {\n        var attrs = [];\n        var attrNames = new Set();\n\n        do {\n          if (this.type === tt.braceR) {\n            break;\n          }\n\n          var node = this.startNode(); // parse AssertionKey : IdentifierName, StringLiteral\n\n          var assertionKeyNode = void 0;\n\n          if (this.type === tt.string) {\n            assertionKeyNode = this.parseLiteral(this.value);\n          } else {\n            assertionKeyNode = this.parseIdent(true);\n          }\n\n          this.next();\n          node.key = assertionKeyNode; // check if we already have an entry for an attribute\n          // if a duplicate entry is found, throw an error\n          // for now this logic will come into play only when someone declares `type` twice\n\n          if (attrNames.has(node.key.name)) {\n            this.raise(this.pos, \"Duplicated key in assertions\");\n          }\n\n          attrNames.add(node.key.name);\n\n          if (this.type !== tt.string) {\n            this.raise(this.pos, \"Only string is supported as an assertion value\");\n          }\n\n          node.value = this.parseLiteral(this.value);\n          attrs.push(this.finishNode(node, \"ImportAttribute\"));\n        } while (this.eat(tt.comma));\n\n        return attrs;\n      }\n    }]);\n\n    return _class;\n  }(Parser);\n}","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/acorn-import-assertions/lib/index.js"],"names":["Object","defineProperty","exports","value","importAssertions","_acorn","_interopRequireWildcard","require","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","leftCurlyBrace","charCodeAt","space","keyword","FUNC_STATEMENT","FUNC_HANGING_STATEMENT","FUNC_NULLABLE_ID","Parser","acorn","tt","tokTypes","TokenType","args","assertToken","i","input","t","type","unexpected","next","code","length","_codeAt","pos","label","finishToken","node","source","parseMaybeAssign","eat","comma","parseObj","arguments","_eat","parenR","finishNode","star","options","ecmaVersion","eatContextual","exported","parseIdent","checkExport","name","lastTokStart","expectContextual","string","parseExprAtom","assertions","parseImportAssertions","semicolon","_default","isAsync","_function","isAsyncFunction","fNode","startNode","declaration","parseFunction","_class","cNode","parseClass","shouldParseExportStatement","parseStatement","checkVariableExport","declarations","id","start","specifiers","parseExportSpecifiers","list","spec","checkUnreserved","local","checkLocalExport","parseImportSpecifiers","braceL","attrs","parseAssertEntries","braceR","attrNames","Set","assertionKeyNode","parseLiteral","raise","add","push"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importAssertions = importAssertions;\n\nvar _acorn = _interopRequireWildcard(require(\"acorn\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst leftCurlyBrace = \"{\".charCodeAt(0);\nconst space = \" \".charCodeAt(0);\nconst keyword = \"assert\";\nconst FUNC_STATEMENT = 1,\n      FUNC_HANGING_STATEMENT = 2,\n      FUNC_NULLABLE_ID = 4;\n\nfunction importAssertions(Parser) {\n  // Use supplied version acorn version if present, to avoid\n  // reference mismatches due to different acorn versions. This\n  // allows this plugin to be used with Rollup which supplies\n  // its own internal version of acorn and thereby sidesteps\n  // the package manager.\n  const acorn = Parser.acorn || _acorn;\n  const {\n    tokTypes: tt,\n    TokenType\n  } = acorn;\n  return class extends Parser {\n    constructor(...args) {\n      super(...args);\n      this.assertToken = new TokenType(keyword);\n    }\n\n    _codeAt(i) {\n      return this.input.charCodeAt(i);\n    }\n\n    _eat(t) {\n      if (this.type !== t) {\n        this.unexpected();\n      }\n\n      this.next();\n    }\n\n    readToken(code) {\n      let i = 0;\n\n      for (; i < keyword.length; i++) {\n        if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {\n          return super.readToken(code);\n        }\n      } // ensure that the keyword is at the correct location\n      // ie `assert{...` or `assert {...`\n\n\n      for (;; i++) {\n        if (this._codeAt(this.pos + i) === leftCurlyBrace) {\n          // Found '{'\n          break;\n        } else if (this._codeAt(this.pos + i) === space) {\n          // white space is allowed between `assert` and `{`, so continue.\n          continue;\n        } else {\n          return super.readToken(code);\n        }\n      } // If we're inside a dynamic import expression we'll parse\n      // the `assert` keyword as a standard object property name\n      // ie `import(\"\"./foo.json\", { assert: { type: \"json\" } })`\n\n\n      if (this.type.label === \"{\") {\n        return super.readToken(code);\n      }\n\n      this.pos += keyword.length;\n      return this.finishToken(this.assertToken);\n    }\n\n    parseDynamicImport(node) {\n      this.next(); // skip `(`\n      // Parse node.source.\n\n      node.source = this.parseMaybeAssign();\n\n      if (this.eat(tt.comma)) {\n        const obj = this.parseObj(false);\n        node.arguments = [obj];\n      }\n\n      this._eat(tt.parenR);\n\n      return this.finishNode(node, \"ImportExpression\");\n    } // ported from acorn/src/statement.js pp.parseExport\n\n\n    parseExport(node, exports) {\n      this.next(); // export * from '...'\n\n      if (this.eat(tt.star)) {\n        if (this.options.ecmaVersion >= 11) {\n          if (this.eatContextual(\"as\")) {\n            node.exported = this.parseIdent(true);\n            this.checkExport(exports, node.exported.name, this.lastTokStart);\n          } else {\n            node.exported = null;\n          }\n        }\n\n        this.expectContextual(\"from\");\n\n        if (this.type !== tt.string) {\n          this.unexpected();\n        }\n\n        node.source = this.parseExprAtom();\n\n        if (this.type === this.assertToken) {\n          this.next();\n          const assertions = this.parseImportAssertions();\n\n          if (assertions) {\n            node.assertions = assertions;\n          }\n        }\n\n        this.semicolon();\n        return this.finishNode(node, \"ExportAllDeclaration\");\n      }\n\n      if (this.eat(tt._default)) {\n        // export default ...\n        this.checkExport(exports, \"default\", this.lastTokStart);\n        var isAsync;\n\n        if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n          var fNode = this.startNode();\n          this.next();\n\n          if (isAsync) {\n            this.next();\n          }\n\n          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n        } else if (this.type === tt._class) {\n          var cNode = this.startNode();\n          node.declaration = this.parseClass(cNode, \"nullableID\");\n        } else {\n          node.declaration = this.parseMaybeAssign();\n          this.semicolon();\n        }\n\n        return this.finishNode(node, \"ExportDefaultDeclaration\");\n      } // export var|const|let|function|class ...\n\n\n      if (this.shouldParseExportStatement()) {\n        node.declaration = this.parseStatement(null);\n\n        if (node.declaration.type === \"VariableDeclaration\") {\n          this.checkVariableExport(exports, node.declaration.declarations);\n        } else {\n          this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n        }\n\n        node.specifiers = [];\n        node.source = null;\n      } else {\n        // export { x, y as z } [from '...']\n        node.declaration = null;\n        node.specifiers = this.parseExportSpecifiers(exports);\n\n        if (this.eatContextual(\"from\")) {\n          if (this.type !== tt.string) {\n            this.unexpected();\n          }\n\n          node.source = this.parseExprAtom();\n\n          if (this.type === this.assertToken) {\n            this.next();\n            const assertions = this.parseImportAssertions();\n\n            if (assertions) {\n              node.assertions = assertions;\n            }\n          }\n        } else {\n          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n            // check for keywords used as local names\n            var spec = list[i];\n            this.checkUnreserved(spec.local); // check if export is defined\n\n            this.checkLocalExport(spec.local);\n          }\n\n          node.source = null;\n        }\n\n        this.semicolon();\n      }\n\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    parseImport(node) {\n      this.next(); // import '...'\n\n      if (this.type === tt.string) {\n        node.specifiers = [];\n        node.source = this.parseExprAtom();\n      } else {\n        node.specifiers = this.parseImportSpecifiers();\n        this.expectContextual(\"from\");\n        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n      }\n\n      if (this.type === this.assertToken) {\n        this.next();\n        const assertions = this.parseImportAssertions();\n\n        if (assertions) {\n          node.assertions = assertions;\n        }\n      }\n\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    parseImportAssertions() {\n      this._eat(tt.braceL);\n\n      const attrs = this.parseAssertEntries();\n\n      this._eat(tt.braceR);\n\n      return attrs;\n    }\n\n    parseAssertEntries() {\n      const attrs = [];\n      const attrNames = new Set();\n\n      do {\n        if (this.type === tt.braceR) {\n          break;\n        }\n\n        const node = this.startNode(); // parse AssertionKey : IdentifierName, StringLiteral\n\n        let assertionKeyNode;\n\n        if (this.type === tt.string) {\n          assertionKeyNode = this.parseLiteral(this.value);\n        } else {\n          assertionKeyNode = this.parseIdent(true);\n        }\n\n        this.next();\n        node.key = assertionKeyNode; // check if we already have an entry for an attribute\n        // if a duplicate entry is found, throw an error\n        // for now this logic will come into play only when someone declares `type` twice\n\n        if (attrNames.has(node.key.name)) {\n          this.raise(this.pos, \"Duplicated key in assertions\");\n        }\n\n        attrNames.add(node.key.name);\n\n        if (this.type !== tt.string) {\n          this.raise(this.pos, \"Only string is supported as an assertion value\");\n        }\n\n        node.value = this.parseLiteral(this.value);\n        attrs.push(this.finishNode(node, \"ImportAttribute\"));\n      } while (this.eat(tt.comma));\n\n      return attrs;\n    }\n\n  };\n}"]},"metadata":{},"sourceType":"script"}