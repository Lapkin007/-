{"ast":null,"code":"/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls$\" }] */\n'use strict';\n\nvar _defineProperty = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\n\nvar _classCallCheck = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nrequire(\"core-js/modules/es.symbol.js\");\n\nrequire(\"core-js/modules/es.symbol.description.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.reflect.apply.js\");\n\nrequire(\"core-js/modules/es.reflect.to-string-tag.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nvar net = require('net');\n\nvar tls = require('tls');\n\nvar _require = require('crypto'),\n    randomFillSync = _require.randomFillSync;\n\nvar PerMessageDeflate = require('./permessage-deflate');\n\nvar _require2 = require('./constants'),\n    EMPTY_BUFFER = _require2.EMPTY_BUFFER;\n\nvar _require3 = require('./validation'),\n    isValidStatusCode = _require3.isValidStatusCode;\n\nvar _require4 = require('./buffer-util'),\n    applyMask = _require4.mask,\n    toBuffer = _require4.toBuffer;\n\nvar kByteLength = Symbol('kByteLength');\nvar maskBuffer = Buffer.alloc(4);\n/**\n * HyBi Sender implementation.\n */\n\nvar Sender = /*#__PURE__*/function () {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  function Sender(socket, extensions, generateMask) {\n    _classCallCheck(this, Sender);\n\n    this._extensions = extensions || {};\n\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n\n    this._socket = socket;\n    this._firstFragment = true;\n    this._compress = false;\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n\n\n  _createClass(Sender, [{\n    key: \"close\",\n    value:\n    /**\n     * Sends a close message to the other peer.\n     *\n     * @param {Number} [code] The status code component of the body\n     * @param {(String|Buffer)} [data] The message component of the body\n     * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n     * @param {Function} [cb] Callback\n     * @public\n     */\n    function close(code, data, mask, cb) {\n      var _options;\n\n      var buf;\n\n      if (code === undefined) {\n        buf = EMPTY_BUFFER;\n      } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n        throw new TypeError('First argument must be a valid error code number');\n      } else if (data === undefined || !data.length) {\n        buf = Buffer.allocUnsafe(2);\n        buf.writeUInt16BE(code, 0);\n      } else {\n        var length = Buffer.byteLength(data);\n\n        if (length > 123) {\n          throw new RangeError('The message must not be greater than 123 bytes');\n        }\n\n        buf = Buffer.allocUnsafe(2 + length);\n        buf.writeUInt16BE(code, 0);\n\n        if (typeof data === 'string') {\n          buf.write(data, 2);\n        } else {\n          buf.set(data, 2);\n        }\n      }\n\n      var options = (_options = {}, _defineProperty(_options, kByteLength, buf.length), _defineProperty(_options, \"fin\", true), _defineProperty(_options, \"generateMask\", this._generateMask), _defineProperty(_options, \"mask\", mask), _defineProperty(_options, \"maskBuffer\", this._maskBuffer), _defineProperty(_options, \"opcode\", 0x08), _defineProperty(_options, \"readOnly\", false), _defineProperty(_options, \"rsv1\", false), _options);\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, buf, false, options, cb]);\n      } else {\n        this.sendFrame(Sender.frame(buf, options), cb);\n      }\n    }\n    /**\n     * Sends a ping message to the other peer.\n     *\n     * @param {*} data The message to send\n     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n     * @param {Function} [cb] Callback\n     * @public\n     */\n\n  }, {\n    key: \"ping\",\n    value: function ping(data, mask, cb) {\n      var _options2;\n\n      var byteLength;\n      var readOnly;\n\n      if (typeof data === 'string') {\n        byteLength = Buffer.byteLength(data);\n        readOnly = false;\n      } else {\n        data = toBuffer(data);\n        byteLength = data.length;\n        readOnly = toBuffer.readOnly;\n      }\n\n      if (byteLength > 125) {\n        throw new RangeError('The data size must not be greater than 125 bytes');\n      }\n\n      var options = (_options2 = {}, _defineProperty(_options2, kByteLength, byteLength), _defineProperty(_options2, \"fin\", true), _defineProperty(_options2, \"generateMask\", this._generateMask), _defineProperty(_options2, \"mask\", mask), _defineProperty(_options2, \"maskBuffer\", this._maskBuffer), _defineProperty(_options2, \"opcode\", 0x09), _defineProperty(_options2, \"readOnly\", readOnly), _defineProperty(_options2, \"rsv1\", false), _options2);\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, false, options, cb]);\n      } else {\n        this.sendFrame(Sender.frame(data, options), cb);\n      }\n    }\n    /**\n     * Sends a pong message to the other peer.\n     *\n     * @param {*} data The message to send\n     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n     * @param {Function} [cb] Callback\n     * @public\n     */\n\n  }, {\n    key: \"pong\",\n    value: function pong(data, mask, cb) {\n      var _options3;\n\n      var byteLength;\n      var readOnly;\n\n      if (typeof data === 'string') {\n        byteLength = Buffer.byteLength(data);\n        readOnly = false;\n      } else {\n        data = toBuffer(data);\n        byteLength = data.length;\n        readOnly = toBuffer.readOnly;\n      }\n\n      if (byteLength > 125) {\n        throw new RangeError('The data size must not be greater than 125 bytes');\n      }\n\n      var options = (_options3 = {}, _defineProperty(_options3, kByteLength, byteLength), _defineProperty(_options3, \"fin\", true), _defineProperty(_options3, \"generateMask\", this._generateMask), _defineProperty(_options3, \"mask\", mask), _defineProperty(_options3, \"maskBuffer\", this._maskBuffer), _defineProperty(_options3, \"opcode\", 0x0a), _defineProperty(_options3, \"readOnly\", readOnly), _defineProperty(_options3, \"rsv1\", false), _options3);\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, false, options, cb]);\n      } else {\n        this.sendFrame(Sender.frame(data, options), cb);\n      }\n    }\n    /**\n     * Sends a data message to the other peer.\n     *\n     * @param {*} data The message to send\n     * @param {Object} options Options object\n     * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n     *     or text\n     * @param {Boolean} [options.compress=false] Specifies whether or not to\n     *     compress `data`\n     * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n     *     last one\n     * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n     *     `data`\n     * @param {Function} [cb] Callback\n     * @public\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(data, options, cb) {\n      var perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n      var opcode = options.binary ? 2 : 1;\n      var rsv1 = options.compress;\n      var byteLength;\n      var readOnly;\n\n      if (typeof data === 'string') {\n        byteLength = Buffer.byteLength(data);\n        readOnly = false;\n      } else {\n        data = toBuffer(data);\n        byteLength = data.length;\n        readOnly = toBuffer.readOnly;\n      }\n\n      if (this._firstFragment) {\n        this._firstFragment = false;\n\n        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? 'server_no_context_takeover' : 'client_no_context_takeover']) {\n          rsv1 = byteLength >= perMessageDeflate._threshold;\n        }\n\n        this._compress = rsv1;\n      } else {\n        rsv1 = false;\n        opcode = 0;\n      }\n\n      if (options.fin) this._firstFragment = true;\n\n      if (perMessageDeflate) {\n        var _opts;\n\n        var opts = (_opts = {}, _defineProperty(_opts, kByteLength, byteLength), _defineProperty(_opts, \"fin\", options.fin), _defineProperty(_opts, \"generateMask\", this._generateMask), _defineProperty(_opts, \"mask\", options.mask), _defineProperty(_opts, \"maskBuffer\", this._maskBuffer), _defineProperty(_opts, \"opcode\", opcode), _defineProperty(_opts, \"readOnly\", readOnly), _defineProperty(_opts, \"rsv1\", rsv1), _opts);\n\n        if (this._deflating) {\n          this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n        } else {\n          this.dispatch(data, this._compress, opts, cb);\n        }\n      } else {\n        var _Sender$frame;\n\n        this.sendFrame(Sender.frame(data, (_Sender$frame = {}, _defineProperty(_Sender$frame, kByteLength, byteLength), _defineProperty(_Sender$frame, \"fin\", options.fin), _defineProperty(_Sender$frame, \"generateMask\", this._generateMask), _defineProperty(_Sender$frame, \"mask\", options.mask), _defineProperty(_Sender$frame, \"maskBuffer\", this._maskBuffer), _defineProperty(_Sender$frame, \"opcode\", opcode), _defineProperty(_Sender$frame, \"readOnly\", readOnly), _defineProperty(_Sender$frame, \"rsv1\", false), _Sender$frame)), cb);\n      }\n    }\n    /**\n     * Dispatches a message.\n     *\n     * @param {(Buffer|String)} data The message to send\n     * @param {Boolean} [compress=false] Specifies whether or not to compress\n     *     `data`\n     * @param {Object} options Options object\n     * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n     *     FIN bit\n     * @param {Function} [options.generateMask] The function used to generate the\n     *     masking key\n     * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n     *     `data`\n     * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n     *     key\n     * @param {Number} options.opcode The opcode\n     * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n     *     modified\n     * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n     *     RSV1 bit\n     * @param {Function} [cb] Callback\n     * @private\n     */\n\n  }, {\n    key: \"dispatch\",\n    value: function dispatch(data, compress, options, cb) {\n      var _this = this;\n\n      if (!compress) {\n        this.sendFrame(Sender.frame(data, options), cb);\n        return;\n      }\n\n      var perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n      this._bufferedBytes += options[kByteLength];\n      this._deflating = true;\n      perMessageDeflate.compress(data, options.fin, function (_, buf) {\n        if (_this._socket.destroyed) {\n          var err = new Error('The socket was closed while data was being compressed');\n          if (typeof cb === 'function') cb(err);\n\n          for (var i = 0; i < _this._queue.length; i++) {\n            var params = _this._queue[i];\n            var callback = params[params.length - 1];\n            if (typeof callback === 'function') callback(err);\n          }\n\n          return;\n        }\n\n        _this._bufferedBytes -= options[kByteLength];\n        _this._deflating = false;\n        options.readOnly = false;\n\n        _this.sendFrame(Sender.frame(buf, options), cb);\n\n        _this.dequeue();\n      });\n    }\n    /**\n     * Executes queued send operations.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"dequeue\",\n    value: function dequeue() {\n      while (!this._deflating && this._queue.length) {\n        var params = this._queue.shift();\n\n        this._bufferedBytes -= params[3][kByteLength];\n        Reflect.apply(params[0], this, params.slice(1));\n      }\n    }\n    /**\n     * Enqueues a send operation.\n     *\n     * @param {Array} params Send operation parameters.\n     * @private\n     */\n\n  }, {\n    key: \"enqueue\",\n    value: function enqueue(params) {\n      this._bufferedBytes += params[3][kByteLength];\n\n      this._queue.push(params);\n    }\n    /**\n     * Sends a frame.\n     *\n     * @param {Buffer[]} list The frame to send\n     * @param {Function} [cb] Callback\n     * @private\n     */\n\n  }, {\n    key: \"sendFrame\",\n    value: function sendFrame(list, cb) {\n      if (list.length === 2) {\n        this._socket.cork();\n\n        this._socket.write(list[0]);\n\n        this._socket.write(list[1], cb);\n\n        this._socket.uncork();\n      } else {\n        this._socket.write(list[0], cb);\n      }\n    }\n  }], [{\n    key: \"frame\",\n    value: function frame(data, options) {\n      var mask;\n      var merge = false;\n      var offset = 2;\n      var skipMasking = false;\n\n      if (options.mask) {\n        mask = options.maskBuffer || maskBuffer;\n\n        if (options.generateMask) {\n          options.generateMask(mask);\n        } else {\n          randomFillSync(mask, 0, 4);\n        }\n\n        skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n        offset = 6;\n      }\n\n      var dataLength;\n\n      if (typeof data === 'string') {\n        if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {\n          dataLength = options[kByteLength];\n        } else {\n          data = Buffer.from(data);\n          dataLength = data.length;\n        }\n      } else {\n        dataLength = data.length;\n        merge = options.mask && options.readOnly && !skipMasking;\n      }\n\n      var payloadLength = dataLength;\n\n      if (dataLength >= 65536) {\n        offset += 8;\n        payloadLength = 127;\n      } else if (dataLength > 125) {\n        offset += 2;\n        payloadLength = 126;\n      }\n\n      var target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n      target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n      if (options.rsv1) target[0] |= 0x40;\n      target[1] = payloadLength;\n\n      if (payloadLength === 126) {\n        target.writeUInt16BE(dataLength, 2);\n      } else if (payloadLength === 127) {\n        target[2] = target[3] = 0;\n        target.writeUIntBE(dataLength, 4, 6);\n      }\n\n      if (!options.mask) return [target, data];\n      target[1] |= 0x80;\n      target[offset - 4] = mask[0];\n      target[offset - 3] = mask[1];\n      target[offset - 2] = mask[2];\n      target[offset - 1] = mask[3];\n      if (skipMasking) return [target, data];\n\n      if (merge) {\n        applyMask(data, mask, target, offset, dataLength);\n        return [target];\n      }\n\n      applyMask(data, mask, data, 0, dataLength);\n      return [target, data];\n    }\n  }]);\n\n  return Sender;\n}();\n\nmodule.exports = Sender;","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/webpack-dev-server/node_modules/ws/lib/sender.js"],"names":["net","require","tls","randomFillSync","PerMessageDeflate","EMPTY_BUFFER","isValidStatusCode","applyMask","mask","toBuffer","kByteLength","Symbol","maskBuffer","Buffer","alloc","Sender","socket","extensions","generateMask","_extensions","_generateMask","_maskBuffer","_socket","_firstFragment","_compress","_bufferedBytes","_deflating","_queue","code","data","cb","buf","undefined","TypeError","length","allocUnsafe","writeUInt16BE","byteLength","RangeError","write","set","options","enqueue","dispatch","sendFrame","frame","readOnly","perMessageDeflate","extensionName","opcode","binary","rsv1","compress","params","_isServer","_threshold","fin","opts","_","destroyed","err","Error","i","callback","dequeue","shift","Reflect","apply","slice","push","list","cork","uncork","merge","offset","skipMasking","dataLength","from","payloadLength","target","writeUIntBE","module","exports"],"mappings":"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","sourcesContent":["/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls$\" }] */\n\n'use strict';\n\nconst net = require('net');\nconst tls = require('tls');\nconst { randomFillSync } = require('crypto');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst { EMPTY_BUFFER } = require('./constants');\nconst { isValidStatusCode } = require('./validation');\nconst { mask: applyMask, toBuffer } = require('./buffer-util');\n\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n  static frame(data, options) {\n    let mask;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n\n    if (options.mask) {\n      mask = options.maskBuffer || maskBuffer;\n\n      if (options.generateMask) {\n        options.generateMask(mask);\n      } else {\n        randomFillSync(mask, 0, 4);\n      }\n\n      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n      offset = 6;\n    }\n\n    let dataLength;\n\n    if (typeof data === 'string') {\n      if (\n        (!options.mask || skipMasking) &&\n        options[kByteLength] !== undefined\n      ) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n\n    let payloadLength = dataLength;\n\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (skipMasking) return [target, data];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, dataLength);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, dataLength);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n\n      if (typeof data === 'string') {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x08,\n      readOnly: false,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x09,\n      readOnly,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x0a,\n      readOnly,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (\n        rsv1 &&\n        perMessageDeflate &&\n        perMessageDeflate.params[\n          perMessageDeflate._isServer\n            ? 'server_no_context_takeover'\n            : 'client_no_context_takeover'\n        ]\n      ) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        [kByteLength]: byteLength,\n        fin: options.fin,\n        generateMask: this._generateMask,\n        mask: options.mask,\n        maskBuffer: this._maskBuffer,\n        opcode,\n        readOnly,\n        rsv1\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n      } else {\n        this.dispatch(data, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(data, {\n          [kByteLength]: byteLength,\n          fin: options.fin,\n          generateMask: this._generateMask,\n          mask: options.mask,\n          maskBuffer: this._maskBuffer,\n          opcode,\n          readOnly,\n          rsv1: false\n        }),\n        cb\n      );\n    }\n  }\n\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._bufferedBytes += options[kByteLength];\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          'The socket was closed while data was being compressed'\n        );\n\n        if (typeof cb === 'function') cb(err);\n\n        for (let i = 0; i < this._queue.length; i++) {\n          const params = this._queue[i];\n          const callback = params[params.length - 1];\n\n          if (typeof callback === 'function') callback(err);\n        }\n\n        return;\n      }\n\n      this._bufferedBytes -= options[kByteLength];\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n"]},"metadata":{},"sourceType":"script"}