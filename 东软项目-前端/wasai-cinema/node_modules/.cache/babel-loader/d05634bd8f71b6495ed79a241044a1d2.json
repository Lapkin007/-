{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _typeof = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/typeof.js\").default;\n\nrequire(\"regenerator-runtime/runtime.js\");\n\nrequire(\"core-js/modules/es.number.is-finite.js\");\n\nrequire(\"core-js/modules/es.number.constructor.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nvar os = require('os');\n\nvar onExit = require('signal-exit');\n\nvar DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5; // Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior\n\nvar spawnedKill = function spawnedKill(kill) {\n  var signal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'SIGTERM';\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var killResult = kill(signal);\n  setKillTimeout(kill, signal, options, killResult);\n  return killResult;\n};\n\nvar setKillTimeout = function setKillTimeout(kill, signal, options, killResult) {\n  if (!shouldForceKill(signal, options, killResult)) {\n    return;\n  }\n\n  var timeout = getForceKillAfterTimeout(options);\n  var t = setTimeout(function () {\n    kill('SIGKILL');\n  }, timeout); // Guarded because there's no `.unref()` when `execa` is used in the renderer\n  // process in Electron. This cannot be tested since we don't run tests in\n  // Electron.\n  // istanbul ignore else\n\n  if (t.unref) {\n    t.unref();\n  }\n};\n\nvar shouldForceKill = function shouldForceKill(signal, _ref, killResult) {\n  var forceKillAfterTimeout = _ref.forceKillAfterTimeout;\n  return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;\n};\n\nvar isSigterm = function isSigterm(signal) {\n  return signal === os.constants.signals.SIGTERM || typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM';\n};\n\nvar getForceKillAfterTimeout = function getForceKillAfterTimeout(_ref2) {\n  var _ref2$forceKillAfterT = _ref2.forceKillAfterTimeout,\n      forceKillAfterTimeout = _ref2$forceKillAfterT === void 0 ? true : _ref2$forceKillAfterT;\n\n  if (forceKillAfterTimeout === true) {\n    return DEFAULT_FORCE_KILL_TIMEOUT;\n  }\n\n  if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {\n    throw new TypeError(\"Expected the `forceKillAfterTimeout` option to be a non-negative integer, got `\".concat(forceKillAfterTimeout, \"` (\").concat(_typeof(forceKillAfterTimeout), \")\"));\n  }\n\n  return forceKillAfterTimeout;\n}; // `childProcess.cancel()`\n\n\nvar spawnedCancel = function spawnedCancel(spawned, context) {\n  var killResult = spawned.kill();\n\n  if (killResult) {\n    context.isCanceled = true;\n  }\n};\n\nvar timeoutKill = function timeoutKill(spawned, signal, reject) {\n  spawned.kill(signal);\n  reject(Object.assign(new Error('Timed out'), {\n    timedOut: true,\n    signal: signal\n  }));\n}; // `timeout` option handling\n\n\nvar setupTimeout = function setupTimeout(spawned, _ref3, spawnedPromise) {\n  var timeout = _ref3.timeout,\n      _ref3$killSignal = _ref3.killSignal,\n      killSignal = _ref3$killSignal === void 0 ? 'SIGTERM' : _ref3$killSignal;\n\n  if (timeout === 0 || timeout === undefined) {\n    return spawnedPromise;\n  }\n\n  var timeoutId;\n  var timeoutPromise = new Promise(function (resolve, reject) {\n    timeoutId = setTimeout(function () {\n      timeoutKill(spawned, killSignal, reject);\n    }, timeout);\n  });\n  var safeSpawnedPromise = spawnedPromise.finally(function () {\n    clearTimeout(timeoutId);\n  });\n  return Promise.race([timeoutPromise, safeSpawnedPromise]);\n};\n\nvar validateTimeout = function validateTimeout(_ref4) {\n  var timeout = _ref4.timeout;\n\n  if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {\n    throw new TypeError(\"Expected the `timeout` option to be a non-negative integer, got `\".concat(timeout, \"` (\").concat(_typeof(timeout), \")\"));\n  }\n}; // `cleanup` option handling\n\n\nvar setExitHandler = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(spawned, _ref5, timedPromise) {\n    var cleanup, detached, removeExitHandler;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            cleanup = _ref5.cleanup, detached = _ref5.detached;\n\n            if (!(!cleanup || detached)) {\n              _context.next = 3;\n              break;\n            }\n\n            return _context.abrupt(\"return\", timedPromise);\n\n          case 3:\n            removeExitHandler = onExit(function () {\n              spawned.kill();\n            });\n            return _context.abrupt(\"return\", timedPromise.finally(function () {\n              removeExitHandler();\n            }));\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function setExitHandler(_x, _x2, _x3) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nmodule.exports = {\n  spawnedKill: spawnedKill,\n  spawnedCancel: spawnedCancel,\n  setupTimeout: setupTimeout,\n  validateTimeout: validateTimeout,\n  setExitHandler: setExitHandler\n};","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/default-gateway/node_modules/execa/lib/kill.js"],"names":["os","require","onExit","DEFAULT_FORCE_KILL_TIMEOUT","spawnedKill","kill","signal","options","killResult","setKillTimeout","shouldForceKill","timeout","getForceKillAfterTimeout","t","setTimeout","unref","forceKillAfterTimeout","isSigterm","constants","signals","SIGTERM","toUpperCase","Number","isFinite","TypeError","spawnedCancel","spawned","context","isCanceled","timeoutKill","reject","Object","assign","Error","timedOut","setupTimeout","spawnedPromise","killSignal","undefined","timeoutId","timeoutPromise","Promise","resolve","safeSpawnedPromise","finally","clearTimeout","race","validateTimeout","setExitHandler","timedPromise","cleanup","detached","removeExitHandler","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst os = require('os');\nconst onExit = require('signal-exit');\n\nconst DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;\n\n// Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior\nconst spawnedKill = (kill, signal = 'SIGTERM', options = {}) => {\n\tconst killResult = kill(signal);\n\tsetKillTimeout(kill, signal, options, killResult);\n\treturn killResult;\n};\n\nconst setKillTimeout = (kill, signal, options, killResult) => {\n\tif (!shouldForceKill(signal, options, killResult)) {\n\t\treturn;\n\t}\n\n\tconst timeout = getForceKillAfterTimeout(options);\n\tconst t = setTimeout(() => {\n\t\tkill('SIGKILL');\n\t}, timeout);\n\n\t// Guarded because there's no `.unref()` when `execa` is used in the renderer\n\t// process in Electron. This cannot be tested since we don't run tests in\n\t// Electron.\n\t// istanbul ignore else\n\tif (t.unref) {\n\t\tt.unref();\n\t}\n};\n\nconst shouldForceKill = (signal, {forceKillAfterTimeout}, killResult) => {\n\treturn isSigterm(signal) && forceKillAfterTimeout !== false && killResult;\n};\n\nconst isSigterm = signal => {\n\treturn signal === os.constants.signals.SIGTERM ||\n\t\t(typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM');\n};\n\nconst getForceKillAfterTimeout = ({forceKillAfterTimeout = true}) => {\n\tif (forceKillAfterTimeout === true) {\n\t\treturn DEFAULT_FORCE_KILL_TIMEOUT;\n\t}\n\n\tif (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {\n\t\tthrow new TypeError(`Expected the \\`forceKillAfterTimeout\\` option to be a non-negative integer, got \\`${forceKillAfterTimeout}\\` (${typeof forceKillAfterTimeout})`);\n\t}\n\n\treturn forceKillAfterTimeout;\n};\n\n// `childProcess.cancel()`\nconst spawnedCancel = (spawned, context) => {\n\tconst killResult = spawned.kill();\n\n\tif (killResult) {\n\t\tcontext.isCanceled = true;\n\t}\n};\n\nconst timeoutKill = (spawned, signal, reject) => {\n\tspawned.kill(signal);\n\treject(Object.assign(new Error('Timed out'), {timedOut: true, signal}));\n};\n\n// `timeout` option handling\nconst setupTimeout = (spawned, {timeout, killSignal = 'SIGTERM'}, spawnedPromise) => {\n\tif (timeout === 0 || timeout === undefined) {\n\t\treturn spawnedPromise;\n\t}\n\n\tlet timeoutId;\n\tconst timeoutPromise = new Promise((resolve, reject) => {\n\t\ttimeoutId = setTimeout(() => {\n\t\t\ttimeoutKill(spawned, killSignal, reject);\n\t\t}, timeout);\n\t});\n\n\tconst safeSpawnedPromise = spawnedPromise.finally(() => {\n\t\tclearTimeout(timeoutId);\n\t});\n\n\treturn Promise.race([timeoutPromise, safeSpawnedPromise]);\n};\n\nconst validateTimeout = ({timeout}) => {\n\tif (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {\n\t\tthrow new TypeError(`Expected the \\`timeout\\` option to be a non-negative integer, got \\`${timeout}\\` (${typeof timeout})`);\n\t}\n};\n\n// `cleanup` option handling\nconst setExitHandler = async (spawned, {cleanup, detached}, timedPromise) => {\n\tif (!cleanup || detached) {\n\t\treturn timedPromise;\n\t}\n\n\tconst removeExitHandler = onExit(() => {\n\t\tspawned.kill();\n\t});\n\n\treturn timedPromise.finally(() => {\n\t\tremoveExitHandler();\n\t});\n};\n\nmodule.exports = {\n\tspawnedKill,\n\tspawnedCancel,\n\tsetupTimeout,\n\tvalidateTimeout,\n\tsetExitHandler\n};\n"]},"metadata":{},"sourceType":"script"}