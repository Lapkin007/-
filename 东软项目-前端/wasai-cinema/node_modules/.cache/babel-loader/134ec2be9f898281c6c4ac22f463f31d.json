{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _slicedToArray = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _asyncToGenerator = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.reflect.get-own-property-descriptor.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.reflect.to-string-tag.js\");\n\nrequire(\"core-js/modules/es.reflect.apply.js\");\n\nrequire(\"core-js/modules/es.reflect.define-property.js\");\n\nrequire(\"regenerator-runtime/runtime.js\");\n\nvar nativePromisePrototype = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n  return regeneratorRuntime.wrap(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _callee);\n}))().constructor.prototype;\n\nvar descriptors = ['then', 'catch', 'finally'].map(function (property) {\n  return [property, Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)];\n}); // The return value is a mixin of `childProcess` and `Promise`\n\nvar mergePromise = function mergePromise(spawned, promise) {\n  var _iterator = _createForOfIteratorHelper(descriptors),\n      _step;\n\n  try {\n    var _loop = function _loop() {\n      var _step$value = _slicedToArray(_step.value, 2),\n          property = _step$value[0],\n          descriptor = _step$value[1];\n\n      // Starting the main `promise` is deferred to avoid consuming streams\n      var value = typeof promise === 'function' ? function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return Reflect.apply(descriptor.value, promise(), args);\n      } : descriptor.value.bind(promise);\n      Reflect.defineProperty(spawned, property, _objectSpread(_objectSpread({}, descriptor), {}, {\n        value: value\n      }));\n    };\n\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return spawned;\n}; // Use promises instead of `child_process` events\n\n\nvar getSpawnedPromise = function getSpawnedPromise(spawned) {\n  return new Promise(function (resolve, reject) {\n    spawned.on('exit', function (exitCode, signal) {\n      resolve({\n        exitCode: exitCode,\n        signal: signal\n      });\n    });\n    spawned.on('error', function (error) {\n      reject(error);\n    });\n\n    if (spawned.stdin) {\n      spawned.stdin.on('error', function (error) {\n        reject(error);\n      });\n    }\n  });\n};\n\nmodule.exports = {\n  mergePromise: mergePromise,\n  getSpawnedPromise: getSpawnedPromise\n};","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/default-gateway/node_modules/execa/lib/promise.js"],"names":["nativePromisePrototype","constructor","prototype","descriptors","map","property","Reflect","getOwnPropertyDescriptor","mergePromise","spawned","promise","descriptor","value","args","apply","bind","defineProperty","getSpawnedPromise","Promise","resolve","reject","on","exitCode","signal","error","stdin","module","exports"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,sBAAsB,GAAG,wDAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAD,KAAmBC,WAAnB,CAA+BC,SAA9D;;AACA,IAAMC,WAAW,GAAG,CAAC,MAAD,EAAS,OAAT,EAAkB,SAAlB,EAA6BC,GAA7B,CAAiC,UAAAC,QAAQ;AAAA,SAAI,CAChEA,QADgE,EAEhEC,OAAO,CAACC,wBAAR,CAAiCP,sBAAjC,EAAyDK,QAAzD,CAFgE,CAAJ;AAAA,CAAzC,CAApB,C,CAKA;;AACA,IAAMG,YAAY,GAAG,SAAfA,YAAe,CAACC,OAAD,EAAUC,OAAV,EAAsB;AAAA,6CACLP,WADK;AAAA;;AAAA;AAAA;AAAA;AAAA,UAC9BE,QAD8B;AAAA,UACpBM,UADoB;;AAEzC;AACA,UAAMC,KAAK,GAAG,OAAOF,OAAP,KAAmB,UAAnB,GACb;AAAA,0CAAIG,IAAJ;AAAIA,UAAAA,IAAJ;AAAA;;AAAA,eAAaP,OAAO,CAACQ,KAAR,CAAcH,UAAU,CAACC,KAAzB,EAAgCF,OAAO,EAAvC,EAA2CG,IAA3C,CAAb;AAAA,OADa,GAEbF,UAAU,CAACC,KAAX,CAAiBG,IAAjB,CAAsBL,OAAtB,CAFD;AAIAJ,MAAAA,OAAO,CAACU,cAAR,CAAuBP,OAAvB,EAAgCJ,QAAhC,kCAA8CM,UAA9C;AAA0DC,QAAAA,KAAK,EAALA;AAA1D;AAPyC;;AAC1C,wDAAkD;AAAA;AAOjD;AARyC;AAAA;AAAA;AAAA;AAAA;;AAU1C,SAAOH,OAAP;AACA,CAXD,C,CAaA;;;AACA,IAAMQ,iBAAiB,GAAG,SAApBA,iBAAoB,CAAAR,OAAO,EAAI;AACpC,SAAO,IAAIS,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACvCX,IAAAA,OAAO,CAACY,EAAR,CAAW,MAAX,EAAmB,UAACC,QAAD,EAAWC,MAAX,EAAsB;AACxCJ,MAAAA,OAAO,CAAC;AAACG,QAAAA,QAAQ,EAARA,QAAD;AAAWC,QAAAA,MAAM,EAANA;AAAX,OAAD,CAAP;AACA,KAFD;AAIAd,IAAAA,OAAO,CAACY,EAAR,CAAW,OAAX,EAAoB,UAAAG,KAAK,EAAI;AAC5BJ,MAAAA,MAAM,CAACI,KAAD,CAAN;AACA,KAFD;;AAIA,QAAIf,OAAO,CAACgB,KAAZ,EAAmB;AAClBhB,MAAAA,OAAO,CAACgB,KAAR,CAAcJ,EAAd,CAAiB,OAAjB,EAA0B,UAAAG,KAAK,EAAI;AAClCJ,QAAAA,MAAM,CAACI,KAAD,CAAN;AACA,OAFD;AAGA;AACD,GAdM,CAAP;AAeA,CAhBD;;AAkBAE,MAAM,CAACC,OAAP,GAAiB;AAChBnB,EAAAA,YAAY,EAAZA,YADgB;AAEhBS,EAAAA,iBAAiB,EAAjBA;AAFgB,CAAjB","sourcesContent":["'use strict';\n\nconst nativePromisePrototype = (async () => {})().constructor.prototype;\nconst descriptors = ['then', 'catch', 'finally'].map(property => [\n\tproperty,\n\tReflect.getOwnPropertyDescriptor(nativePromisePrototype, property)\n]);\n\n// The return value is a mixin of `childProcess` and `Promise`\nconst mergePromise = (spawned, promise) => {\n\tfor (const [property, descriptor] of descriptors) {\n\t\t// Starting the main `promise` is deferred to avoid consuming streams\n\t\tconst value = typeof promise === 'function' ?\n\t\t\t(...args) => Reflect.apply(descriptor.value, promise(), args) :\n\t\t\tdescriptor.value.bind(promise);\n\n\t\tReflect.defineProperty(spawned, property, {...descriptor, value});\n\t}\n\n\treturn spawned;\n};\n\n// Use promises instead of `child_process` events\nconst getSpawnedPromise = spawned => {\n\treturn new Promise((resolve, reject) => {\n\t\tspawned.on('exit', (exitCode, signal) => {\n\t\t\tresolve({exitCode, signal});\n\t\t});\n\n\t\tspawned.on('error', error => {\n\t\t\treject(error);\n\t\t});\n\n\t\tif (spawned.stdin) {\n\t\t\tspawned.stdin.on('error', error => {\n\t\t\t\treject(error);\n\t\t\t});\n\t\t}\n\t});\n};\n\nmodule.exports = {\n\tmergePromise,\n\tgetSpawnedPromise\n};\n\n"]},"metadata":{},"sourceType":"script"}