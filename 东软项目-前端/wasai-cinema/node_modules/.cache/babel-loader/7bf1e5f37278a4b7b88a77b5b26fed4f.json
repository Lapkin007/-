{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _typeof = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/typeof.js\").default;\n\nvar _taggedTemplateLiteral = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\n\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4;\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.array.includes.js\");\n\nrequire(\"core-js/modules/es.string.includes.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar types_1 = require(\"../discriminator/types\");\n\nvar compile_1 = require(\"../../compile\");\n\nvar util_1 = require(\"../../compile/util\");\n\nvar error = {\n  message: function message(_ref) {\n    var _ref$params = _ref.params,\n        discrError = _ref$params.discrError,\n        tagName = _ref$params.tagName;\n    return discrError === types_1.DiscrError.Tag ? \"tag \\\"\".concat(tagName, \"\\\" must be string\") : \"value of tag \\\"\".concat(tagName, \"\\\" must be in oneOf\");\n  },\n  params: function params(_ref2) {\n    var _ref2$params = _ref2.params,\n        discrError = _ref2$params.discrError,\n        tag = _ref2$params.tag,\n        tagName = _ref2$params.tagName;\n    return (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"{error: \", \", tag: \", \", tagValue: \", \"}\"])), discrError, tagName, tag);\n  }\n};\nvar def = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error: error,\n  code: function code(cxt) {\n    var gen = cxt.gen,\n        data = cxt.data,\n        schema = cxt.schema,\n        parentSchema = cxt.parentSchema,\n        it = cxt.it;\n    var oneOf = parentSchema.oneOf;\n\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\");\n    }\n\n    var tagName = schema.propertyName;\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\");\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\");\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\");\n    var valid = gen.let(\"valid\", false);\n    var tag = gen.const(\"tag\", (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \"\", \"\"])), data, (0, codegen_1.getProperty)(tagName)));\n    gen.if((0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"typeof \", \" == \\\"string\\\"\"])), tag), function () {\n      return validateMapping();\n    }, function () {\n      return cxt.error(false, {\n        discrError: types_1.DiscrError.Tag,\n        tag: tag,\n        tagName: tagName\n      });\n    });\n    cxt.ok(valid);\n\n    function validateMapping() {\n      var mapping = getMapping();\n      gen.if(false);\n\n      for (var tagValue in mapping) {\n        gen.elseIf((0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \" === \", \"\"])), tag, tagValue));\n        gen.assign(valid, applyTagSchema(mapping[tagValue]));\n      }\n\n      gen.else();\n      cxt.error(false, {\n        discrError: types_1.DiscrError.Mapping,\n        tag: tag,\n        tagName: tagName\n      });\n      gen.endIf();\n    }\n\n    function applyTagSchema(schemaProp) {\n      var _valid = gen.name(\"valid\");\n\n      var schCxt = cxt.subschema({\n        keyword: \"oneOf\",\n        schemaProp: schemaProp\n      }, _valid);\n      cxt.mergeEvaluated(schCxt, codegen_1.Name);\n      return _valid;\n    }\n\n    function getMapping() {\n      var _a;\n\n      var oneOfMapping = {};\n      var topRequired = hasRequired(parentSchema);\n      var tagRequired = true;\n\n      for (var i = 0; i < oneOf.length; i++) {\n        var sch = oneOf[i];\n\n        if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n          sch = compile_1.resolveRef.call(it.self, it.schemaEnv, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);\n          if (sch instanceof compile_1.SchemaEnv) sch = sch.schema;\n        }\n\n        var propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n\n        if (_typeof(propSch) != \"object\") {\n          throw new Error(\"discriminator: oneOf subschemas (or referenced schemas) must have \\\"properties/\".concat(tagName, \"\\\"\"));\n        }\n\n        tagRequired = tagRequired && (topRequired || hasRequired(sch));\n        addMappings(propSch, i);\n      }\n\n      if (!tagRequired) throw new Error(\"discriminator: \\\"\".concat(tagName, \"\\\" must be required\"));\n      return oneOfMapping;\n\n      function hasRequired(_ref3) {\n        var required = _ref3.required;\n        return Array.isArray(required) && required.includes(tagName);\n      }\n\n      function addMappings(sch, i) {\n        if (sch.const) {\n          addMapping(sch.const, i);\n        } else if (sch.enum) {\n          var _iterator = _createForOfIteratorHelper(sch.enum),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var tagValue = _step.value;\n              addMapping(tagValue, i);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } else {\n          throw new Error(\"discriminator: \\\"properties/\".concat(tagName, \"\\\" must have \\\"const\\\" or \\\"enum\\\"\"));\n        }\n      }\n\n      function addMapping(tagValue, i) {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(\"discriminator: \\\"\".concat(tagName, \"\\\" values must be unique strings\"));\n        }\n\n        oneOfMapping[tagValue] = i;\n      }\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","params","discrError","tagName","types_1","Tag","tag","def","keyword","type","schemaType","code","cxt","gen","data","schema","parentSchema","it","oneOf","opts","discriminator","Error","propertyName","mapping","valid","let","const","if","validateMapping","ok","getMapping","tagValue","elseIf","assign","applyTagSchema","else","Mapping","endIf","schemaProp","_valid","name","schCxt","subschema","mergeEvaluated","codegen_1","oneOfMapping","topRequired","hasRequired","tagRequired","i","length","sch","$ref","self","RULES","compile_1","call","schemaEnv","baseId","propSch","properties","_a","addMappings","required","Array","isArray","includes","addMapping","enum","exports"],"sourceRoot":"","sources":["../../../lib/vocabularies/discriminator/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}