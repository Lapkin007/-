{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\n\nvar _templateObject, _templateObject2, _templateObject3;\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar util_1 = require(\"../../compile/util\");\n\nvar error = {\n  message: function message(_ref) {\n    var params = _ref.params;\n    return (0, codegen_1.str)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"must match \\\"\", \"\\\" schema\"])), params.ifClause);\n  },\n  params: function params(_ref2) {\n    var _params = _ref2.params;\n    return (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"{failingKeyword: \", \"}\"])), _params.ifClause);\n  }\n};\nvar def = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error: error,\n  code: function code(cxt) {\n    var gen = cxt.gen,\n        parentSchema = cxt.parentSchema,\n        it = cxt.it;\n\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n    }\n\n    var hasThen = hasSchema(it, \"then\");\n    var hasElse = hasSchema(it, \"else\");\n    if (!hasThen && !hasElse) return;\n    var valid = gen.let(\"valid\", true);\n    var schValid = gen.name(\"_valid\");\n    validateIf();\n    cxt.reset();\n\n    if (hasThen && hasElse) {\n      var ifClause = gen.let(\"ifClause\");\n      cxt.setParams({\n        ifClause: ifClause\n      });\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"));\n    } else {\n      gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n    }\n\n    cxt.pass(valid, function () {\n      return cxt.error(true);\n    });\n\n    function validateIf() {\n      var schCxt = cxt.subschema({\n        keyword: \"if\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false\n      }, schValid);\n      cxt.mergeEvaluated(schCxt);\n    }\n\n    function validateClause(keyword, ifClause) {\n      return function () {\n        var schCxt = cxt.subschema({\n          keyword: keyword\n        }, schValid);\n        gen.assign(valid, schValid);\n        cxt.mergeValidEvaluated(schCxt, valid);\n        if (ifClause) gen.assign(ifClause, (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \"\"])), keyword));else cxt.setParams({\n          ifClause: keyword\n        });\n      };\n    }\n  }\n};\n\nfunction hasSchema(it, keyword) {\n  var schema = it.schema[keyword];\n  return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\n\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","params","ifClause","def","keyword","schemaType","trackErrors","code","cxt","gen","parentSchema","it","then","undefined","else","hasThen","hasSchema","hasElse","valid","let","schValid","name","validateIf","reset","setParams","if","validateClause","pass","schCxt","subschema","compositeRule","createErrors","allErrors","mergeEvaluated","assign","mergeValidEvaluated","schema","exports"],"sourceRoot":"","sources":["../../../lib/vocabularies/applicator/if.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}