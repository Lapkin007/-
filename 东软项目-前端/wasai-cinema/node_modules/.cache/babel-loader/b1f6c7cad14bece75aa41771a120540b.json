{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _inherits = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _createClass = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _classCallCheck = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _typeof = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/typeof.js\").default;\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.regexp.test.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.array.join.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.array.sort.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n\nrequire(\"core-js/modules/es.map.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.string.ends-with.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nvar _require = require(\"./helpers/getFromStreamChunks\"),\n    getMap = _require.getMap,\n    getSourceAndMap = _require.getSourceAndMap;\n\nvar _streamChunks = require(\"./helpers/streamChunks\");\n\nvar Source = require(\"./Source\");\n\nvar splitIntoLines = require(\"./helpers/splitIntoLines\"); // since v8 7.0, Array.prototype.sort is stable\n\n\nvar hasStableSort = (typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) === \"object\" && process.versions && typeof process.versions.v8 === \"string\" && !/^[0-6]\\./.test(process.versions.v8); // This is larger than max string length\n\nvar MAX_SOURCE_POSITION = 0x20000000;\n\nvar Replacement = /*#__PURE__*/_createClass(function Replacement(start, end, content, name) {\n  _classCallCheck(this, Replacement);\n\n  this.start = start;\n  this.end = end;\n  this.content = content;\n  this.name = name;\n\n  if (!hasStableSort) {\n    this.index = -1;\n  }\n});\n\nvar ReplaceSource = /*#__PURE__*/function (_Source) {\n  _inherits(ReplaceSource, _Source);\n\n  var _super = _createSuper(ReplaceSource);\n\n  function ReplaceSource(source, name) {\n    var _this;\n\n    _classCallCheck(this, ReplaceSource);\n\n    _this = _super.call(this);\n    _this._source = source;\n    _this._name = name;\n    /** @type {Replacement[]} */\n\n    _this._replacements = [];\n    _this._isSorted = true;\n    return _this;\n  }\n\n  _createClass(ReplaceSource, [{\n    key: \"getName\",\n    value: function getName() {\n      return this._name;\n    }\n  }, {\n    key: \"getReplacements\",\n    value: function getReplacements() {\n      this._sortReplacements();\n\n      return this._replacements;\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(start, end, newValue, name) {\n      if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + _typeof(newValue));\n\n      this._replacements.push(new Replacement(start, end, newValue, name));\n\n      this._isSorted = false;\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(pos, newValue, name) {\n      if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + _typeof(newValue) + \": \" + newValue);\n\n      this._replacements.push(new Replacement(pos, pos - 1, newValue, name));\n\n      this._isSorted = false;\n    }\n  }, {\n    key: \"source\",\n    value: function source() {\n      if (this._replacements.length === 0) {\n        return this._source.source();\n      }\n\n      var current = this._source.source();\n\n      var pos = 0;\n      var result = [];\n\n      this._sortReplacements();\n\n      var _iterator = _createForOfIteratorHelper(this._replacements),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var replacement = _step.value;\n          var start = Math.floor(replacement.start);\n          var end = Math.floor(replacement.end + 1);\n\n          if (pos < start) {\n            var offset = start - pos;\n            result.push(current.slice(0, offset));\n            current = current.slice(offset);\n            pos = start;\n          }\n\n          result.push(replacement.content);\n\n          if (pos < end) {\n            var _offset = end - pos;\n\n            current = current.slice(_offset);\n            pos = end;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      result.push(current);\n      return result.join(\"\");\n    }\n  }, {\n    key: \"map\",\n    value: function map(options) {\n      if (this._replacements.length === 0) {\n        return this._source.map(options);\n      }\n\n      return getMap(this, options);\n    }\n  }, {\n    key: \"sourceAndMap\",\n    value: function sourceAndMap(options) {\n      if (this._replacements.length === 0) {\n        return this._source.sourceAndMap(options);\n      }\n\n      return getSourceAndMap(this, options);\n    }\n  }, {\n    key: \"original\",\n    value: function original() {\n      return this._source;\n    }\n  }, {\n    key: \"_sortReplacements\",\n    value: function _sortReplacements() {\n      if (this._isSorted) return;\n\n      if (hasStableSort) {\n        this._replacements.sort(function (a, b) {\n          var diff1 = a.start - b.start;\n          if (diff1 !== 0) return diff1;\n          var diff2 = a.end - b.end;\n          if (diff2 !== 0) return diff2;\n          return 0;\n        });\n      } else {\n        this._replacements.forEach(function (repl, i) {\n          return repl.index = i;\n        });\n\n        this._replacements.sort(function (a, b) {\n          var diff1 = a.start - b.start;\n          if (diff1 !== 0) return diff1;\n          var diff2 = a.end - b.end;\n          if (diff2 !== 0) return diff2;\n          return a.index - b.index;\n        });\n      }\n\n      this._isSorted = true;\n    }\n  }, {\n    key: \"streamChunks\",\n    value: function streamChunks(options, onChunk, onSource, onName) {\n      this._sortReplacements();\n\n      var repls = this._replacements;\n      var pos = 0;\n      var i = 0;\n      var replacmentEnd = -1;\n      var nextReplacement = i < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;\n      var generatedLineOffset = 0;\n      var generatedColumnOffset = 0;\n      var generatedColumnOffsetLine = 0;\n      var sourceContents = [];\n      var nameMapping = new Map();\n      var nameIndexMapping = [];\n\n      var checkOriginalContent = function checkOriginalContent(sourceIndex, line, column, expectedChunk) {\n        var content = sourceIndex < sourceContents.length ? sourceContents[sourceIndex] : undefined;\n        if (content === undefined) return false;\n\n        if (typeof content === \"string\") {\n          content = splitIntoLines(content);\n          sourceContents[sourceIndex] = content;\n        }\n\n        var contentLine = line <= content.length ? content[line - 1] : null;\n        if (contentLine === null) return false;\n        return contentLine.slice(column, column + expectedChunk.length) === expectedChunk;\n      };\n\n      var _streamChunks2 = _streamChunks(this._source, Object.assign({}, options, {\n        finalSource: false\n      }), function (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) {\n        var chunkPos = 0;\n        var endPos = pos + chunk.length; // Skip over when it has been replaced\n\n        // Skip over when it has been replaced\n        if (replacmentEnd > pos) {\n          // Skip over the whole chunk\n          if (replacmentEnd >= endPos) {\n            var _line2 = generatedLine + generatedLineOffset;\n\n            if (chunk.endsWith(\"\\n\")) {\n              generatedLineOffset--;\n\n              if (generatedColumnOffsetLine === _line2) {\n                // undo exiting corrections form the current line\n                generatedColumnOffset += generatedColumn;\n              }\n            } else if (generatedColumnOffsetLine === _line2) {\n              generatedColumnOffset -= chunk.length;\n            } else {\n              generatedColumnOffset = -chunk.length;\n              generatedColumnOffsetLine = _line2;\n            }\n\n            pos = endPos;\n            return;\n          } // Partially skip over chunk\n\n\n          // Partially skip over chunk\n          chunkPos = replacmentEnd - pos;\n\n          if (checkOriginalContent(sourceIndex, originalLine, originalColumn, chunk.slice(0, chunkPos))) {\n            originalColumn += chunkPos;\n          }\n\n          pos += chunkPos;\n\n          var _line = generatedLine + generatedLineOffset;\n\n          if (generatedColumnOffsetLine === _line) {\n            generatedColumnOffset -= chunkPos;\n          } else {\n            generatedColumnOffset = -chunkPos;\n            generatedColumnOffsetLine = _line;\n          }\n\n          generatedColumn += chunkPos;\n        } // Is a replacement in the chunk?\n\n\n        // Is a replacement in the chunk?\n        if (nextReplacement < endPos) {\n          do {\n            var _line3 = generatedLine + generatedLineOffset;\n\n            if (nextReplacement > pos) {\n              // Emit chunk until replacement\n              var _offset2 = nextReplacement - pos;\n\n              var chunkSlice = chunk.slice(chunkPos, chunkPos + _offset2);\n              onChunk(chunkSlice, _line3, generatedColumn + (_line3 === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, nameIndex < 0 || nameIndex >= nameIndexMapping.length ? -1 : nameIndexMapping[nameIndex]);\n              generatedColumn += _offset2;\n              chunkPos += _offset2;\n              pos = nextReplacement;\n\n              if (checkOriginalContent(sourceIndex, originalLine, originalColumn, chunkSlice)) {\n                originalColumn += chunkSlice.length;\n              }\n            } // Insert replacement content splitted into chunks by lines\n\n\n            // Insert replacement content splitted into chunks by lines\n            var _repls$i = repls[i],\n                content = _repls$i.content,\n                name = _repls$i.name;\n\n            var _matches = splitIntoLines(content);\n\n            var replacementNameIndex = nameIndex;\n\n            if (sourceIndex >= 0 && name) {\n              var globalIndex = nameMapping.get(name);\n\n              if (globalIndex === undefined) {\n                globalIndex = nameMapping.size;\n                nameMapping.set(name, globalIndex);\n                onName(globalIndex, name);\n              }\n\n              replacementNameIndex = globalIndex;\n            }\n\n            for (var m = 0; m < _matches.length; m++) {\n              var contentLine = _matches[m];\n              onChunk(contentLine, _line3, generatedColumn + (_line3 === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, replacementNameIndex); // Only the first chunk has name assigned\n\n              // Only the first chunk has name assigned\n              replacementNameIndex = -1;\n\n              if (m === _matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n                if (generatedColumnOffsetLine === _line3) {\n                  generatedColumnOffset += contentLine.length;\n                } else {\n                  generatedColumnOffset = contentLine.length;\n                  generatedColumnOffsetLine = _line3;\n                }\n              } else {\n                generatedLineOffset++;\n                _line3++;\n                generatedColumnOffset = -generatedColumn;\n                generatedColumnOffsetLine = _line3;\n              }\n            } // Remove replaced content by settings this variable\n\n\n            // Remove replaced content by settings this variable\n            replacmentEnd = Math.max(replacmentEnd, Math.floor(repls[i].end + 1)); // Move to next replacment\n\n            // Move to next replacment\n            i++;\n            nextReplacement = i < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION; // Skip over when it has been replaced\n\n            // Skip over when it has been replaced\n            var offset = chunk.length - endPos + replacmentEnd - chunkPos;\n\n            if (offset > 0) {\n              // Skip over whole chunk\n              if (replacmentEnd >= endPos) {\n                var _line5 = generatedLine + generatedLineOffset;\n\n                if (chunk.endsWith(\"\\n\")) {\n                  generatedLineOffset--;\n\n                  if (generatedColumnOffsetLine === _line5) {\n                    // undo exiting corrections form the current line\n                    generatedColumnOffset += generatedColumn;\n                  }\n                } else if (generatedColumnOffsetLine === _line5) {\n                  generatedColumnOffset -= chunk.length - chunkPos;\n                } else {\n                  generatedColumnOffset = chunkPos - chunk.length;\n                  generatedColumnOffsetLine = _line5;\n                }\n\n                pos = endPos;\n                return;\n              } // Partially skip over chunk\n\n\n              // Partially skip over chunk\n              var _line4 = generatedLine + generatedLineOffset;\n\n              if (checkOriginalContent(sourceIndex, originalLine, originalColumn, chunk.slice(chunkPos, chunkPos + offset))) {\n                originalColumn += offset;\n              }\n\n              chunkPos += offset;\n              pos += offset;\n\n              if (generatedColumnOffsetLine === _line4) {\n                generatedColumnOffset -= offset;\n              } else {\n                generatedColumnOffset = -offset;\n                generatedColumnOffsetLine = _line4;\n              }\n\n              generatedColumn += offset;\n            }\n          } while (nextReplacement < endPos);\n        } // Emit remaining chunk\n\n\n        // Emit remaining chunk\n        if (chunkPos < chunk.length) {\n          var _chunkSlice = chunkPos === 0 ? chunk : chunk.slice(chunkPos);\n\n          var _line6 = generatedLine + generatedLineOffset;\n\n          onChunk(_chunkSlice, _line6, generatedColumn + (_line6 === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, nameIndex < 0 ? -1 : nameIndexMapping[nameIndex]);\n        }\n\n        pos = endPos;\n      }, function (sourceIndex, source, sourceContent) {\n        while (sourceContents.length < sourceIndex) {\n          sourceContents.push(undefined);\n        }\n\n        sourceContents[sourceIndex] = sourceContent;\n        onSource(sourceIndex, source, sourceContent);\n      }, function (nameIndex, name) {\n        var globalIndex = nameMapping.get(name);\n\n        if (globalIndex === undefined) {\n          globalIndex = nameMapping.size;\n          nameMapping.set(name, globalIndex);\n          onName(globalIndex, name);\n        }\n\n        nameIndexMapping[nameIndex] = globalIndex;\n      }),\n          generatedLine = _streamChunks2.generatedLine,\n          generatedColumn = _streamChunks2.generatedColumn; // Handle remaining replacements\n\n\n      var remainer = \"\";\n\n      for (; i < repls.length; i++) {\n        remainer += repls[i].content;\n      } // Insert remaining replacements content splitted into chunks by lines\n\n\n      var line = generatedLine + generatedLineOffset;\n      var matches = splitIntoLines(remainer);\n\n      for (var m = 0; m < matches.length; m++) {\n        var contentLine = matches[m];\n        onChunk(contentLine, line, generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0), -1, -1, -1, -1);\n\n        if (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n          if (generatedColumnOffsetLine === line) {\n            generatedColumnOffset += contentLine.length;\n          } else {\n            generatedColumnOffset = contentLine.length;\n            generatedColumnOffsetLine = line;\n          }\n        } else {\n          generatedLineOffset++;\n          line++;\n          generatedColumnOffset = -generatedColumn;\n          generatedColumnOffsetLine = line;\n        }\n      }\n\n      return {\n        generatedLine: line,\n        generatedColumn: generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0)\n      };\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      this._sortReplacements();\n\n      hash.update(\"ReplaceSource\");\n\n      this._source.updateHash(hash);\n\n      hash.update(this._name || \"\");\n\n      var _iterator2 = _createForOfIteratorHelper(this._replacements),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var repl = _step2.value;\n          hash.update(\"\".concat(repl.start).concat(repl.end).concat(repl.content).concat(repl.name));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }]);\n\n  return ReplaceSource;\n}(Source);\n\nmodule.exports = ReplaceSource;","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/webpack-sources/lib/ReplaceSource.js"],"names":["require","getMap","getSourceAndMap","streamChunks","Source","splitIntoLines","hasStableSort","process","versions","v8","test","MAX_SOURCE_POSITION","Replacement","start","end","content","name","index","ReplaceSource","source","_source","_name","_replacements","_isSorted","_sortReplacements","newValue","Error","push","pos","length","current","result","replacement","Math","floor","offset","slice","join","options","map","sourceAndMap","sort","a","b","diff1","diff2","forEach","repl","i","onChunk","onSource","onName","repls","replacmentEnd","nextReplacement","generatedLineOffset","generatedColumnOffset","generatedColumnOffsetLine","sourceContents","nameMapping","Map","nameIndexMapping","checkOriginalContent","sourceIndex","line","column","expectedChunk","undefined","contentLine","Object","assign","finalSource","chunk","generatedLine","generatedColumn","originalLine","originalColumn","nameIndex","chunkPos","endPos","endsWith","chunkSlice","matches","replacementNameIndex","globalIndex","get","size","set","m","max","sourceContent","remainer","hash","update","updateHash","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst { getMap, getSourceAndMap } = require(\"./helpers/getFromStreamChunks\");\nconst streamChunks = require(\"./helpers/streamChunks\");\nconst Source = require(\"./Source\");\nconst splitIntoLines = require(\"./helpers/splitIntoLines\");\n\n// since v8 7.0, Array.prototype.sort is stable\nconst hasStableSort =\n\ttypeof process === \"object\" &&\n\tprocess.versions &&\n\ttypeof process.versions.v8 === \"string\" &&\n\t!/^[0-6]\\./.test(process.versions.v8);\n\n// This is larger than max string length\nconst MAX_SOURCE_POSITION = 0x20000000;\n\nclass Replacement {\n\tconstructor(start, end, content, name) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.content = content;\n\t\tthis.name = name;\n\t\tif (!hasStableSort) {\n\t\t\tthis.index = -1;\n\t\t}\n\t}\n}\n\nclass ReplaceSource extends Source {\n\tconstructor(source, name) {\n\t\tsuper();\n\t\tthis._source = source;\n\t\tthis._name = name;\n\t\t/** @type {Replacement[]} */\n\t\tthis._replacements = [];\n\t\tthis._isSorted = true;\n\t}\n\n\tgetName() {\n\t\treturn this._name;\n\t}\n\n\tgetReplacements() {\n\t\tthis._sortReplacements();\n\t\treturn this._replacements;\n\t}\n\n\treplace(start, end, newValue, name) {\n\t\tif (typeof newValue !== \"string\")\n\t\t\tthrow new Error(\n\t\t\t\t\"insertion must be a string, but is a \" + typeof newValue\n\t\t\t);\n\t\tthis._replacements.push(new Replacement(start, end, newValue, name));\n\t\tthis._isSorted = false;\n\t}\n\n\tinsert(pos, newValue, name) {\n\t\tif (typeof newValue !== \"string\")\n\t\t\tthrow new Error(\n\t\t\t\t\"insertion must be a string, but is a \" +\n\t\t\t\t\ttypeof newValue +\n\t\t\t\t\t\": \" +\n\t\t\t\t\tnewValue\n\t\t\t);\n\t\tthis._replacements.push(new Replacement(pos, pos - 1, newValue, name));\n\t\tthis._isSorted = false;\n\t}\n\n\tsource() {\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn this._source.source();\n\t\t}\n\t\tlet current = this._source.source();\n\t\tlet pos = 0;\n\t\tconst result = [];\n\n\t\tthis._sortReplacements();\n\t\tfor (const replacement of this._replacements) {\n\t\t\tconst start = Math.floor(replacement.start);\n\t\t\tconst end = Math.floor(replacement.end + 1);\n\t\t\tif (pos < start) {\n\t\t\t\tconst offset = start - pos;\n\t\t\t\tresult.push(current.slice(0, offset));\n\t\t\t\tcurrent = current.slice(offset);\n\t\t\t\tpos = start;\n\t\t\t}\n\t\t\tresult.push(replacement.content);\n\t\t\tif (pos < end) {\n\t\t\t\tconst offset = end - pos;\n\t\t\t\tcurrent = current.slice(offset);\n\t\t\t\tpos = end;\n\t\t\t}\n\t\t}\n\t\tresult.push(current);\n\t\treturn result.join(\"\");\n\t}\n\n\tmap(options) {\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn this._source.map(options);\n\t\t}\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn this._source.sourceAndMap(options);\n\t\t}\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\toriginal() {\n\t\treturn this._source;\n\t}\n\n\t_sortReplacements() {\n\t\tif (this._isSorted) return;\n\t\tif (hasStableSort) {\n\t\t\tthis._replacements.sort(function (a, b) {\n\t\t\t\tconst diff1 = a.start - b.start;\n\t\t\t\tif (diff1 !== 0) return diff1;\n\t\t\t\tconst diff2 = a.end - b.end;\n\t\t\t\tif (diff2 !== 0) return diff2;\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t} else {\n\t\t\tthis._replacements.forEach((repl, i) => (repl.index = i));\n\t\t\tthis._replacements.sort(function (a, b) {\n\t\t\t\tconst diff1 = a.start - b.start;\n\t\t\t\tif (diff1 !== 0) return diff1;\n\t\t\t\tconst diff2 = a.end - b.end;\n\t\t\t\tif (diff2 !== 0) return diff2;\n\t\t\t\treturn a.index - b.index;\n\t\t\t});\n\t\t}\n\t\tthis._isSorted = true;\n\t}\n\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tthis._sortReplacements();\n\t\tconst repls = this._replacements;\n\t\tlet pos = 0;\n\t\tlet i = 0;\n\t\tlet replacmentEnd = -1;\n\t\tlet nextReplacement =\n\t\t\ti < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;\n\t\tlet generatedLineOffset = 0;\n\t\tlet generatedColumnOffset = 0;\n\t\tlet generatedColumnOffsetLine = 0;\n\t\tconst sourceContents = [];\n\t\tconst nameMapping = new Map();\n\t\tconst nameIndexMapping = [];\n\t\tconst checkOriginalContent = (sourceIndex, line, column, expectedChunk) => {\n\t\t\tlet content =\n\t\t\t\tsourceIndex < sourceContents.length\n\t\t\t\t\t? sourceContents[sourceIndex]\n\t\t\t\t\t: undefined;\n\t\t\tif (content === undefined) return false;\n\t\t\tif (typeof content === \"string\") {\n\t\t\t\tcontent = splitIntoLines(content);\n\t\t\t\tsourceContents[sourceIndex] = content;\n\t\t\t}\n\t\t\tconst contentLine = line <= content.length ? content[line - 1] : null;\n\t\t\tif (contentLine === null) return false;\n\t\t\treturn (\n\t\t\t\tcontentLine.slice(column, column + expectedChunk.length) ===\n\t\t\t\texpectedChunk\n\t\t\t);\n\t\t};\n\t\tlet { generatedLine, generatedColumn } = streamChunks(\n\t\t\tthis._source,\n\t\t\tObject.assign({}, options, { finalSource: false }),\n\t\t\t(\n\t\t\t\tchunk,\n\t\t\t\tgeneratedLine,\n\t\t\t\tgeneratedColumn,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\tnameIndex\n\t\t\t) => {\n\t\t\t\tlet chunkPos = 0;\n\t\t\t\tlet endPos = pos + chunk.length;\n\n\t\t\t\t// Skip over when it has been replaced\n\t\t\t\tif (replacmentEnd > pos) {\n\t\t\t\t\t// Skip over the whole chunk\n\t\t\t\t\tif (replacmentEnd >= endPos) {\n\t\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\tif (chunk.endsWith(\"\\n\")) {\n\t\t\t\t\t\t\tgeneratedLineOffset--;\n\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t// undo exiting corrections form the current line\n\t\t\t\t\t\t\t\tgeneratedColumnOffset += generatedColumn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\tgeneratedColumnOffset -= chunk.length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgeneratedColumnOffset = -chunk.length;\n\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos = endPos;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Partially skip over chunk\n\t\t\t\t\tchunkPos = replacmentEnd - pos;\n\t\t\t\t\tif (\n\t\t\t\t\t\tcheckOriginalContent(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\tchunk.slice(0, chunkPos)\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\toriginalColumn += chunkPos;\n\t\t\t\t\t}\n\t\t\t\t\tpos += chunkPos;\n\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\tgeneratedColumnOffset -= chunkPos;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgeneratedColumnOffset = -chunkPos;\n\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t}\n\t\t\t\t\tgeneratedColumn += chunkPos;\n\t\t\t\t}\n\n\t\t\t\t// Is a replacement in the chunk?\n\t\t\t\tif (nextReplacement < endPos) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tlet line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\tif (nextReplacement > pos) {\n\t\t\t\t\t\t\t// Emit chunk until replacement\n\t\t\t\t\t\t\tconst offset = nextReplacement - pos;\n\t\t\t\t\t\t\tconst chunkSlice = chunk.slice(chunkPos, chunkPos + offset);\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tchunkSlice,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tgeneratedColumn +\n\t\t\t\t\t\t\t\t\t(line === generatedColumnOffsetLine\n\t\t\t\t\t\t\t\t\t\t? generatedColumnOffset\n\t\t\t\t\t\t\t\t\t\t: 0),\n\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\tnameIndex < 0 || nameIndex >= nameIndexMapping.length\n\t\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t\t: nameIndexMapping[nameIndex]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tgeneratedColumn += offset;\n\t\t\t\t\t\t\tchunkPos += offset;\n\t\t\t\t\t\t\tpos = nextReplacement;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcheckOriginalContent(\n\t\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\t\tchunkSlice\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\toriginalColumn += chunkSlice.length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Insert replacement content splitted into chunks by lines\n\t\t\t\t\t\tconst { content, name } = repls[i];\n\t\t\t\t\t\tlet matches = splitIntoLines(content);\n\t\t\t\t\t\tlet replacementNameIndex = nameIndex;\n\t\t\t\t\t\tif (sourceIndex >= 0 && name) {\n\t\t\t\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\t\tglobalIndex = nameMapping.size;\n\t\t\t\t\t\t\t\tnameMapping.set(name, globalIndex);\n\t\t\t\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treplacementNameIndex = globalIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let m = 0; m < matches.length; m++) {\n\t\t\t\t\t\t\tconst contentLine = matches[m];\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tcontentLine,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tgeneratedColumn +\n\t\t\t\t\t\t\t\t\t(line === generatedColumnOffsetLine\n\t\t\t\t\t\t\t\t\t\t? generatedColumnOffset\n\t\t\t\t\t\t\t\t\t\t: 0),\n\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\treplacementNameIndex\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Only the first chunk has name assigned\n\t\t\t\t\t\t\treplacementNameIndex = -1;\n\n\t\t\t\t\t\t\tif (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n\t\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset += contentLine.length;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset = contentLine.length;\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgeneratedLineOffset++;\n\t\t\t\t\t\t\t\tline++;\n\t\t\t\t\t\t\t\tgeneratedColumnOffset = -generatedColumn;\n\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remove replaced content by settings this variable\n\t\t\t\t\t\treplacmentEnd = Math.max(\n\t\t\t\t\t\t\treplacmentEnd,\n\t\t\t\t\t\t\tMath.floor(repls[i].end + 1)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Move to next replacment\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tnextReplacement =\n\t\t\t\t\t\t\ti < repls.length\n\t\t\t\t\t\t\t\t? Math.floor(repls[i].start)\n\t\t\t\t\t\t\t\t: MAX_SOURCE_POSITION;\n\n\t\t\t\t\t\t// Skip over when it has been replaced\n\t\t\t\t\t\tconst offset = chunk.length - endPos + replacmentEnd - chunkPos;\n\t\t\t\t\t\tif (offset > 0) {\n\t\t\t\t\t\t\t// Skip over whole chunk\n\t\t\t\t\t\t\tif (replacmentEnd >= endPos) {\n\t\t\t\t\t\t\t\tlet line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\t\t\tif (chunk.endsWith(\"\\n\")) {\n\t\t\t\t\t\t\t\t\tgeneratedLineOffset--;\n\t\t\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t\t\t// undo exiting corrections form the current line\n\t\t\t\t\t\t\t\t\t\tgeneratedColumnOffset += generatedColumn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset -= chunk.length - chunkPos;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset = chunkPos - chunk.length;\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpos = endPos;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Partially skip over chunk\n\t\t\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcheckOriginalContent(\n\t\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\t\tchunk.slice(chunkPos, chunkPos + offset)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\toriginalColumn += offset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchunkPos += offset;\n\t\t\t\t\t\t\tpos += offset;\n\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\tgeneratedColumnOffset -= offset;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgeneratedColumnOffset = -offset;\n\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgeneratedColumn += offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (nextReplacement < endPos);\n\t\t\t\t}\n\n\t\t\t\t// Emit remaining chunk\n\t\t\t\tif (chunkPos < chunk.length) {\n\t\t\t\t\tconst chunkSlice = chunkPos === 0 ? chunk : chunk.slice(chunkPos);\n\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\tonChunk(\n\t\t\t\t\t\tchunkSlice,\n\t\t\t\t\t\tline,\n\t\t\t\t\t\tgeneratedColumn +\n\t\t\t\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0),\n\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\tnameIndex < 0 ? -1 : nameIndexMapping[nameIndex]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tpos = endPos;\n\t\t\t},\n\t\t\t(sourceIndex, source, sourceContent) => {\n\t\t\t\twhile (sourceContents.length < sourceIndex)\n\t\t\t\t\tsourceContents.push(undefined);\n\t\t\t\tsourceContents[sourceIndex] = sourceContent;\n\t\t\t\tonSource(sourceIndex, source, sourceContent);\n\t\t\t},\n\t\t\t(nameIndex, name) => {\n\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\tglobalIndex = nameMapping.size;\n\t\t\t\t\tnameMapping.set(name, globalIndex);\n\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t}\n\t\t\t\tnameIndexMapping[nameIndex] = globalIndex;\n\t\t\t}\n\t\t);\n\n\t\t// Handle remaining replacements\n\t\tlet remainer = \"\";\n\t\tfor (; i < repls.length; i++) {\n\t\t\tremainer += repls[i].content;\n\t\t}\n\n\t\t// Insert remaining replacements content splitted into chunks by lines\n\t\tlet line = generatedLine + generatedLineOffset;\n\t\tlet matches = splitIntoLines(remainer);\n\t\tfor (let m = 0; m < matches.length; m++) {\n\t\t\tconst contentLine = matches[m];\n\t\t\tonChunk(\n\t\t\t\tcontentLine,\n\t\t\t\tline,\n\t\t\t\tgeneratedColumn +\n\t\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0),\n\t\t\t\t-1,\n\t\t\t\t-1,\n\t\t\t\t-1,\n\t\t\t\t-1\n\t\t\t);\n\n\t\t\tif (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\tgeneratedColumnOffset += contentLine.length;\n\t\t\t\t} else {\n\t\t\t\t\tgeneratedColumnOffset = contentLine.length;\n\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgeneratedLineOffset++;\n\t\t\t\tline++;\n\t\t\t\tgeneratedColumnOffset = -generatedColumn;\n\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tgeneratedLine: line,\n\t\t\tgeneratedColumn:\n\t\t\t\tgeneratedColumn +\n\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0)\n\t\t};\n\t}\n\n\tupdateHash(hash) {\n\t\tthis._sortReplacements();\n\t\thash.update(\"ReplaceSource\");\n\t\tthis._source.updateHash(hash);\n\t\thash.update(this._name || \"\");\n\t\tfor (const repl of this._replacements) {\n\t\t\thash.update(`${repl.start}${repl.end}${repl.content}${repl.name}`);\n\t\t}\n\t}\n}\n\nmodule.exports = ReplaceSource;\n"]},"metadata":{},"sourceType":"script"}