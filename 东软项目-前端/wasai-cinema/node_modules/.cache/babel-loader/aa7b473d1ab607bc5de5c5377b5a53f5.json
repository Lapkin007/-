{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _toConsumableArray = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.regexp.test.js\");\n\nrequire(\"core-js/modules/es.string.replace.js\");\n\nrequire(\"core-js/modules/es.array.join.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.string.split.js\");\n\nrequire(\"core-js/modules/es.string.trim.js\");\n\nrequire(\"core-js/modules/es.string.ends-with.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nvar normalizeArgs = function normalizeArgs(file) {\n  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  if (!Array.isArray(args)) {\n    return [file];\n  }\n\n  return [file].concat(_toConsumableArray(args));\n};\n\nvar NO_ESCAPE_REGEXP = /^[\\w.-]+$/;\nvar DOUBLE_QUOTES_REGEXP = /\"/g;\n\nvar escapeArg = function escapeArg(arg) {\n  if (typeof arg !== 'string' || NO_ESCAPE_REGEXP.test(arg)) {\n    return arg;\n  }\n\n  return \"\\\"\".concat(arg.replace(DOUBLE_QUOTES_REGEXP, '\\\\\"'), \"\\\"\");\n};\n\nvar joinCommand = function joinCommand(file, args) {\n  return normalizeArgs(file, args).join(' ');\n};\n\nvar getEscapedCommand = function getEscapedCommand(file, args) {\n  return normalizeArgs(file, args).map(function (arg) {\n    return escapeArg(arg);\n  }).join(' ');\n};\n\nvar SPACES_REGEXP = / +/g; // Handle `execa.command()`\n\nvar parseCommand = function parseCommand(command) {\n  var tokens = [];\n\n  var _iterator = _createForOfIteratorHelper(command.trim().split(SPACES_REGEXP)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var token = _step.value;\n      // Allow spaces to be escaped by a backslash if not meant as a delimiter\n      var previousToken = tokens[tokens.length - 1];\n\n      if (previousToken && previousToken.endsWith('\\\\')) {\n        // Merge previous token with current one\n        tokens[tokens.length - 1] = \"\".concat(previousToken.slice(0, -1), \" \").concat(token);\n      } else {\n        tokens.push(token);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return tokens;\n};\n\nmodule.exports = {\n  joinCommand: joinCommand,\n  getEscapedCommand: getEscapedCommand,\n  parseCommand: parseCommand\n};","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/default-gateway/node_modules/execa/lib/command.js"],"names":["normalizeArgs","file","args","Array","isArray","NO_ESCAPE_REGEXP","DOUBLE_QUOTES_REGEXP","escapeArg","arg","test","replace","joinCommand","join","getEscapedCommand","map","SPACES_REGEXP","parseCommand","command","tokens","trim","split","token","previousToken","length","endsWith","slice","push","module","exports"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,IAAMA,aAAa,GAAG,SAAhBA,aAAgB,CAACC,IAAD,EAAqB;AAAA,MAAdC,IAAc,uEAAP,EAAO;;AAC1C,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAL,EAA0B;AACzB,WAAO,CAACD,IAAD,CAAP;AACA;;AAED,UAAQA,IAAR,4BAAiBC,IAAjB;AACA,CAND;;AAQA,IAAMG,gBAAgB,GAAG,WAAzB;AACA,IAAMC,oBAAoB,GAAG,IAA7B;;AAEA,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAAAC,GAAG,EAAI;AACxB,MAAI,OAAOA,GAAP,KAAe,QAAf,IAA2BH,gBAAgB,CAACI,IAAjB,CAAsBD,GAAtB,CAA/B,EAA2D;AAC1D,WAAOA,GAAP;AACA;;AAED,qBAAWA,GAAG,CAACE,OAAJ,CAAYJ,oBAAZ,EAAkC,KAAlC,CAAX;AACA,CAND;;AAQA,IAAMK,WAAW,GAAG,SAAdA,WAAc,CAACV,IAAD,EAAOC,IAAP,EAAgB;AACnC,SAAOF,aAAa,CAACC,IAAD,EAAOC,IAAP,CAAb,CAA0BU,IAA1B,CAA+B,GAA/B,CAAP;AACA,CAFD;;AAIA,IAAMC,iBAAiB,GAAG,SAApBA,iBAAoB,CAACZ,IAAD,EAAOC,IAAP,EAAgB;AACzC,SAAOF,aAAa,CAACC,IAAD,EAAOC,IAAP,CAAb,CAA0BY,GAA1B,CAA8B,UAAAN,GAAG;AAAA,WAAID,SAAS,CAACC,GAAD,CAAb;AAAA,GAAjC,EAAqDI,IAArD,CAA0D,GAA1D,CAAP;AACA,CAFD;;AAIA,IAAMG,aAAa,GAAG,KAAtB,C,CAEA;;AACA,IAAMC,YAAY,GAAG,SAAfA,YAAe,CAAAC,OAAO,EAAI;AAC/B,MAAMC,MAAM,GAAG,EAAf;;AAD+B,6CAEXD,OAAO,CAACE,IAAR,GAAeC,KAAf,CAAqBL,aAArB,CAFW;AAAA;;AAAA;AAE/B,wDAAyD;AAAA,UAA9CM,KAA8C;AACxD;AACA,UAAMC,aAAa,GAAGJ,MAAM,CAACA,MAAM,CAACK,MAAP,GAAgB,CAAjB,CAA5B;;AACA,UAAID,aAAa,IAAIA,aAAa,CAACE,QAAd,CAAuB,IAAvB,CAArB,EAAmD;AAClD;AACAN,QAAAA,MAAM,CAACA,MAAM,CAACK,MAAP,GAAgB,CAAjB,CAAN,aAA+BD,aAAa,CAACG,KAAd,CAAoB,CAApB,EAAuB,CAAC,CAAxB,CAA/B,cAA6DJ,KAA7D;AACA,OAHD,MAGO;AACNH,QAAAA,MAAM,CAACQ,IAAP,CAAYL,KAAZ;AACA;AACD;AAX8B;AAAA;AAAA;AAAA;AAAA;;AAa/B,SAAOH,MAAP;AACA,CAdD;;AAgBAS,MAAM,CAACC,OAAP,GAAiB;AAChBjB,EAAAA,WAAW,EAAXA,WADgB;AAEhBE,EAAAA,iBAAiB,EAAjBA,iBAFgB;AAGhBG,EAAAA,YAAY,EAAZA;AAHgB,CAAjB","sourcesContent":["'use strict';\nconst normalizeArgs = (file, args = []) => {\n\tif (!Array.isArray(args)) {\n\t\treturn [file];\n\t}\n\n\treturn [file, ...args];\n};\n\nconst NO_ESCAPE_REGEXP = /^[\\w.-]+$/;\nconst DOUBLE_QUOTES_REGEXP = /\"/g;\n\nconst escapeArg = arg => {\n\tif (typeof arg !== 'string' || NO_ESCAPE_REGEXP.test(arg)) {\n\t\treturn arg;\n\t}\n\n\treturn `\"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\\\\"')}\"`;\n};\n\nconst joinCommand = (file, args) => {\n\treturn normalizeArgs(file, args).join(' ');\n};\n\nconst getEscapedCommand = (file, args) => {\n\treturn normalizeArgs(file, args).map(arg => escapeArg(arg)).join(' ');\n};\n\nconst SPACES_REGEXP = / +/g;\n\n// Handle `execa.command()`\nconst parseCommand = command => {\n\tconst tokens = [];\n\tfor (const token of command.trim().split(SPACES_REGEXP)) {\n\t\t// Allow spaces to be escaped by a backslash if not meant as a delimiter\n\t\tconst previousToken = tokens[tokens.length - 1];\n\t\tif (previousToken && previousToken.endsWith('\\\\')) {\n\t\t\t// Merge previous token with current one\n\t\t\ttokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;\n\t\t} else {\n\t\t\ttokens.push(token);\n\t\t}\n\t}\n\n\treturn tokens;\n};\n\nmodule.exports = {\n\tjoinCommand,\n\tgetEscapedCommand,\n\tparseCommand\n};\n"]},"metadata":{},"sourceType":"script"}