{"ast":null,"code":"/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls|https$\" }] */\n'use strict';\n\nvar _defineProperty = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\n\nvar _objectSpread = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _classCallCheck = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _assertThisInitialized = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\n\nvar _inherits = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.set.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.regexp.test.js\");\n\nrequire(\"core-js/modules/es.array.join.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.object.keys.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nvar EventEmitter = require('events');\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar net = require('net');\n\nvar tls = require('tls');\n\nvar _require = require('crypto'),\n    createHash = _require.createHash;\n\nvar extension = require('./extension');\n\nvar PerMessageDeflate = require('./permessage-deflate');\n\nvar subprotocol = require('./subprotocol');\n\nvar WebSocket = require('./websocket');\n\nvar _require2 = require('./constants'),\n    GUID = _require2.GUID,\n    kWebSocket = _require2.kWebSocket;\n\nvar keyRegex = /^[+/0-9A-Za-z]{22}==$/;\nvar RUNNING = 0;\nvar CLOSING = 1;\nvar CLOSED = 2;\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\n\nvar WebSocketServer = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(WebSocketServer, _EventEmitter);\n\n  var _super = _createSuper(WebSocketServer);\n\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  function WebSocketServer(options, callback) {\n    var _this;\n\n    _classCallCheck(this, WebSocketServer);\n\n    _this = _super.call(this);\n    options = _objectSpread({\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null,\n      // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket: WebSocket\n    }, options);\n\n    if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n      throw new TypeError('One and only one of the \"port\", \"server\", or \"noServer\" options ' + 'must be specified');\n    }\n\n    if (options.port != null) {\n      _this._server = http.createServer(function (req, res) {\n        var body = http.STATUS_CODES[426];\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n\n      _this._server.listen(options.port, options.host, options.backlog, callback);\n    } else if (options.server) {\n      _this._server = options.server;\n    }\n\n    if (_this._server) {\n      var emitConnection = _this.emit.bind(_assertThisInitialized(_this), 'connection');\n\n      _this._removeListeners = addListeners(_this._server, {\n        listening: _this.emit.bind(_assertThisInitialized(_this), 'listening'),\n        error: _this.emit.bind(_assertThisInitialized(_this), 'error'),\n        upgrade: function upgrade(req, socket, head) {\n          _this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n\n    if (options.clientTracking) {\n      _this.clients = new Set();\n      _this._shouldEmitClose = false;\n    }\n\n    _this.options = options;\n    _this._state = RUNNING;\n    return _this;\n  }\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n\n\n  _createClass(WebSocketServer, [{\n    key: \"address\",\n    value: function address() {\n      if (this.options.noServer) {\n        throw new Error('The server is operating in \"noServer\" mode');\n      }\n\n      if (!this._server) return null;\n      return this._server.address();\n    }\n    /**\n     * Stop the server from accepting new connections and emit the `'close'` event\n     * when all existing connections are closed.\n     *\n     * @param {Function} [cb] A one-time listener for the `'close'` event\n     * @public\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(cb) {\n      var _this2 = this;\n\n      if (this._state === CLOSED) {\n        if (cb) {\n          this.once('close', function () {\n            cb(new Error('The server is not running'));\n          });\n        }\n\n        process.nextTick(emitClose, this);\n        return;\n      }\n\n      if (cb) this.once('close', cb);\n      if (this._state === CLOSING) return;\n      this._state = CLOSING;\n\n      if (this.options.noServer || this.options.server) {\n        if (this._server) {\n          this._removeListeners();\n\n          this._removeListeners = this._server = null;\n        }\n\n        if (this.clients) {\n          if (!this.clients.size) {\n            process.nextTick(emitClose, this);\n          } else {\n            this._shouldEmitClose = true;\n          }\n        } else {\n          process.nextTick(emitClose, this);\n        }\n      } else {\n        var server = this._server;\n\n        this._removeListeners();\n\n        this._removeListeners = this._server = null; //\n        // The HTTP/S server was created internally. Close it, and rely on its\n        // `'close'` event.\n        //\n\n        server.close(function () {\n          emitClose(_this2);\n        });\n      }\n    }\n    /**\n     * See if a given request should be handled by this server instance.\n     *\n     * @param {http.IncomingMessage} req Request object to inspect\n     * @return {Boolean} `true` if the request is valid, else `false`\n     * @public\n     */\n\n  }, {\n    key: \"shouldHandle\",\n    value: function shouldHandle(req) {\n      if (this.options.path) {\n        var index = req.url.indexOf('?');\n        var pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n        if (pathname !== this.options.path) return false;\n      }\n\n      return true;\n    }\n    /**\n     * Handle a HTTP Upgrade request.\n     *\n     * @param {http.IncomingMessage} req The request object\n     * @param {(net.Socket|tls.Socket)} socket The network socket between the\n     *     server and client\n     * @param {Buffer} head The first packet of the upgraded stream\n     * @param {Function} cb Callback\n     * @public\n     */\n\n  }, {\n    key: \"handleUpgrade\",\n    value: function handleUpgrade(req, socket, head, cb) {\n      var _this3 = this;\n\n      socket.on('error', socketOnError);\n      var key = req.headers['sec-websocket-key'] !== undefined ? req.headers['sec-websocket-key'] : false;\n      var version = +req.headers['sec-websocket-version'];\n\n      if (req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket' || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {\n        return abortHandshake(socket, 400);\n      }\n\n      var secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n      var protocols = new Set();\n\n      if (secWebSocketProtocol !== undefined) {\n        try {\n          protocols = subprotocol.parse(secWebSocketProtocol);\n        } catch (err) {\n          return abortHandshake(socket, 400);\n        }\n      }\n\n      var secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n      var extensions = {};\n\n      if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {\n        var perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);\n\n        try {\n          var offers = extension.parse(secWebSocketExtensions);\n\n          if (offers[PerMessageDeflate.extensionName]) {\n            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n          }\n        } catch (err) {\n          return abortHandshake(socket, 400);\n        }\n      } //\n      // Optionally call external client verification handler.\n      //\n\n\n      if (this.options.verifyClient) {\n        var info = {\n          origin: req.headers[\"\".concat(version === 8 ? 'sec-websocket-origin' : 'origin')],\n          secure: !!(req.socket.authorized || req.socket.encrypted),\n          req: req\n        };\n\n        if (this.options.verifyClient.length === 2) {\n          this.options.verifyClient(info, function (verified, code, message, headers) {\n            if (!verified) {\n              return abortHandshake(socket, code || 401, message, headers);\n            }\n\n            _this3.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n          });\n          return;\n        }\n\n        if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n      }\n\n      this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n    }\n    /**\n     * Upgrade the connection to WebSocket.\n     *\n     * @param {Object} extensions The accepted extensions\n     * @param {String} key The value of the `Sec-WebSocket-Key` header\n     * @param {Set} protocols The subprotocols\n     * @param {http.IncomingMessage} req The request object\n     * @param {(net.Socket|tls.Socket)} socket The network socket between the\n     *     server and client\n     * @param {Buffer} head The first packet of the upgraded stream\n     * @param {Function} cb Callback\n     * @throws {Error} If called more than once with the same socket\n     * @private\n     */\n\n  }, {\n    key: \"completeUpgrade\",\n    value: function completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n      var _this4 = this;\n\n      //\n      // Destroy the socket if the client has already sent a FIN packet.\n      //\n      if (!socket.readable || !socket.writable) return socket.destroy();\n\n      if (socket[kWebSocket]) {\n        throw new Error('server.handleUpgrade() was called more than once with the same ' + 'socket, possibly due to a misconfiguration');\n      }\n\n      if (this._state > RUNNING) return abortHandshake(socket, 503);\n      var digest = createHash('sha1').update(key + GUID).digest('base64');\n      var headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', \"Sec-WebSocket-Accept: \".concat(digest)];\n      var ws = new this.options.WebSocket(null);\n\n      if (protocols.size) {\n        //\n        // Optionally call external protocol selection handler.\n        //\n        var protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\n\n        if (protocol) {\n          headers.push(\"Sec-WebSocket-Protocol: \".concat(protocol));\n          ws._protocol = protocol;\n        }\n      }\n\n      if (extensions[PerMessageDeflate.extensionName]) {\n        var params = extensions[PerMessageDeflate.extensionName].params;\n        var value = extension.format(_defineProperty({}, PerMessageDeflate.extensionName, [params]));\n        headers.push(\"Sec-WebSocket-Extensions: \".concat(value));\n        ws._extensions = extensions;\n      } //\n      // Allow external modification/inspection of handshake headers.\n      //\n\n\n      this.emit('headers', headers, req);\n      socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n      socket.removeListener('error', socketOnError);\n      ws.setSocket(socket, head, {\n        maxPayload: this.options.maxPayload,\n        skipUTF8Validation: this.options.skipUTF8Validation\n      });\n\n      if (this.clients) {\n        this.clients.add(ws);\n        ws.on('close', function () {\n          _this4.clients.delete(ws);\n\n          if (_this4._shouldEmitClose && !_this4.clients.size) {\n            process.nextTick(emitClose, _this4);\n          }\n        });\n      }\n\n      cb(ws, req);\n    }\n  }]);\n\n  return WebSocketServer;\n}(EventEmitter);\n\nmodule.exports = WebSocketServer;\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\n\nfunction addListeners(server, map) {\n  for (var _i = 0, _Object$keys = Object.keys(map); _i < _Object$keys.length; _i++) {\n    var event = _Object$keys[_i];\n    server.on(event, map[event]);\n  }\n\n  return function removeListeners() {\n    for (var _i2 = 0, _Object$keys2 = Object.keys(map); _i2 < _Object$keys2.length; _i2++) {\n      var _event = _Object$keys2[_i2];\n      server.removeListener(_event, map[_event]);\n    }\n  };\n}\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\n\n\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n/**\n * Handle premature socket errors.\n *\n * @private\n */\n\n\nfunction socketOnError() {\n  this.destroy();\n}\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\n\n\nfunction abortHandshake(socket, code, message, headers) {\n  if (socket.writable) {\n    message = message || http.STATUS_CODES[code];\n    headers = _objectSpread({\n      Connection: 'close',\n      'Content-Type': 'text/html',\n      'Content-Length': Buffer.byteLength(message)\n    }, headers);\n    socket.write(\"HTTP/1.1 \".concat(code, \" \").concat(http.STATUS_CODES[code], \"\\r\\n\") + Object.keys(headers).map(function (h) {\n      return \"\".concat(h, \": \").concat(headers[h]);\n    }).join('\\r\\n') + '\\r\\n\\r\\n' + message);\n  }\n\n  socket.removeListener('error', socketOnError);\n  socket.destroy();\n}","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/webpack-dev-server/node_modules/ws/lib/websocket-server.js"],"names":["EventEmitter","require","http","https","net","tls","createHash","extension","PerMessageDeflate","subprotocol","WebSocket","GUID","kWebSocket","keyRegex","RUNNING","CLOSING","CLOSED","WebSocketServer","options","callback","maxPayload","skipUTF8Validation","perMessageDeflate","handleProtocols","clientTracking","verifyClient","noServer","backlog","server","host","path","port","TypeError","_server","createServer","req","res","body","STATUS_CODES","writeHead","length","end","listen","emitConnection","emit","bind","_removeListeners","addListeners","listening","error","upgrade","socket","head","handleUpgrade","clients","Set","_shouldEmitClose","_state","Error","address","cb","once","process","nextTick","emitClose","size","close","index","url","indexOf","pathname","slice","on","socketOnError","key","headers","undefined","version","method","toLowerCase","test","shouldHandle","abortHandshake","secWebSocketProtocol","protocols","parse","err","secWebSocketExtensions","extensions","offers","extensionName","accept","info","origin","secure","authorized","encrypted","verified","code","message","completeUpgrade","readable","writable","destroy","digest","update","ws","protocol","values","next","value","push","_protocol","params","format","_extensions","write","concat","join","removeListener","setSocket","add","delete","module","exports","map","Object","keys","event","removeListeners","Connection","Buffer","byteLength","h"],"mappings":"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","sourcesContent":["/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls|https$\" }] */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst http = require('http');\nconst https = require('https');\nconst net = require('net');\nconst tls = require('tls');\nconst { createHash } = require('crypto');\n\nconst extension = require('./extension');\nconst PerMessageDeflate = require('./permessage-deflate');\nconst subprotocol = require('./subprotocol');\nconst WebSocket = require('./websocket');\nconst { GUID, kWebSocket } = require('./constants');\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket,\n      ...options\n    };\n\n    if (\n      (options.port == null && !options.server && !options.noServer) ||\n      (options.port != null && (options.server || options.noServer)) ||\n      (options.server && options.noServer)\n    ) {\n      throw new TypeError(\n        'One and only one of the \"port\", \"server\", or \"noServer\" options ' +\n          'must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n\n    this.options = options;\n    this._state = RUNNING;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n\n      process.nextTick(emitClose, this);\n      return;\n    }\n\n    if (cb) this.once('close', cb);\n\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key =\n      req.headers['sec-websocket-key'] !== undefined\n        ? req.headers['sec-websocket-key']\n        : false;\n    const version = +req.headers['sec-websocket-version'];\n\n    if (\n      req.method !== 'GET' ||\n      req.headers.upgrade.toLowerCase() !== 'websocket' ||\n      !key ||\n      !keyRegex.test(key) ||\n      (version !== 8 && version !== 13) ||\n      !this.shouldHandle(req)\n    ) {\n      return abortHandshake(socket, 400);\n    }\n\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        return abortHandshake(socket, 400);\n      }\n    }\n\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n\n    if (\n      this.options.perMessageDeflate &&\n      secWebSocketExtensions !== undefined\n    ) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        return abortHandshake(socket, 400);\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(\n            extensions,\n            key,\n            protocols,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    if (socket[kWebSocket]) {\n      throw new Error(\n        'server.handleUpgrade() was called more than once with the same ' +\n          'socket, possibly due to a misconfiguration'\n      );\n    }\n\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new this.options.WebSocket(null);\n\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols\n        ? this.options.handleProtocols(protocols, req)\n        : protocols.values().next().value;\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, {\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n\n    cb(ws, req);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n\n/**\n * Handle premature socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  if (socket.writable) {\n    message = message || http.STATUS_CODES[code];\n    headers = {\n      Connection: 'close',\n      'Content-Type': 'text/html',\n      'Content-Length': Buffer.byteLength(message),\n      ...headers\n    };\n\n    socket.write(\n      `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n        Object.keys(headers)\n          .map((h) => `${h}: ${headers[h]}`)\n          .join('\\r\\n') +\n        '\\r\\n\\r\\n' +\n        message\n    );\n  }\n\n  socket.removeListener('error', socketOnError);\n  socket.destroy();\n}\n"]},"metadata":{},"sourceType":"script"}