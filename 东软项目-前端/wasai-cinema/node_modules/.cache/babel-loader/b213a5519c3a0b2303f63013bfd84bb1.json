{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nrequire(\"core-js/modules/es.map.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar utils = require(\"../../utils\");\n\nvar EntryFilter = /*#__PURE__*/function () {\n  function EntryFilter(_settings, _micromatchOptions) {\n    _classCallCheck(this, EntryFilter);\n\n    this._settings = _settings;\n    this._micromatchOptions = _micromatchOptions;\n    this.index = new Map();\n  }\n\n  _createClass(EntryFilter, [{\n    key: \"getFilter\",\n    value: function getFilter(positive, negative) {\n      var _this = this;\n\n      var positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);\n      var negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);\n      return function (entry) {\n        return _this._filter(entry, positiveRe, negativeRe);\n      };\n    }\n  }, {\n    key: \"_filter\",\n    value: function _filter(entry, positiveRe, negativeRe) {\n      if (this._settings.unique && this._isDuplicateEntry(entry)) {\n        return false;\n      }\n\n      if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {\n        return false;\n      }\n\n      if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {\n        return false;\n      }\n\n      var filepath = this._settings.baseNameMatch ? entry.name : entry.path;\n      var isMatched = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);\n\n      if (this._settings.unique && isMatched) {\n        this._createIndexRecord(entry);\n      }\n\n      return isMatched;\n    }\n  }, {\n    key: \"_isDuplicateEntry\",\n    value: function _isDuplicateEntry(entry) {\n      return this.index.has(entry.path);\n    }\n  }, {\n    key: \"_createIndexRecord\",\n    value: function _createIndexRecord(entry) {\n      this.index.set(entry.path, undefined);\n    }\n  }, {\n    key: \"_onlyFileFilter\",\n    value: function _onlyFileFilter(entry) {\n      return this._settings.onlyFiles && !entry.dirent.isFile();\n    }\n  }, {\n    key: \"_onlyDirectoryFilter\",\n    value: function _onlyDirectoryFilter(entry) {\n      return this._settings.onlyDirectories && !entry.dirent.isDirectory();\n    }\n  }, {\n    key: \"_isSkippedByAbsoluteNegativePatterns\",\n    value: function _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {\n      if (!this._settings.absolute) {\n        return false;\n      }\n\n      var fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);\n      return utils.pattern.matchAny(fullpath, patternsRe);\n    }\n    /**\n     * First, just trying to apply patterns to the path.\n     * Second, trying to apply patterns to the path with final slash.\n     */\n\n  }, {\n    key: \"_isMatchToPatterns\",\n    value: function _isMatchToPatterns(entryPath, patternsRe) {\n      var filepath = utils.path.removeLeadingDotSegment(entryPath);\n      return utils.pattern.matchAny(filepath, patternsRe) || utils.pattern.matchAny(filepath + '/', patternsRe);\n    }\n  }]);\n\n  return EntryFilter;\n}();\n\nexports.default = EntryFilter;","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/fast-glob/out/providers/filters/entry.js"],"names":["Object","defineProperty","exports","value","utils","require","EntryFilter","_settings","_micromatchOptions","index","Map","positive","negative","positiveRe","pattern","convertPatternsToRe","negativeRe","entry","_filter","unique","_isDuplicateEntry","_onlyFileFilter","_onlyDirectoryFilter","_isSkippedByAbsoluteNegativePatterns","path","filepath","baseNameMatch","name","isMatched","_isMatchToPatterns","_createIndexRecord","has","set","undefined","onlyFiles","dirent","isFile","onlyDirectories","isDirectory","entryPath","patternsRe","absolute","fullpath","makeAbsolute","cwd","matchAny","removeLeadingDotSegment","default"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils = require(\"../../utils\");\nclass EntryFilter {\n    constructor(_settings, _micromatchOptions) {\n        this._settings = _settings;\n        this._micromatchOptions = _micromatchOptions;\n        this.index = new Map();\n    }\n    getFilter(positive, negative) {\n        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);\n        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);\n        return (entry) => this._filter(entry, positiveRe, negativeRe);\n    }\n    _filter(entry, positiveRe, negativeRe) {\n        if (this._settings.unique && this._isDuplicateEntry(entry)) {\n            return false;\n        }\n        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {\n            return false;\n        }\n        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {\n            return false;\n        }\n        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;\n        const isMatched = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);\n        if (this._settings.unique && isMatched) {\n            this._createIndexRecord(entry);\n        }\n        return isMatched;\n    }\n    _isDuplicateEntry(entry) {\n        return this.index.has(entry.path);\n    }\n    _createIndexRecord(entry) {\n        this.index.set(entry.path, undefined);\n    }\n    _onlyFileFilter(entry) {\n        return this._settings.onlyFiles && !entry.dirent.isFile();\n    }\n    _onlyDirectoryFilter(entry) {\n        return this._settings.onlyDirectories && !entry.dirent.isDirectory();\n    }\n    _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {\n        if (!this._settings.absolute) {\n            return false;\n        }\n        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);\n        return utils.pattern.matchAny(fullpath, patternsRe);\n    }\n    /**\n     * First, just trying to apply patterns to the path.\n     * Second, trying to apply patterns to the path with final slash.\n     */\n    _isMatchToPatterns(entryPath, patternsRe) {\n        const filepath = utils.path.removeLeadingDotSegment(entryPath);\n        return utils.pattern.matchAny(filepath, patternsRe) || utils.pattern.matchAny(filepath + '/', patternsRe);\n    }\n}\nexports.default = EntryFilter;\n"]},"metadata":{},"sourceType":"script"}