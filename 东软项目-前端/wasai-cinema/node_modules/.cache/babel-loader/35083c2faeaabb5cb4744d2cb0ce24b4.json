{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _asyncToGenerator = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nrequire(\"regenerator-runtime/runtime.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.array.includes.js\");\n\nrequire(\"core-js/modules/es.string.includes.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.regexp.test.js\");\n\nvar path = require(\"path\");\n\nvar mime = require(\"mime-types\");\n\nvar parseRange = require(\"range-parser\");\n\nvar getFilenameFromUrl = require(\"./utils/getFilenameFromUrl\");\n\nvar _require = require(\"./utils/compatibleAPI\"),\n    getHeaderNames = _require.getHeaderNames,\n    getHeaderFromRequest = _require.getHeaderFromRequest,\n    getHeaderFromResponse = _require.getHeaderFromResponse,\n    setHeaderForResponse = _require.setHeaderForResponse,\n    setStatusCode = _require.setStatusCode,\n    send = _require.send;\n\nvar ready = require(\"./utils/ready\");\n/** @typedef {import(\"./index.js\").NextFunction} NextFunction */\n\n/** @typedef {import(\"./index.js\").IncomingMessage} IncomingMessage */\n\n/** @typedef {import(\"./index.js\").ServerResponse} ServerResponse */\n\n/**\n * @param {string} type\n * @param {number} size\n * @param {import(\"range-parser\").Range} [range]\n * @returns {string}\n */\n\n\nfunction getValueContentRangeHeader(type, size, range) {\n  return \"\".concat(type, \" \").concat(range ? \"\".concat(range.start, \"-\").concat(range.end) : \"*\", \"/\").concat(size);\n}\n/**\n * @param {string | number} title\n * @param {string} body\n * @returns {string}\n */\n\n\nfunction createHtmlDocument(title, body) {\n  return \"\".concat(\"<!DOCTYPE html>\\n\" + '<html lang=\"en\">\\n' + \"<head>\\n\" + '<meta charset=\"utf-8\">\\n' + \"<title>\").concat(title, \"</title>\\n\") + \"</head>\\n\" + \"<body>\\n\" + \"<pre>\".concat(body, \"</pre>\\n\") + \"</body>\\n\" + \"</html>\\n\";\n}\n\nvar BYTES_RANGE_REGEXP = /^ *bytes/i;\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @param {import(\"./index.js\").Context<Request, Response>} context\n * @return {import(\"./index.js\").Middleware<Request, Response>}\n */\n\nfunction wrapper(context) {\n  return /*#__PURE__*/function () {\n    var _middleware = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(req, res, next) {\n      var acceptedMethods, goNext, _goNext, processRequest, _processRequest;\n\n      return regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _processRequest = function _processRequest3() {\n                _processRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n                  var filename, headers, allHeaders, name, contentType, rangeHeader, start, end, size, parsedRanges, message, existingHeaders, i, document, _byteLength, _parsedRanges, _parsedRanges$, isFsSupportsStream, bufferOtStream, byteLength, _bufferOtStream;\n\n                  return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          filename = getFilenameFromUrl(context,\n                          /** @type {string} */\n                          req.url);\n\n                          if (filename) {\n                            _context2.next = 5;\n                            break;\n                          }\n\n                          _context2.next = 4;\n                          return goNext();\n\n                        case 4:\n                          return _context2.abrupt(\"return\");\n\n                        case 5:\n                          headers = context.options.headers;\n\n                          if (typeof headers === \"function\") {\n                            // @ts-ignore\n                            headers = headers(req, res, context);\n                          }\n                          /**\n                           * @type {{key: string, value: string | number}[]}\n                           */\n\n\n                          allHeaders = [];\n\n                          if (typeof headers !== \"undefined\") {\n                            if (!Array.isArray(headers)) {\n                              // eslint-disable-next-line guard-for-in\n                              for (name in headers) {\n                                // @ts-ignore\n                                allHeaders.push({\n                                  key: name,\n                                  value: headers[name]\n                                });\n                              }\n\n                              headers = allHeaders;\n                            }\n\n                            headers.forEach(\n                            /**\n                             * @param {{key: string, value: any}} header\n                             */\n                            function (header) {\n                              setHeaderForResponse(res, header.key, header.value);\n                            });\n                          }\n\n                          if (!getHeaderFromResponse(res, \"Content-Type\")) {\n                            // content-type name(like application/javascript; charset=utf-8) or false\n                            contentType = mime.contentType(path.extname(filename)); // Only set content-type header if media type is known\n                            // https://tools.ietf.org/html/rfc7231#section-3.1.1.5\n\n                            if (contentType) {\n                              setHeaderForResponse(res, \"Content-Type\", contentType);\n                            }\n                          }\n\n                          if (!getHeaderFromResponse(res, \"Accept-Ranges\")) {\n                            setHeaderForResponse(res, \"Accept-Ranges\", \"bytes\");\n                          }\n\n                          rangeHeader = getHeaderFromRequest(req, \"range\");\n\n                          if (!(rangeHeader && BYTES_RANGE_REGEXP.test(rangeHeader))) {\n                            _context2.next = 34;\n                            break;\n                          }\n\n                          _context2.next = 15;\n                          return new Promise(function (resolve) {\n                            /** @type {import(\"fs\").lstat} */\n                            context.outputFileSystem.lstat(filename, function (error, stats) {\n                              if (error) {\n                                context.logger.error(error);\n                                return;\n                              }\n\n                              resolve(stats.size);\n                            });\n                          });\n\n                        case 15:\n                          size = _context2.sent;\n                          parsedRanges = parseRange(size, rangeHeader, {\n                            combine: true\n                          });\n\n                          if (!(parsedRanges === -1)) {\n                            _context2.next = 32;\n                            break;\n                          }\n\n                          message = \"Unsatisfiable range for 'Range' header.\";\n                          context.logger.error(message);\n                          existingHeaders = getHeaderNames(res);\n\n                          for (i = 0; i < existingHeaders.length; i++) {\n                            res.removeHeader(existingHeaders[i]);\n                          }\n\n                          setStatusCode(res, 416);\n                          setHeaderForResponse(res, \"Content-Range\", getValueContentRangeHeader(\"bytes\", size));\n                          setHeaderForResponse(res, \"Content-Type\", \"text/html; charset=utf-8\");\n                          document = createHtmlDocument(416, \"Error: \".concat(message));\n                          _byteLength = Buffer.byteLength(document);\n                          setHeaderForResponse(res, \"Content-Length\", Buffer.byteLength(document));\n                          send(req, res, document, _byteLength);\n                          return _context2.abrupt(\"return\");\n\n                        case 32:\n                          if (parsedRanges === -2) {\n                            context.logger.error(\"A malformed 'Range' header was provided. A regular response will be sent for this request.\");\n                          } else if (parsedRanges.length > 1) {\n                            context.logger.error(\"A 'Range' header with multiple ranges was provided. Multiple ranges are not supported, so a regular response will be sent for this request.\");\n                          }\n\n                        case 33:\n                          if (parsedRanges !== -2 && parsedRanges.length === 1) {\n                            // Content-Range\n                            setStatusCode(res, 206);\n                            setHeaderForResponse(res, \"Content-Range\", getValueContentRangeHeader(\"bytes\", size,\n                            /** @type {import(\"range-parser\").Ranges} */\n                            parsedRanges[0]));\n                            _parsedRanges = _slicedToArray(parsedRanges, 1);\n                            _parsedRanges$ = _parsedRanges[0];\n                            start = _parsedRanges$.start;\n                            end = _parsedRanges$.end;\n                          }\n\n                        case 34:\n                          isFsSupportsStream = typeof context.outputFileSystem.createReadStream === \"function\";\n                          _context2.prev = 35;\n\n                          if (typeof start !== \"undefined\" && typeof end !== \"undefined\" && isFsSupportsStream) {\n                            bufferOtStream =\n                            /** @type {import(\"fs\").createReadStream} */\n                            context.outputFileSystem.createReadStream(filename, {\n                              start: start,\n                              end: end\n                            });\n                            byteLength = end - start + 1;\n                          } else {\n                            bufferOtStream =\n                            /** @type {import(\"fs\").readFileSync} */\n                            context.outputFileSystem.readFileSync(filename);\n                            _bufferOtStream = bufferOtStream;\n                            byteLength = _bufferOtStream.byteLength;\n                          }\n\n                          _context2.next = 44;\n                          break;\n\n                        case 39:\n                          _context2.prev = 39;\n                          _context2.t0 = _context2[\"catch\"](35);\n                          _context2.next = 43;\n                          return goNext();\n\n                        case 43:\n                          return _context2.abrupt(\"return\");\n\n                        case 44:\n                          send(req, res, bufferOtStream, byteLength);\n\n                        case 45:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _callee2, null, [[35, 39]]);\n                }));\n                return _processRequest.apply(this, arguments);\n              };\n\n              processRequest = function _processRequest2() {\n                return _processRequest.apply(this, arguments);\n              };\n\n              _goNext = function _goNext3() {\n                _goNext = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n                  return regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          if (context.options.serverSideRender) {\n                            _context.next = 2;\n                            break;\n                          }\n\n                          return _context.abrupt(\"return\", next());\n\n                        case 2:\n                          return _context.abrupt(\"return\", new Promise(function (resolve) {\n                            ready(context, function () {\n                              /** @type {any} */\n                              // eslint-disable-next-line no-param-reassign\n                              res.locals.webpack = {\n                                devMiddleware: context\n                              };\n                              resolve(next());\n                            }, req);\n                          }));\n\n                        case 3:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                }));\n                return _goNext.apply(this, arguments);\n              };\n\n              goNext = function _goNext2() {\n                return _goNext.apply(this, arguments);\n              };\n\n              acceptedMethods = context.options.methods || [\"GET\", \"HEAD\"]; // fixes #282. credit @cexoso. in certain edge situations res.locals is undefined.\n              // eslint-disable-next-line no-param-reassign\n\n              res.locals = res.locals || {};\n\n              if (!(req.method && !acceptedMethods.includes(req.method))) {\n                _context3.next = 10;\n                break;\n              }\n\n              _context3.next = 9;\n              return goNext();\n\n            case 9:\n              return _context3.abrupt(\"return\");\n\n            case 10:\n              ready(context, processRequest, req);\n\n            case 11:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    function middleware(_x, _x2, _x3) {\n      return _middleware.apply(this, arguments);\n    }\n\n    return middleware;\n  }();\n}\n\nmodule.exports = wrapper;","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/webpack-dev-middleware/dist/middleware.js"],"names":["path","require","mime","parseRange","getFilenameFromUrl","getHeaderNames","getHeaderFromRequest","getHeaderFromResponse","setHeaderForResponse","setStatusCode","send","ready","getValueContentRangeHeader","type","size","range","start","end","createHtmlDocument","title","body","BYTES_RANGE_REGEXP","wrapper","context","req","res","next","goNext","processRequest","filename","url","headers","options","allHeaders","Array","isArray","name","push","key","value","forEach","header","contentType","extname","rangeHeader","test","Promise","resolve","outputFileSystem","lstat","error","stats","logger","parsedRanges","combine","message","existingHeaders","i","length","removeHeader","document","byteLength","Buffer","isFsSupportsStream","createReadStream","bufferOtStream","readFileSync","serverSideRender","locals","webpack","devMiddleware","acceptedMethods","methods","method","includes","middleware","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst path = require(\"path\");\n\nconst mime = require(\"mime-types\");\n\nconst parseRange = require(\"range-parser\");\n\nconst getFilenameFromUrl = require(\"./utils/getFilenameFromUrl\");\n\nconst {\n  getHeaderNames,\n  getHeaderFromRequest,\n  getHeaderFromResponse,\n  setHeaderForResponse,\n  setStatusCode,\n  send\n} = require(\"./utils/compatibleAPI\");\n\nconst ready = require(\"./utils/ready\");\n/** @typedef {import(\"./index.js\").NextFunction} NextFunction */\n\n/** @typedef {import(\"./index.js\").IncomingMessage} IncomingMessage */\n\n/** @typedef {import(\"./index.js\").ServerResponse} ServerResponse */\n\n/**\n * @param {string} type\n * @param {number} size\n * @param {import(\"range-parser\").Range} [range]\n * @returns {string}\n */\n\n\nfunction getValueContentRangeHeader(type, size, range) {\n  return `${type} ${range ? `${range.start}-${range.end}` : \"*\"}/${size}`;\n}\n/**\n * @param {string | number} title\n * @param {string} body\n * @returns {string}\n */\n\n\nfunction createHtmlDocument(title, body) {\n  return `${\"<!DOCTYPE html>\\n\" + '<html lang=\"en\">\\n' + \"<head>\\n\" + '<meta charset=\"utf-8\">\\n' + \"<title>\"}${title}</title>\\n` + `</head>\\n` + `<body>\\n` + `<pre>${body}</pre>\\n` + `</body>\\n` + `</html>\\n`;\n}\n\nconst BYTES_RANGE_REGEXP = /^ *bytes/i;\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @param {import(\"./index.js\").Context<Request, Response>} context\n * @return {import(\"./index.js\").Middleware<Request, Response>}\n */\n\nfunction wrapper(context) {\n  return async function middleware(req, res, next) {\n    const acceptedMethods = context.options.methods || [\"GET\", \"HEAD\"]; // fixes #282. credit @cexoso. in certain edge situations res.locals is undefined.\n    // eslint-disable-next-line no-param-reassign\n\n    res.locals = res.locals || {};\n\n    if (req.method && !acceptedMethods.includes(req.method)) {\n      await goNext();\n      return;\n    }\n\n    ready(context, processRequest, req);\n\n    async function goNext() {\n      if (!context.options.serverSideRender) {\n        return next();\n      }\n\n      return new Promise(resolve => {\n        ready(context, () => {\n          /** @type {any} */\n          // eslint-disable-next-line no-param-reassign\n          res.locals.webpack = {\n            devMiddleware: context\n          };\n          resolve(next());\n        }, req);\n      });\n    }\n\n    async function processRequest() {\n      const filename = getFilenameFromUrl(context,\n      /** @type {string} */\n      req.url);\n\n      if (!filename) {\n        await goNext();\n        return;\n      }\n\n      let {\n        headers\n      } = context.options;\n\n      if (typeof headers === \"function\") {\n        // @ts-ignore\n        headers = headers(req, res, context);\n      }\n      /**\n       * @type {{key: string, value: string | number}[]}\n       */\n\n\n      const allHeaders = [];\n\n      if (typeof headers !== \"undefined\") {\n        if (!Array.isArray(headers)) {\n          // eslint-disable-next-line guard-for-in\n          for (const name in headers) {\n            // @ts-ignore\n            allHeaders.push({\n              key: name,\n              value: headers[name]\n            });\n          }\n\n          headers = allHeaders;\n        }\n\n        headers.forEach(\n        /**\n         * @param {{key: string, value: any}} header\n         */\n        header => {\n          setHeaderForResponse(res, header.key, header.value);\n        });\n      }\n\n      if (!getHeaderFromResponse(res, \"Content-Type\")) {\n        // content-type name(like application/javascript; charset=utf-8) or false\n        const contentType = mime.contentType(path.extname(filename)); // Only set content-type header if media type is known\n        // https://tools.ietf.org/html/rfc7231#section-3.1.1.5\n\n        if (contentType) {\n          setHeaderForResponse(res, \"Content-Type\", contentType);\n        }\n      }\n\n      if (!getHeaderFromResponse(res, \"Accept-Ranges\")) {\n        setHeaderForResponse(res, \"Accept-Ranges\", \"bytes\");\n      }\n\n      const rangeHeader = getHeaderFromRequest(req, \"range\");\n      let start;\n      let end;\n\n      if (rangeHeader && BYTES_RANGE_REGEXP.test(rangeHeader)) {\n        const size = await new Promise(resolve => {\n          /** @type {import(\"fs\").lstat} */\n          context.outputFileSystem.lstat(filename, (error, stats) => {\n            if (error) {\n              context.logger.error(error);\n              return;\n            }\n\n            resolve(stats.size);\n          });\n        });\n        const parsedRanges = parseRange(size, rangeHeader, {\n          combine: true\n        });\n\n        if (parsedRanges === -1) {\n          const message = \"Unsatisfiable range for 'Range' header.\";\n          context.logger.error(message);\n          const existingHeaders = getHeaderNames(res);\n\n          for (let i = 0; i < existingHeaders.length; i++) {\n            res.removeHeader(existingHeaders[i]);\n          }\n\n          setStatusCode(res, 416);\n          setHeaderForResponse(res, \"Content-Range\", getValueContentRangeHeader(\"bytes\", size));\n          setHeaderForResponse(res, \"Content-Type\", \"text/html; charset=utf-8\");\n          const document = createHtmlDocument(416, `Error: ${message}`);\n          const byteLength = Buffer.byteLength(document);\n          setHeaderForResponse(res, \"Content-Length\", Buffer.byteLength(document));\n          send(req, res, document, byteLength);\n          return;\n        } else if (parsedRanges === -2) {\n          context.logger.error(\"A malformed 'Range' header was provided. A regular response will be sent for this request.\");\n        } else if (parsedRanges.length > 1) {\n          context.logger.error(\"A 'Range' header with multiple ranges was provided. Multiple ranges are not supported, so a regular response will be sent for this request.\");\n        }\n\n        if (parsedRanges !== -2 && parsedRanges.length === 1) {\n          // Content-Range\n          setStatusCode(res, 206);\n          setHeaderForResponse(res, \"Content-Range\", getValueContentRangeHeader(\"bytes\", size,\n          /** @type {import(\"range-parser\").Ranges} */\n          parsedRanges[0]));\n          [{\n            start,\n            end\n          }] = parsedRanges;\n        }\n      }\n\n      const isFsSupportsStream = typeof context.outputFileSystem.createReadStream === \"function\";\n      let bufferOtStream;\n      let byteLength;\n\n      try {\n        if (typeof start !== \"undefined\" && typeof end !== \"undefined\" && isFsSupportsStream) {\n          bufferOtStream =\n          /** @type {import(\"fs\").createReadStream} */\n          context.outputFileSystem.createReadStream(filename, {\n            start,\n            end\n          });\n          byteLength = end - start + 1;\n        } else {\n          bufferOtStream =\n          /** @type {import(\"fs\").readFileSync} */\n          context.outputFileSystem.readFileSync(filename);\n          ({\n            byteLength\n          } = bufferOtStream);\n        }\n      } catch (_ignoreError) {\n        await goNext();\n        return;\n      }\n\n      send(req, res, bufferOtStream, byteLength);\n    }\n  };\n}\n\nmodule.exports = wrapper;"]},"metadata":{},"sourceType":"script"}