{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nvar _require = require(\"schema-utils\"),\n    validate = _require.validate;\n\nvar mime = require(\"mime-types\");\n\nvar middleware = require(\"./middleware\");\n\nvar getFilenameFromUrl = require(\"./utils/getFilenameFromUrl\");\n\nvar setupHooks = require(\"./utils/setupHooks\");\n\nvar setupWriteToDisk = require(\"./utils/setupWriteToDisk\");\n\nvar setupOutputFileSystem = require(\"./utils/setupOutputFileSystem\");\n\nvar ready = require(\"./utils/ready\");\n\nvar schema = require(\"./options.json\");\n\nvar noop = function noop() {};\n/** @typedef {import(\"schema-utils/declarations/validate\").Schema} Schema */\n\n/** @typedef {import(\"webpack\").Compiler} Compiler */\n\n/** @typedef {import(\"webpack\").MultiCompiler} MultiCompiler */\n\n/** @typedef {import(\"webpack\").Configuration} Configuration */\n\n/** @typedef {import(\"webpack\").Stats} Stats */\n\n/** @typedef {import(\"webpack\").MultiStats} MultiStats */\n\n/**\n * @typedef {Object} ExtendedServerResponse\n * @property {{ webpack?: { devMiddleware?: Context<IncomingMessage, ServerResponse> } }} [locals]\n */\n\n/** @typedef {import(\"http\").IncomingMessage} IncomingMessage */\n\n/** @typedef {import(\"http\").ServerResponse & ExtendedServerResponse} ServerResponse */\n\n/**\n * @callback NextFunction\n * @param {any} [err]\n * @return {void}\n */\n\n/**\n * @typedef {NonNullable<Configuration[\"watchOptions\"]>} WatchOptions\n */\n\n/**\n * @typedef {Compiler[\"watching\"]} Watching\n */\n\n/**\n * @typedef {ReturnType<Compiler[\"watch\"]>} MultiWatching\n */\n\n/**\n * @typedef {Compiler[\"outputFileSystem\"] & { createReadStream?: import(\"fs\").createReadStream, statSync?: import(\"fs\").statSync, lstat?: import(\"fs\").lstat, readFileSync?: import(\"fs\").readFileSync }} OutputFileSystem\n */\n\n/** @typedef {ReturnType<Compiler[\"getInfrastructureLogger\"]>} Logger */\n\n/**\n * @callback Callback\n * @param {Stats | MultiStats} [stats]\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Object} Context\n * @property {boolean} state\n * @property {Stats | MultiStats | undefined} stats\n * @property {Callback[]} callbacks\n * @property {Options<Request, Response>} options\n * @property {Compiler | MultiCompiler} compiler\n * @property {Watching | MultiWatching} watching\n * @property {Logger} logger\n * @property {OutputFileSystem} outputFileSystem\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Record<string, string | number> | Array<{ key: string, value: number | string }> | ((req: Request, res: Response, context: Context<Request, Response>) =>  void | undefined | Record<string, string | number>) | undefined} Headers\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Object} Options\n * @property {{[key: string]: string}} [mimeTypes]\n * @property {boolean | ((targetPath: string) => boolean)} [writeToDisk]\n * @property {string} [methods]\n * @property {Headers<Request, Response>} [headers]\n * @property {NonNullable<Configuration[\"output\"]>[\"publicPath\"]} [publicPath]\n * @property {Configuration[\"stats\"]} [stats]\n * @property {boolean} [serverSideRender]\n * @property {OutputFileSystem} [outputFileSystem]\n * @property {boolean | string} [index]\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @callback Middleware\n * @param {Request} req\n * @param {Response} res\n * @param {NextFunction} next\n * @return {Promise<void>}\n */\n\n/**\n * @callback GetFilenameFromUrl\n * @param {string} url\n * @returns {string | undefined}\n */\n\n/**\n * @callback WaitUntilValid\n * @param {Callback} callback\n */\n\n/**\n * @callback Invalidate\n * @param {Callback} callback\n */\n\n/**\n * @callback Close\n * @param {(err: Error | null | undefined) => void} callback\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Object} AdditionalMethods\n * @property {GetFilenameFromUrl} getFilenameFromUrl\n * @property {WaitUntilValid} waitUntilValid\n * @property {Invalidate} invalidate\n * @property {Close} close\n * @property {Context<Request, Response>} context\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Middleware<Request, Response> & AdditionalMethods<Request, Response>} API\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @param {Compiler | MultiCompiler} compiler\n * @param {Options<Request, Response>} [options]\n * @returns {API<Request, Response>}\n */\n\n\nfunction wdm(compiler) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  validate(\n  /** @type {Schema} */\n  schema, options, {\n    name: \"Dev Middleware\",\n    baseDataPath: \"options\"\n  });\n  var mimeTypes = options.mimeTypes;\n\n  if (mimeTypes) {\n    var types = mime.types; // mimeTypes from user provided options should take priority\n    // over existing, known types\n    // @ts-ignore\n\n    mime.types = _objectSpread(_objectSpread({}, types), mimeTypes);\n  }\n  /**\n   * @type {Context<Request, Response>}\n   */\n\n\n  var context = {\n    state: false,\n    // eslint-disable-next-line no-undefined\n    stats: undefined,\n    callbacks: [],\n    options: options,\n    compiler: compiler,\n    // @ts-ignore\n    // eslint-disable-next-line no-undefined\n    watching: undefined,\n    logger: compiler.getInfrastructureLogger(\"webpack-dev-middleware\"),\n    // @ts-ignore\n    // eslint-disable-next-line no-undefined\n    outputFileSystem: undefined\n  };\n  setupHooks(context);\n\n  if (options.writeToDisk) {\n    setupWriteToDisk(context);\n  }\n\n  setupOutputFileSystem(context); // Start watching\n\n  if (\n  /** @type {Compiler} */\n  context.compiler.watching) {\n    context.watching =\n    /** @type {Compiler} */\n    context.compiler.watching;\n  } else {\n    /**\n     * @type {WatchOptions | WatchOptions[]}\n     */\n    var watchOptions;\n    /**\n     * @param {Error | null | undefined} error\n     */\n\n    var errorHandler = function errorHandler(error) {\n      if (error) {\n        // TODO: improve that in future\n        // For example - `writeToDisk` can throw an error and right now it is ends watching.\n        // We can improve that and keep watching active, but it is require API on webpack side.\n        // Let's implement that in webpack@5 because it is rare case.\n        context.logger.error(error);\n      }\n    };\n\n    if (Array.isArray(\n    /** @type {MultiCompiler} */\n    context.compiler.compilers)) {\n      watchOptions =\n      /** @type {MultiCompiler} */\n      context.compiler.compilers.map(\n      /**\n       * @param {Compiler} childCompiler\n       * @returns {WatchOptions}\n       */\n      function (childCompiler) {\n        return childCompiler.options.watchOptions || {};\n      });\n      context.watching =\n      /** @type {MultiWatching} */\n      context.compiler.watch(\n      /** @type {WatchOptions}} */\n      watchOptions, errorHandler);\n    } else {\n      watchOptions =\n      /** @type {Compiler} */\n      context.compiler.options.watchOptions || {};\n      context.watching =\n      /** @type {Watching} */\n      context.compiler.watch(watchOptions, errorHandler);\n    }\n  }\n\n  var instance =\n  /** @type {API<Request, Response>} */\n  middleware(context); // API\n\n  /** @type {API<Request, Response>} */\n\n  instance.getFilenameFromUrl =\n  /**\n   * @param {string} url\n   * @returns {string|undefined}\n   */\n  function (url) {\n    return getFilenameFromUrl(context, url);\n  };\n  /** @type {API<Request, Response>} */\n\n\n  instance.waitUntilValid = function () {\n    var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;\n    ready(context, callback);\n  };\n  /** @type {API<Request, Response>} */\n\n\n  instance.invalidate = function () {\n    var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;\n    ready(context, callback);\n    context.watching.invalidate();\n  };\n  /** @type {API<Request, Response>} */\n\n\n  instance.close = function () {\n    var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;\n    context.watching.close(callback);\n  };\n  /** @type {API<Request, Response>} */\n\n\n  instance.context = context;\n  return instance;\n}\n\nmodule.exports = wdm;","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/webpack-dev-middleware/dist/index.js"],"names":["require","validate","mime","middleware","getFilenameFromUrl","setupHooks","setupWriteToDisk","setupOutputFileSystem","ready","schema","noop","wdm","compiler","options","name","baseDataPath","mimeTypes","types","context","state","stats","undefined","callbacks","watching","logger","getInfrastructureLogger","outputFileSystem","writeToDisk","watchOptions","errorHandler","error","Array","isArray","compilers","map","childCompiler","watch","instance","url","waitUntilValid","callback","invalidate","close","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst {\n  validate\n} = require(\"schema-utils\");\n\nconst mime = require(\"mime-types\");\n\nconst middleware = require(\"./middleware\");\n\nconst getFilenameFromUrl = require(\"./utils/getFilenameFromUrl\");\n\nconst setupHooks = require(\"./utils/setupHooks\");\n\nconst setupWriteToDisk = require(\"./utils/setupWriteToDisk\");\n\nconst setupOutputFileSystem = require(\"./utils/setupOutputFileSystem\");\n\nconst ready = require(\"./utils/ready\");\n\nconst schema = require(\"./options.json\");\n\nconst noop = () => {};\n/** @typedef {import(\"schema-utils/declarations/validate\").Schema} Schema */\n\n/** @typedef {import(\"webpack\").Compiler} Compiler */\n\n/** @typedef {import(\"webpack\").MultiCompiler} MultiCompiler */\n\n/** @typedef {import(\"webpack\").Configuration} Configuration */\n\n/** @typedef {import(\"webpack\").Stats} Stats */\n\n/** @typedef {import(\"webpack\").MultiStats} MultiStats */\n\n/**\n * @typedef {Object} ExtendedServerResponse\n * @property {{ webpack?: { devMiddleware?: Context<IncomingMessage, ServerResponse> } }} [locals]\n */\n\n/** @typedef {import(\"http\").IncomingMessage} IncomingMessage */\n\n/** @typedef {import(\"http\").ServerResponse & ExtendedServerResponse} ServerResponse */\n\n/**\n * @callback NextFunction\n * @param {any} [err]\n * @return {void}\n */\n\n/**\n * @typedef {NonNullable<Configuration[\"watchOptions\"]>} WatchOptions\n */\n\n/**\n * @typedef {Compiler[\"watching\"]} Watching\n */\n\n/**\n * @typedef {ReturnType<Compiler[\"watch\"]>} MultiWatching\n */\n\n/**\n * @typedef {Compiler[\"outputFileSystem\"] & { createReadStream?: import(\"fs\").createReadStream, statSync?: import(\"fs\").statSync, lstat?: import(\"fs\").lstat, readFileSync?: import(\"fs\").readFileSync }} OutputFileSystem\n */\n\n/** @typedef {ReturnType<Compiler[\"getInfrastructureLogger\"]>} Logger */\n\n/**\n * @callback Callback\n * @param {Stats | MultiStats} [stats]\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Object} Context\n * @property {boolean} state\n * @property {Stats | MultiStats | undefined} stats\n * @property {Callback[]} callbacks\n * @property {Options<Request, Response>} options\n * @property {Compiler | MultiCompiler} compiler\n * @property {Watching | MultiWatching} watching\n * @property {Logger} logger\n * @property {OutputFileSystem} outputFileSystem\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Record<string, string | number> | Array<{ key: string, value: number | string }> | ((req: Request, res: Response, context: Context<Request, Response>) =>  void | undefined | Record<string, string | number>) | undefined} Headers\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Object} Options\n * @property {{[key: string]: string}} [mimeTypes]\n * @property {boolean | ((targetPath: string) => boolean)} [writeToDisk]\n * @property {string} [methods]\n * @property {Headers<Request, Response>} [headers]\n * @property {NonNullable<Configuration[\"output\"]>[\"publicPath\"]} [publicPath]\n * @property {Configuration[\"stats\"]} [stats]\n * @property {boolean} [serverSideRender]\n * @property {OutputFileSystem} [outputFileSystem]\n * @property {boolean | string} [index]\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @callback Middleware\n * @param {Request} req\n * @param {Response} res\n * @param {NextFunction} next\n * @return {Promise<void>}\n */\n\n/**\n * @callback GetFilenameFromUrl\n * @param {string} url\n * @returns {string | undefined}\n */\n\n/**\n * @callback WaitUntilValid\n * @param {Callback} callback\n */\n\n/**\n * @callback Invalidate\n * @param {Callback} callback\n */\n\n/**\n * @callback Close\n * @param {(err: Error | null | undefined) => void} callback\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Object} AdditionalMethods\n * @property {GetFilenameFromUrl} getFilenameFromUrl\n * @property {WaitUntilValid} waitUntilValid\n * @property {Invalidate} invalidate\n * @property {Close} close\n * @property {Context<Request, Response>} context\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Middleware<Request, Response> & AdditionalMethods<Request, Response>} API\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @param {Compiler | MultiCompiler} compiler\n * @param {Options<Request, Response>} [options]\n * @returns {API<Request, Response>}\n */\n\n\nfunction wdm(compiler, options = {}) {\n  validate(\n  /** @type {Schema} */\n  schema, options, {\n    name: \"Dev Middleware\",\n    baseDataPath: \"options\"\n  });\n  const {\n    mimeTypes\n  } = options;\n\n  if (mimeTypes) {\n    const {\n      types\n    } = mime; // mimeTypes from user provided options should take priority\n    // over existing, known types\n    // @ts-ignore\n\n    mime.types = { ...types,\n      ...mimeTypes\n    };\n  }\n  /**\n   * @type {Context<Request, Response>}\n   */\n\n\n  const context = {\n    state: false,\n    // eslint-disable-next-line no-undefined\n    stats: undefined,\n    callbacks: [],\n    options,\n    compiler,\n    // @ts-ignore\n    // eslint-disable-next-line no-undefined\n    watching: undefined,\n    logger: compiler.getInfrastructureLogger(\"webpack-dev-middleware\"),\n    // @ts-ignore\n    // eslint-disable-next-line no-undefined\n    outputFileSystem: undefined\n  };\n  setupHooks(context);\n\n  if (options.writeToDisk) {\n    setupWriteToDisk(context);\n  }\n\n  setupOutputFileSystem(context); // Start watching\n\n  if (\n  /** @type {Compiler} */\n  context.compiler.watching) {\n    context.watching =\n    /** @type {Compiler} */\n    context.compiler.watching;\n  } else {\n    /**\n     * @type {WatchOptions | WatchOptions[]}\n     */\n    let watchOptions;\n    /**\n     * @param {Error | null | undefined} error\n     */\n\n    const errorHandler = error => {\n      if (error) {\n        // TODO: improve that in future\n        // For example - `writeToDisk` can throw an error and right now it is ends watching.\n        // We can improve that and keep watching active, but it is require API on webpack side.\n        // Let's implement that in webpack@5 because it is rare case.\n        context.logger.error(error);\n      }\n    };\n\n    if (Array.isArray(\n    /** @type {MultiCompiler} */\n    context.compiler.compilers)) {\n      watchOptions =\n      /** @type {MultiCompiler} */\n      context.compiler.compilers.map(\n      /**\n       * @param {Compiler} childCompiler\n       * @returns {WatchOptions}\n       */\n      childCompiler => childCompiler.options.watchOptions || {});\n      context.watching =\n      /** @type {MultiWatching} */\n      context.compiler.watch(\n      /** @type {WatchOptions}} */\n      watchOptions, errorHandler);\n    } else {\n      watchOptions =\n      /** @type {Compiler} */\n      context.compiler.options.watchOptions || {};\n      context.watching =\n      /** @type {Watching} */\n      context.compiler.watch(watchOptions, errorHandler);\n    }\n  }\n\n  const instance =\n  /** @type {API<Request, Response>} */\n  middleware(context); // API\n\n  /** @type {API<Request, Response>} */\n\n  instance.getFilenameFromUrl =\n  /**\n   * @param {string} url\n   * @returns {string|undefined}\n   */\n  url => getFilenameFromUrl(context, url);\n  /** @type {API<Request, Response>} */\n\n\n  instance.waitUntilValid = (callback = noop) => {\n    ready(context, callback);\n  };\n  /** @type {API<Request, Response>} */\n\n\n  instance.invalidate = (callback = noop) => {\n    ready(context, callback);\n    context.watching.invalidate();\n  };\n  /** @type {API<Request, Response>} */\n\n\n  instance.close = (callback = noop) => {\n    context.watching.close(callback);\n  };\n  /** @type {API<Request, Response>} */\n\n\n  instance.context = context;\n  return instance;\n}\n\nmodule.exports = wdm;"]},"metadata":{},"sourceType":"script"}