{"ast":null,"code":"\"use strict\";\n\nvar _typeof = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/typeof.js\").default;\n\nvar _slicedToArray = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _taggedTemplateLiteral = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\n\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17;\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.regexp.constructor.js\");\n\nrequire(\"core-js/modules/es.regexp.dot-all.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.regexp.sticky.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar error = {\n  message: function message(_ref) {\n    var schemaCode = _ref.schemaCode;\n    return (0, codegen_1.str)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"must match format \\\"\", \"\\\"\"])), schemaCode);\n  },\n  params: function params(_ref2) {\n    var schemaCode = _ref2.schemaCode;\n    return (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"{format: \", \"}\"])), schemaCode);\n  }\n};\nvar def = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error: error,\n  code: function code(cxt, ruleType) {\n    var gen = cxt.gen,\n        data = cxt.data,\n        $data = cxt.$data,\n        schema = cxt.schema,\n        schemaCode = cxt.schemaCode,\n        it = cxt.it;\n    var opts = it.opts,\n        errSchemaPath = it.errSchemaPath,\n        schemaEnv = it.schemaEnv,\n        self = it.self;\n    if (!opts.validateFormats) return;\n    if ($data) validate$DataFormat();else validateFormat();\n\n    function validate$DataFormat() {\n      var fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats\n      });\n      var fDef = gen.const(\"fDef\", (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), fmts, schemaCode));\n      var fType = gen.let(\"fType\");\n      var format = gen.let(\"format\"); // TODO simplify\n\n      gen.if((0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"typeof \", \" == \\\"object\\\" && !(\", \" instanceof RegExp)\"])), fDef, fDef), function () {\n        return gen.assign(fType, (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \".type || \\\"string\\\"\"])), fDef)).assign(format, (0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \".validate\"])), fDef));\n      }, function () {\n        return gen.assign(fType, (0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\\\"string\\\"\"])))).assign(format, fDef);\n      });\n      cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n\n      function unknownFmt() {\n        if (opts.strictSchema === false) return codegen_1.nil;\n        return (0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \" && !\", \"\"])), schemaCode, format);\n      }\n\n      function invalidFmt() {\n        var callFormat = schemaEnv.$async ? (0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"(\", \".async ? await \", \"(\", \") : \", \"(\", \"))\"])), fDef, format, data, format, data) : (0, codegen_1._)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\", \"(\", \")\"])), format, data);\n        var validData = (0, codegen_1._)(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"(typeof \", \" == \\\"function\\\" ? \", \" : \", \".test(\", \"))\"])), format, callFormat, format, data);\n        return (0, codegen_1._)(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"\", \" && \", \" !== true && \", \" === \", \" && !\", \"\"])), format, format, fType, ruleType, validData);\n      }\n    }\n\n    function validateFormat() {\n      var formatDef = self.formats[schema];\n\n      if (!formatDef) {\n        unknownFormat();\n        return;\n      }\n\n      if (formatDef === true) return;\n\n      var _getFormat = getFormat(formatDef),\n          _getFormat2 = _slicedToArray(_getFormat, 3),\n          fmtType = _getFormat2[0],\n          format = _getFormat2[1],\n          fmtRef = _getFormat2[2];\n\n      if (fmtType === ruleType) cxt.pass(validCondition());\n\n      function unknownFormat() {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg());\n          return;\n        }\n\n        throw new Error(unknownMsg());\n\n        function unknownMsg() {\n          return \"unknown format \\\"\".concat(schema, \"\\\" ignored in schema at path \\\"\").concat(errSchemaPath, \"\\\"\");\n        }\n      }\n\n      function getFormat(fmtDef) {\n        var code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"\", \"\", \"\"])), opts.code.formats, (0, codegen_1.getProperty)(schema)) : undefined;\n        var fmt = gen.scopeValue(\"formats\", {\n          key: schema,\n          ref: fmtDef,\n          code: code\n        });\n\n        if (_typeof(fmtDef) == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, (0, codegen_1._)(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"\", \".validate\"])), fmt)];\n        }\n\n        return [\"string\", fmtDef, fmt];\n      }\n\n      function validCondition() {\n        if (_typeof(formatDef) == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\");\n          return (0, codegen_1._)(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral([\"await \", \"(\", \")\"])), fmtRef, data);\n        }\n\n        return typeof format == \"function\" ? (0, codegen_1._)(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral([\"\", \"(\", \")\"])), fmtRef, data) : (0, codegen_1._)(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral([\"\", \".test(\", \")\"])), fmtRef, data);\n      }\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","schemaCode","params","def","keyword","type","schemaType","$data","code","cxt","ruleType","gen","data","schema","it","opts","errSchemaPath","schemaEnv","self","validateFormats","validate$DataFormat","validateFormat","fmts","scopeValue","ref","formats","fDef","const","fType","let","format","if","assign","fail$data","unknownFmt","invalidFmt","strictSchema","codegen_1","callFormat","$async","validData","formatDef","unknownFormat","getFormat","fmtType","fmtRef","pass","validCondition","logger","warn","unknownMsg","Error","fmtDef","RegExp","undefined","fmt","key","validate","async","exports"],"sourceRoot":"","sources":["../../../lib/vocabularies/format/format.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}