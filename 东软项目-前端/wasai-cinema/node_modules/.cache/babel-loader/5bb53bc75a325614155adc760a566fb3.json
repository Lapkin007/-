{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _createClass = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _classCallCheck = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.string.match.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"regenerator-runtime/runtime.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HttpProxyMiddleware = void 0;\n\nvar httpProxy = require(\"http-proxy\");\n\nvar config_factory_1 = require(\"./config-factory\");\n\nvar contextMatcher = require(\"./context-matcher\");\n\nvar handlers = require(\"./_handlers\");\n\nvar logger_1 = require(\"./logger\");\n\nvar PathRewriter = require(\"./path-rewriter\");\n\nvar Router = require(\"./router\");\n\nvar HttpProxyMiddleware = /*#__PURE__*/_createClass(function HttpProxyMiddleware(context, opts) {\n  var _this = this;\n\n  _classCallCheck(this, HttpProxyMiddleware);\n\n  this.logger = (0, logger_1.getInstance)();\n  this.wsInternalSubscribed = false;\n  this.serverOnCloseSubscribed = false; // https://github.com/Microsoft/TypeScript/wiki/'this'-in-TypeScript#red-flags-for-this\n\n  this.middleware = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(req, res, next) {\n      var _a, _b, activeProxyOptions, server;\n\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!_this.shouldProxy(_this.config.context, req)) {\n                _context.next = 13;\n                break;\n              }\n\n              _context.prev = 1;\n              _context.next = 4;\n              return _this.prepareProxyRequest(req);\n\n            case 4:\n              activeProxyOptions = _context.sent;\n\n              _this.proxy.web(req, res, activeProxyOptions);\n\n              _context.next = 11;\n              break;\n\n            case 8:\n              _context.prev = 8;\n              _context.t0 = _context[\"catch\"](1);\n              next(_context.t0);\n\n            case 11:\n              _context.next = 14;\n              break;\n\n            case 13:\n              next();\n\n            case 14:\n              /**\n               * Get the server object to subscribe to server events;\n               * 'upgrade' for websocket and 'close' for graceful shutdown\n               *\n               * NOTE:\n               * req.socket: node >= 13\n               * req.connection: node < 13 (Remove this when node 12/13 support is dropped)\n               */\n              server = (_b = (_a = req.socket) !== null && _a !== void 0 ? _a : req.connection) === null || _b === void 0 ? void 0 : _b.server;\n\n              if (server && !_this.serverOnCloseSubscribed) {\n                server.on('close', function () {\n                  _this.logger.info('[HPM] server close signal received: closing proxy server');\n\n                  _this.proxy.close();\n                });\n                _this.serverOnCloseSubscribed = true;\n              }\n\n              if (_this.proxyOptions.ws === true) {\n                // use initial request to access the server object to subscribe to http upgrade event\n                _this.catchUpgradeRequest(server);\n              }\n\n            case 17:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[1, 8]]);\n    }));\n\n    return function (_x, _x2, _x3) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  this.catchUpgradeRequest = function (server) {\n    if (!_this.wsInternalSubscribed) {\n      server.on('upgrade', _this.handleUpgrade); // prevent duplicate upgrade handling;\n      // in case external upgrade is also configured\n\n      _this.wsInternalSubscribed = true;\n    }\n  };\n\n  this.handleUpgrade = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(req, socket, head) {\n      var activeProxyOptions;\n      return regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!_this.shouldProxy(_this.config.context, req)) {\n                _context2.next = 6;\n                break;\n              }\n\n              _context2.next = 3;\n              return _this.prepareProxyRequest(req);\n\n            case 3:\n              activeProxyOptions = _context2.sent;\n\n              _this.proxy.ws(req, socket, head, activeProxyOptions);\n\n              _this.logger.info('[HPM] Upgrading to WebSocket');\n\n            case 6:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x4, _x5, _x6) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  /**\n   * Determine whether request should be proxied.\n   *\n   * @private\n   * @param  {String} context [description]\n   * @param  {Object} req     [description]\n   * @return {Boolean}\n   */\n\n\n  this.shouldProxy = function (context, req) {\n    var path = req.originalUrl || req.url;\n    return contextMatcher.match(context, path, req);\n  };\n  /**\n   * Apply option.router and option.pathRewrite\n   * Order matters:\n   *    Router uses original path for routing;\n   *    NOT the modified path, after it has been rewritten by pathRewrite\n   * @param {Object} req\n   * @return {Object} proxy options\n   */\n\n\n  this.prepareProxyRequest = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(req) {\n      var originalPath, newProxyOptions, arrow;\n      return regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              // https://github.com/chimurai/http-proxy-middleware/issues/17\n              // https://github.com/chimurai/http-proxy-middleware/issues/94\n              req.url = req.originalUrl || req.url; // store uri before it gets rewritten for logging\n\n              originalPath = req.url;\n              newProxyOptions = Object.assign({}, _this.proxyOptions); // Apply in order:\n              // 1. option.router\n              // 2. option.pathRewrite\n\n              _context3.next = 5;\n              return _this.applyRouter(req, newProxyOptions);\n\n            case 5:\n              _context3.next = 7;\n              return _this.applyPathRewrite(req, _this.pathRewriter);\n\n            case 7:\n              // debug logging for both http(s) and websockets\n              if (_this.proxyOptions.logLevel === 'debug') {\n                arrow = (0, logger_1.getArrow)(originalPath, req.url, _this.proxyOptions.target, newProxyOptions.target);\n\n                _this.logger.debug('[HPM] %s %s %s %s', req.method, originalPath, arrow, newProxyOptions.target);\n              }\n\n              return _context3.abrupt(\"return\", newProxyOptions);\n\n            case 9:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function (_x7) {\n      return _ref3.apply(this, arguments);\n    };\n  }(); // Modify option.target when router present.\n\n\n  this.applyRouter = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(req, options) {\n      var newTarget;\n      return regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              if (!options.router) {\n                _context4.next = 5;\n                break;\n              }\n\n              _context4.next = 3;\n              return Router.getTarget(req, options);\n\n            case 3:\n              newTarget = _context4.sent;\n\n              if (newTarget) {\n                _this.logger.debug('[HPM] Router new target: %s -> \"%s\"', options.target, newTarget);\n\n                options.target = newTarget;\n              }\n\n            case 5:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function (_x8, _x9) {\n      return _ref4.apply(this, arguments);\n    };\n  }(); // rewrite path\n\n\n  this.applyPathRewrite = /*#__PURE__*/function () {\n    var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(req, pathRewriter) {\n      var path;\n      return regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!pathRewriter) {\n                _context5.next = 5;\n                break;\n              }\n\n              _context5.next = 3;\n              return pathRewriter(req.url, req);\n\n            case 3:\n              path = _context5.sent;\n\n              if (typeof path === 'string') {\n                req.url = path;\n              } else {\n                _this.logger.info('[HPM] pathRewrite: No rewritten path found. (%s)', req.url);\n              }\n\n            case 5:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n\n    return function (_x10, _x11) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n\n  this.logError = function (err, req, res, target) {\n    var _a;\n\n    var hostname = ((_a = req.headers) === null || _a === void 0 ? void 0 : _a.host) || req.hostname || req.host; // (websocket) || (node0.10 || node 4/5)\n\n    var requestHref = \"\".concat(hostname).concat(req.url);\n    var targetHref = \"\".concat(target === null || target === void 0 ? void 0 : target.href); // target is undefined when websocket errors\n\n    var errorMessage = '[HPM] Error occurred while proxying request %s to %s [%s] (%s)';\n    var errReference = 'https://nodejs.org/api/errors.html#errors_common_system_errors'; // link to Node Common Systems Errors page\n\n    _this.logger.error(errorMessage, requestHref, targetHref, err.code || err, errReference);\n  };\n\n  this.config = (0, config_factory_1.createConfig)(context, opts);\n  this.proxyOptions = this.config.options; // create proxy\n\n  this.proxy = httpProxy.createProxyServer({});\n  this.logger.info(\"[HPM] Proxy created: \".concat(this.config.context, \"  -> \").concat(this.proxyOptions.target));\n  this.pathRewriter = PathRewriter.createPathRewriter(this.proxyOptions.pathRewrite); // returns undefined when \"pathRewrite\" is not provided\n  // attach handler to http-proxy events\n\n  handlers.init(this.proxy, this.proxyOptions); // log errors for debug purpose\n\n  this.proxy.on('error', this.logError); // https://github.com/chimurai/http-proxy-middleware/issues/19\n  // expose function to upgrade externally\n\n  this.middleware.upgrade = function (req, socket, head) {\n    if (!_this.wsInternalSubscribed) {\n      _this.handleUpgrade(req, socket, head);\n    }\n  };\n});\n\nexports.HttpProxyMiddleware = HttpProxyMiddleware;","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/http-proxy-middleware/dist/http-proxy-middleware.js"],"names":["Object","defineProperty","exports","value","HttpProxyMiddleware","httpProxy","require","config_factory_1","contextMatcher","handlers","logger_1","PathRewriter","Router","context","opts","logger","getInstance","wsInternalSubscribed","serverOnCloseSubscribed","middleware","req","res","next","shouldProxy","config","prepareProxyRequest","activeProxyOptions","proxy","web","server","_b","_a","socket","connection","on","info","close","proxyOptions","ws","catchUpgradeRequest","handleUpgrade","head","path","originalUrl","url","match","originalPath","newProxyOptions","assign","applyRouter","applyPathRewrite","pathRewriter","logLevel","arrow","getArrow","target","debug","method","options","router","getTarget","newTarget","logError","err","hostname","headers","host","requestHref","targetHref","href","errorMessage","errReference","error","code","createConfig","createProxyServer","createPathRewriter","pathRewrite","init","upgrade"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HttpProxyMiddleware = void 0;\nconst httpProxy = require(\"http-proxy\");\nconst config_factory_1 = require(\"./config-factory\");\nconst contextMatcher = require(\"./context-matcher\");\nconst handlers = require(\"./_handlers\");\nconst logger_1 = require(\"./logger\");\nconst PathRewriter = require(\"./path-rewriter\");\nconst Router = require(\"./router\");\nclass HttpProxyMiddleware {\n    constructor(context, opts) {\n        this.logger = (0, logger_1.getInstance)();\n        this.wsInternalSubscribed = false;\n        this.serverOnCloseSubscribed = false;\n        // https://github.com/Microsoft/TypeScript/wiki/'this'-in-TypeScript#red-flags-for-this\n        this.middleware = async (req, res, next) => {\n            var _a, _b;\n            if (this.shouldProxy(this.config.context, req)) {\n                try {\n                    const activeProxyOptions = await this.prepareProxyRequest(req);\n                    this.proxy.web(req, res, activeProxyOptions);\n                }\n                catch (err) {\n                    next(err);\n                }\n            }\n            else {\n                next();\n            }\n            /**\n             * Get the server object to subscribe to server events;\n             * 'upgrade' for websocket and 'close' for graceful shutdown\n             *\n             * NOTE:\n             * req.socket: node >= 13\n             * req.connection: node < 13 (Remove this when node 12/13 support is dropped)\n             */\n            const server = (_b = ((_a = req.socket) !== null && _a !== void 0 ? _a : req.connection)) === null || _b === void 0 ? void 0 : _b.server;\n            if (server && !this.serverOnCloseSubscribed) {\n                server.on('close', () => {\n                    this.logger.info('[HPM] server close signal received: closing proxy server');\n                    this.proxy.close();\n                });\n                this.serverOnCloseSubscribed = true;\n            }\n            if (this.proxyOptions.ws === true) {\n                // use initial request to access the server object to subscribe to http upgrade event\n                this.catchUpgradeRequest(server);\n            }\n        };\n        this.catchUpgradeRequest = (server) => {\n            if (!this.wsInternalSubscribed) {\n                server.on('upgrade', this.handleUpgrade);\n                // prevent duplicate upgrade handling;\n                // in case external upgrade is also configured\n                this.wsInternalSubscribed = true;\n            }\n        };\n        this.handleUpgrade = async (req, socket, head) => {\n            if (this.shouldProxy(this.config.context, req)) {\n                const activeProxyOptions = await this.prepareProxyRequest(req);\n                this.proxy.ws(req, socket, head, activeProxyOptions);\n                this.logger.info('[HPM] Upgrading to WebSocket');\n            }\n        };\n        /**\n         * Determine whether request should be proxied.\n         *\n         * @private\n         * @param  {String} context [description]\n         * @param  {Object} req     [description]\n         * @return {Boolean}\n         */\n        this.shouldProxy = (context, req) => {\n            const path = req.originalUrl || req.url;\n            return contextMatcher.match(context, path, req);\n        };\n        /**\n         * Apply option.router and option.pathRewrite\n         * Order matters:\n         *    Router uses original path for routing;\n         *    NOT the modified path, after it has been rewritten by pathRewrite\n         * @param {Object} req\n         * @return {Object} proxy options\n         */\n        this.prepareProxyRequest = async (req) => {\n            // https://github.com/chimurai/http-proxy-middleware/issues/17\n            // https://github.com/chimurai/http-proxy-middleware/issues/94\n            req.url = req.originalUrl || req.url;\n            // store uri before it gets rewritten for logging\n            const originalPath = req.url;\n            const newProxyOptions = Object.assign({}, this.proxyOptions);\n            // Apply in order:\n            // 1. option.router\n            // 2. option.pathRewrite\n            await this.applyRouter(req, newProxyOptions);\n            await this.applyPathRewrite(req, this.pathRewriter);\n            // debug logging for both http(s) and websockets\n            if (this.proxyOptions.logLevel === 'debug') {\n                const arrow = (0, logger_1.getArrow)(originalPath, req.url, this.proxyOptions.target, newProxyOptions.target);\n                this.logger.debug('[HPM] %s %s %s %s', req.method, originalPath, arrow, newProxyOptions.target);\n            }\n            return newProxyOptions;\n        };\n        // Modify option.target when router present.\n        this.applyRouter = async (req, options) => {\n            let newTarget;\n            if (options.router) {\n                newTarget = await Router.getTarget(req, options);\n                if (newTarget) {\n                    this.logger.debug('[HPM] Router new target: %s -> \"%s\"', options.target, newTarget);\n                    options.target = newTarget;\n                }\n            }\n        };\n        // rewrite path\n        this.applyPathRewrite = async (req, pathRewriter) => {\n            if (pathRewriter) {\n                const path = await pathRewriter(req.url, req);\n                if (typeof path === 'string') {\n                    req.url = path;\n                }\n                else {\n                    this.logger.info('[HPM] pathRewrite: No rewritten path found. (%s)', req.url);\n                }\n            }\n        };\n        this.logError = (err, req, res, target) => {\n            var _a;\n            const hostname = ((_a = req.headers) === null || _a === void 0 ? void 0 : _a.host) || req.hostname || req.host; // (websocket) || (node0.10 || node 4/5)\n            const requestHref = `${hostname}${req.url}`;\n            const targetHref = `${target === null || target === void 0 ? void 0 : target.href}`; // target is undefined when websocket errors\n            const errorMessage = '[HPM] Error occurred while proxying request %s to %s [%s] (%s)';\n            const errReference = 'https://nodejs.org/api/errors.html#errors_common_system_errors'; // link to Node Common Systems Errors page\n            this.logger.error(errorMessage, requestHref, targetHref, err.code || err, errReference);\n        };\n        this.config = (0, config_factory_1.createConfig)(context, opts);\n        this.proxyOptions = this.config.options;\n        // create proxy\n        this.proxy = httpProxy.createProxyServer({});\n        this.logger.info(`[HPM] Proxy created: ${this.config.context}  -> ${this.proxyOptions.target}`);\n        this.pathRewriter = PathRewriter.createPathRewriter(this.proxyOptions.pathRewrite); // returns undefined when \"pathRewrite\" is not provided\n        // attach handler to http-proxy events\n        handlers.init(this.proxy, this.proxyOptions);\n        // log errors for debug purpose\n        this.proxy.on('error', this.logError);\n        // https://github.com/chimurai/http-proxy-middleware/issues/19\n        // expose function to upgrade externally\n        this.middleware.upgrade = (req, socket, head) => {\n            if (!this.wsInternalSubscribed) {\n                this.handleUpgrade(req, socket, head);\n            }\n        };\n    }\n}\nexports.HttpProxyMiddleware = HttpProxyMiddleware;\n"]},"metadata":{},"sourceType":"script"}