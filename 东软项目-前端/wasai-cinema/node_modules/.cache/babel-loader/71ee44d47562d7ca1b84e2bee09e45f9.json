{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nrequire(\"core-js/modules/es.map.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.set.js\");\n\nvar path = require(\"path\");\n/**\n * @template T\n * @typedef {Object} TreeNode\n * @property {string} filePath\n * @property {TreeNode} parent\n * @property {TreeNode[]} children\n * @property {number} entries\n * @property {boolean} active\n * @property {T[] | T | undefined} value\n */\n\n/**\n * @template T\n * @param {Map<string, T[] | T} plan\n * @param {number} limit\n * @returns {Map<string, Map<T, string>>} the new plan\n */\n\n\nmodule.exports = function (plan, limit) {\n  var treeMap = new Map(); // Convert to tree\n\n  var _iterator = _createForOfIteratorHelper(plan),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          filePath = _step$value[0],\n          value = _step$value[1];\n\n      treeMap.set(filePath, {\n        filePath: filePath,\n        parent: undefined,\n        children: undefined,\n        entries: 1,\n        active: true,\n        value: value\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var currentCount = treeMap.size; // Create parents and calculate sum of entries\n\n  var _iterator2 = _createForOfIteratorHelper(treeMap.values()),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _node2 = _step2.value;\n      var parentPath = path.dirname(_node2.filePath);\n\n      if (parentPath !== _node2.filePath) {\n        var _parent = treeMap.get(parentPath);\n\n        if (_parent === undefined) {\n          _parent = {\n            filePath: parentPath,\n            parent: undefined,\n            children: [_node2],\n            entries: _node2.entries,\n            active: false,\n            value: undefined\n          };\n          treeMap.set(parentPath, _parent);\n          _node2.parent = _parent;\n        } else {\n          _node2.parent = _parent;\n\n          if (_parent.children === undefined) {\n            _parent.children = [_node2];\n          } else {\n            _parent.children.push(_node2);\n          }\n\n          do {\n            _parent.entries += _node2.entries;\n            _parent = _parent.parent;\n          } while (_parent);\n        }\n      }\n    } // Reduce until limit reached\n\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  while (currentCount > limit) {\n    // Select node that helps reaching the limit most effectively without overmerging\n    var overLimit = currentCount - limit;\n    var bestNode = undefined;\n    var bestCost = Infinity;\n\n    var _iterator3 = _createForOfIteratorHelper(treeMap.values()),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var node = _step3.value;\n        if (node.entries <= 1 || !node.children || !node.parent) continue;\n        if (node.children.length === 0) continue;\n        if (node.children.length === 1 && !node.value) continue; // Try to select the node with has just a bit more entries than we need to reduce\n        // When just a bit more is over 30% over the limit,\n        // also consider just a bit less entries then we need to reduce\n\n        var cost = node.entries - 1 >= overLimit ? node.entries - 1 - overLimit : overLimit - node.entries + 1 + limit * 0.3;\n\n        if (cost < bestCost) {\n          bestNode = node;\n          bestCost = cost;\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    if (!bestNode) break; // Merge all children\n\n    var reduction = bestNode.entries - 1;\n    bestNode.active = true;\n    bestNode.entries = 1;\n    currentCount -= reduction;\n    var parent = bestNode.parent;\n\n    while (parent) {\n      parent.entries -= reduction;\n      parent = parent.parent;\n    }\n\n    var queue = new Set(bestNode.children);\n\n    var _iterator4 = _createForOfIteratorHelper(queue),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _node = _step4.value;\n        _node.active = false;\n        _node.entries = 0;\n\n        if (_node.children) {\n          var _iterator5 = _createForOfIteratorHelper(_node.children),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var child = _step5.value;\n              queue.add(child);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  } // Write down new plan\n\n\n  var newPlan = new Map();\n\n  var _iterator6 = _createForOfIteratorHelper(treeMap.values()),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var rootNode = _step6.value;\n      if (!rootNode.active) continue;\n      var map = new Map();\n\n      var _queue = new Set([rootNode]);\n\n      var _iterator7 = _createForOfIteratorHelper(_queue),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _node3 = _step7.value;\n          if (_node3.active && _node3 !== rootNode) continue;\n\n          if (_node3.value) {\n            if (Array.isArray(_node3.value)) {\n              var _iterator8 = _createForOfIteratorHelper(_node3.value),\n                  _step8;\n\n              try {\n                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                  var item = _step8.value;\n                  map.set(item, _node3.filePath);\n                }\n              } catch (err) {\n                _iterator8.e(err);\n              } finally {\n                _iterator8.f();\n              }\n            } else {\n              map.set(_node3.value, _node3.filePath);\n            }\n          }\n\n          if (_node3.children) {\n            var _iterator9 = _createForOfIteratorHelper(_node3.children),\n                _step9;\n\n            try {\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                var _child = _step9.value;\n\n                _queue.add(_child);\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      newPlan.set(rootNode.filePath, map);\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  return newPlan;\n};","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/watchpack/lib/reducePlan.js"],"names":["path","require","module","exports","plan","limit","treeMap","Map","filePath","value","set","parent","undefined","children","entries","active","currentCount","size","values","node","parentPath","dirname","get","push","overLimit","bestNode","bestCost","Infinity","length","cost","reduction","queue","Set","child","add","newPlan","rootNode","map","Array","isArray","item"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst path = require(\"path\");\n\n/**\n * @template T\n * @typedef {Object} TreeNode\n * @property {string} filePath\n * @property {TreeNode} parent\n * @property {TreeNode[]} children\n * @property {number} entries\n * @property {boolean} active\n * @property {T[] | T | undefined} value\n */\n\n/**\n * @template T\n * @param {Map<string, T[] | T} plan\n * @param {number} limit\n * @returns {Map<string, Map<T, string>>} the new plan\n */\nmodule.exports = (plan, limit) => {\n\tconst treeMap = new Map();\n\t// Convert to tree\n\tfor (const [filePath, value] of plan) {\n\t\ttreeMap.set(filePath, {\n\t\t\tfilePath,\n\t\t\tparent: undefined,\n\t\t\tchildren: undefined,\n\t\t\tentries: 1,\n\t\t\tactive: true,\n\t\t\tvalue\n\t\t});\n\t}\n\tlet currentCount = treeMap.size;\n\t// Create parents and calculate sum of entries\n\tfor (const node of treeMap.values()) {\n\t\tconst parentPath = path.dirname(node.filePath);\n\t\tif (parentPath !== node.filePath) {\n\t\t\tlet parent = treeMap.get(parentPath);\n\t\t\tif (parent === undefined) {\n\t\t\t\tparent = {\n\t\t\t\t\tfilePath: parentPath,\n\t\t\t\t\tparent: undefined,\n\t\t\t\t\tchildren: [node],\n\t\t\t\t\tentries: node.entries,\n\t\t\t\t\tactive: false,\n\t\t\t\t\tvalue: undefined\n\t\t\t\t};\n\t\t\t\ttreeMap.set(parentPath, parent);\n\t\t\t\tnode.parent = parent;\n\t\t\t} else {\n\t\t\t\tnode.parent = parent;\n\t\t\t\tif (parent.children === undefined) {\n\t\t\t\t\tparent.children = [node];\n\t\t\t\t} else {\n\t\t\t\t\tparent.children.push(node);\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tparent.entries += node.entries;\n\t\t\t\t\tparent = parent.parent;\n\t\t\t\t} while (parent);\n\t\t\t}\n\t\t}\n\t}\n\t// Reduce until limit reached\n\twhile (currentCount > limit) {\n\t\t// Select node that helps reaching the limit most effectively without overmerging\n\t\tconst overLimit = currentCount - limit;\n\t\tlet bestNode = undefined;\n\t\tlet bestCost = Infinity;\n\t\tfor (const node of treeMap.values()) {\n\t\t\tif (node.entries <= 1 || !node.children || !node.parent) continue;\n\t\t\tif (node.children.length === 0) continue;\n\t\t\tif (node.children.length === 1 && !node.value) continue;\n\t\t\t// Try to select the node with has just a bit more entries than we need to reduce\n\t\t\t// When just a bit more is over 30% over the limit,\n\t\t\t// also consider just a bit less entries then we need to reduce\n\t\t\tconst cost =\n\t\t\t\tnode.entries - 1 >= overLimit\n\t\t\t\t\t? node.entries - 1 - overLimit\n\t\t\t\t\t: overLimit - node.entries + 1 + limit * 0.3;\n\t\t\tif (cost < bestCost) {\n\t\t\t\tbestNode = node;\n\t\t\t\tbestCost = cost;\n\t\t\t}\n\t\t}\n\t\tif (!bestNode) break;\n\t\t// Merge all children\n\t\tconst reduction = bestNode.entries - 1;\n\t\tbestNode.active = true;\n\t\tbestNode.entries = 1;\n\t\tcurrentCount -= reduction;\n\t\tlet parent = bestNode.parent;\n\t\twhile (parent) {\n\t\t\tparent.entries -= reduction;\n\t\t\tparent = parent.parent;\n\t\t}\n\t\tconst queue = new Set(bestNode.children);\n\t\tfor (const node of queue) {\n\t\t\tnode.active = false;\n\t\t\tnode.entries = 0;\n\t\t\tif (node.children) {\n\t\t\t\tfor (const child of node.children) queue.add(child);\n\t\t\t}\n\t\t}\n\t}\n\t// Write down new plan\n\tconst newPlan = new Map();\n\tfor (const rootNode of treeMap.values()) {\n\t\tif (!rootNode.active) continue;\n\t\tconst map = new Map();\n\t\tconst queue = new Set([rootNode]);\n\t\tfor (const node of queue) {\n\t\t\tif (node.active && node !== rootNode) continue;\n\t\t\tif (node.value) {\n\t\t\t\tif (Array.isArray(node.value)) {\n\t\t\t\t\tfor (const item of node.value) {\n\t\t\t\t\t\tmap.set(item, node.filePath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmap.set(node.value, node.filePath);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.children) {\n\t\t\t\tfor (const child of node.children) {\n\t\t\t\t\tqueue.add(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnewPlan.set(rootNode.filePath, map);\n\t}\n\treturn newPlan;\n};\n"]},"metadata":{},"sourceType":"script"}