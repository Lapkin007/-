{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\n\nvar _templateObject, _templateObject2, _templateObject3;\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar util_1 = require(\"../../compile/util\");\n\nvar error = {\n  message: \"must match exactly one schema in oneOf\",\n  params: function params(_ref) {\n    var _params = _ref.params;\n    return (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"{passingSchemas: \", \"}\"])), _params.passing);\n  }\n};\nvar def = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error: error,\n  code: function code(cxt) {\n    var gen = cxt.gen,\n        schema = cxt.schema,\n        parentSchema = cxt.parentSchema,\n        it = cxt.it;\n    /* istanbul ignore if */\n\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n    if (it.opts.discriminator && parentSchema.discriminator) return;\n    var schArr = schema;\n    var valid = gen.let(\"valid\", false);\n    var passing = gen.let(\"passing\", null);\n    var schValid = gen.name(\"_valid\");\n    cxt.setParams({\n      passing: passing\n    }); // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf);\n    cxt.result(valid, function () {\n      return cxt.reset();\n    }, function () {\n      return cxt.error(true);\n    });\n\n    function validateOneOf() {\n      schArr.forEach(function (sch, i) {\n        var schCxt;\n\n        if ((0, util_1.alwaysValidSchema)(it, sch)) {\n          gen.var(schValid, true);\n        } else {\n          schCxt = cxt.subschema({\n            keyword: \"oneOf\",\n            schemaProp: i,\n            compositeRule: true\n          }, schValid);\n        }\n\n        if (i > 0) {\n          gen.if((0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \" && \", \"\"])), schValid, valid)).assign(valid, false).assign(passing, (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"[\", \", \", \"]\"])), passing, i)).else();\n        }\n\n        gen.if(schValid, function () {\n          gen.assign(valid, true);\n          gen.assign(passing, i);\n          if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1.Name);\n        });\n      });\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;AAOA;;AACA;;AASA,IAAMA,KAAK,GAA2B;AACpCC,SAAO,EAAE,wCAD2B;AAEpCC,QAAM,EAAE;AAAA,QAAEA,OAAF,QAAEA,MAAF;AAAA,YAAc,cAAd,6FAAmCA,OAAM,CAACC,OAA1C;AAAA;AAF4B,CAAtC;AAKA,IAAMC,GAAG,GAA0B;AACjCC,SAAO,EAAE,OADwB;AAEjCC,YAAU,EAAE,OAFqB;AAGjCC,aAAW,EAAE,IAHoB;AAIjCP,OAAK,EAALA,KAJiC;AAKjCQ,MALiC,gBAK5BC,GAL4B,EAKb;AAClB,QAAOC,GAAP,GAAwCD,GAAxC,CAAOC,GAAP;AAAA,QAAYC,MAAZ,GAAwCF,GAAxC,CAAYE,MAAZ;AAAA,QAAoBC,YAApB,GAAwCH,GAAxC,CAAoBG,YAApB;AAAA,QAAkCC,EAAlC,GAAwCJ,GAAxC,CAAkCI,EAAlC;AACA;;AACA,QAAI,CAACC,KAAK,CAACC,OAAN,CAAcJ,MAAd,CAAL,EAA4B,MAAM,IAAIK,KAAJ,CAAU,0BAAV,CAAN;AAC5B,QAAIH,EAAE,CAACI,IAAH,CAAQC,aAAR,IAAyBN,YAAY,CAACM,aAA1C,EAAyD;AACzD,QAAMC,MAAM,GAAgBR,MAA5B;AACA,QAAMS,KAAK,GAAGV,GAAG,CAACW,GAAJ,CAAQ,OAAR,EAAiB,KAAjB,CAAd;AACA,QAAMlB,OAAO,GAAGO,GAAG,CAACW,GAAJ,CAAQ,SAAR,EAAmB,IAAnB,CAAhB;AACA,QAAMC,QAAQ,GAAGZ,GAAG,CAACa,IAAJ,CAAS,QAAT,CAAjB;AACAd,OAAG,CAACe,SAAJ,CAAc;AAACrB,aAAO,EAAPA;AAAD,KAAd,EATkB,CAUlB;;AAEAO,OAAG,CAACe,KAAJ,CAAUC,aAAV;AAEAjB,OAAG,CAACkB,MAAJ,CACEP,KADF,EAEE;AAAA,aAAMX,GAAG,CAACmB,KAAJ,EAAN;AAAA,KAFF,EAGE;AAAA,aAAMnB,GAAG,CAACT,KAAJ,CAAU,IAAV,CAAN;AAAA,KAHF;;AAMA,aAAS0B,aAAT,GAAsB;AACpBP,YAAM,CAACU,OAAP,CAAe,UAACC,GAAD,EAAiBC,CAAjB,EAA8B;AAC3C,YAAIC,MAAJ;;AACA,YAAI,8BAAkBnB,EAAlB,EAAsBiB,GAAtB,CAAJ,EAAgC;AAC9BpB,aAAG,CAACuB,GAAJ,CAAQX,QAAR,EAAkB,IAAlB;AACD,SAFD,MAEO;AACLU,gBAAM,GAAGvB,GAAG,CAACyB,SAAJ,CACP;AACE7B,mBAAO,EAAE,OADX;AAEE8B,sBAAU,EAAEJ,CAFd;AAGEK,yBAAa,EAAE;AAHjB,WADO,EAMPd,QANO,CAAT;AAQD;;AAED,YAAIS,CAAC,GAAG,CAAR,EAAW;AACTrB,aAAG,CACA2B,EADH,EACM,cADN,qFACUf,QADV,EACyBF,KADzB,GAEGkB,MAFH,CAEUlB,KAFV,EAEiB,KAFjB,EAGGkB,MAHH,CAGUnC,OAHV,GAGmB,cAHnB,qFAGwBA,OAHxB,EAGoC4B,CAHpC,GAIGQ,IAJH;AAKD;;AAED7B,WAAG,CAAC2B,EAAJ,CAAOf,QAAP,EAAiB,YAAK;AACpBZ,aAAG,CAAC4B,MAAJ,CAAWlB,KAAX,EAAkB,IAAlB;AACAV,aAAG,CAAC4B,MAAJ,CAAWnC,OAAX,EAAoB4B,CAApB;AACA,cAAIC,MAAJ,EAAYvB,GAAG,CAAC+B,cAAJ,CAAmBR,MAAnB,EAA2BS,cAA3B;AACb,SAJD;AAKD,OA5BD;AA6BD;AACF;AAxDgC,CAAnC;AA2DAC,kBAAetC,GAAf","names":["error","message","params","passing","def","keyword","schemaType","trackErrors","code","cxt","gen","schema","parentSchema","it","Array","isArray","Error","opts","discriminator","schArr","valid","let","schValid","name","setParams","block","validateOneOf","result","reset","forEach","sch","i","schCxt","var","subschema","schemaProp","compositeRule","if","assign","else","mergeEvaluated","codegen_1","exports"],"sourceRoot":"","sources":["../../../lib/vocabularies/applicator/oneOf.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}