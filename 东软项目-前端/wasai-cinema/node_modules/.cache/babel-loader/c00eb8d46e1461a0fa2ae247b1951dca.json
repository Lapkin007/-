{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"regenerator-runtime/runtime.js\");\n\nvar isStream = require('is-stream');\n\nvar getStream = require('get-stream');\n\nvar mergeStream = require('merge-stream'); // `input` option\n\n\nvar handleInput = function handleInput(spawned, input) {\n  // Checking for stdin is workaround for https://github.com/nodejs/node/issues/26852\n  // @todo remove `|| spawned.stdin === undefined` once we drop support for Node.js <=12.2.0\n  if (input === undefined || spawned.stdin === undefined) {\n    return;\n  }\n\n  if (isStream(input)) {\n    input.pipe(spawned.stdin);\n  } else {\n    spawned.stdin.end(input);\n  }\n}; // `all` interleaves `stdout` and `stderr`\n\n\nvar makeAllStream = function makeAllStream(spawned, _ref) {\n  var all = _ref.all;\n\n  if (!all || !spawned.stdout && !spawned.stderr) {\n    return;\n  }\n\n  var mixed = mergeStream();\n\n  if (spawned.stdout) {\n    mixed.add(spawned.stdout);\n  }\n\n  if (spawned.stderr) {\n    mixed.add(spawned.stderr);\n  }\n\n  return mixed;\n}; // On failure, `result.stdout|stderr|all` should contain the currently buffered stream\n\n\nvar getBufferedData = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(stream, streamPromise) {\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (stream) {\n              _context.next = 2;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 2:\n            stream.destroy();\n            _context.prev = 3;\n            _context.next = 6;\n            return streamPromise;\n\n          case 6:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 9:\n            _context.prev = 9;\n            _context.t0 = _context[\"catch\"](3);\n            return _context.abrupt(\"return\", _context.t0.bufferedData);\n\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[3, 9]]);\n  }));\n\n  return function getBufferedData(_x, _x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar getStreamPromise = function getStreamPromise(stream, _ref3) {\n  var encoding = _ref3.encoding,\n      buffer = _ref3.buffer,\n      maxBuffer = _ref3.maxBuffer;\n\n  if (!stream || !buffer) {\n    return;\n  }\n\n  if (encoding) {\n    return getStream(stream, {\n      encoding: encoding,\n      maxBuffer: maxBuffer\n    });\n  }\n\n  return getStream.buffer(stream, {\n    maxBuffer: maxBuffer\n  });\n}; // Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)\n\n\nvar getSpawnedResult = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref4, _ref5, processDone) {\n    var stdout, stderr, all, encoding, buffer, maxBuffer, stdoutPromise, stderrPromise, allPromise;\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            stdout = _ref4.stdout, stderr = _ref4.stderr, all = _ref4.all;\n            encoding = _ref5.encoding, buffer = _ref5.buffer, maxBuffer = _ref5.maxBuffer;\n            stdoutPromise = getStreamPromise(stdout, {\n              encoding: encoding,\n              buffer: buffer,\n              maxBuffer: maxBuffer\n            });\n            stderrPromise = getStreamPromise(stderr, {\n              encoding: encoding,\n              buffer: buffer,\n              maxBuffer: maxBuffer\n            });\n            allPromise = getStreamPromise(all, {\n              encoding: encoding,\n              buffer: buffer,\n              maxBuffer: maxBuffer * 2\n            });\n            _context2.prev = 5;\n            _context2.next = 8;\n            return Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);\n\n          case 8:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 11:\n            _context2.prev = 11;\n            _context2.t0 = _context2[\"catch\"](5);\n            return _context2.abrupt(\"return\", Promise.all([{\n              error: _context2.t0,\n              signal: _context2.t0.signal,\n              timedOut: _context2.t0.timedOut\n            }, getBufferedData(stdout, stdoutPromise), getBufferedData(stderr, stderrPromise), getBufferedData(all, allPromise)]));\n\n          case 14:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[5, 11]]);\n  }));\n\n  return function getSpawnedResult(_x3, _x4, _x5) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nvar validateInputSync = function validateInputSync(_ref7) {\n  var input = _ref7.input;\n\n  if (isStream(input)) {\n    throw new TypeError('The `input` option cannot be a stream in sync mode');\n  }\n};\n\nmodule.exports = {\n  handleInput: handleInput,\n  makeAllStream: makeAllStream,\n  getSpawnedResult: getSpawnedResult,\n  validateInputSync: validateInputSync\n};","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/default-gateway/node_modules/execa/lib/stream.js"],"names":["isStream","require","getStream","mergeStream","handleInput","spawned","input","undefined","stdin","pipe","end","makeAllStream","all","stdout","stderr","mixed","add","getBufferedData","stream","streamPromise","destroy","bufferedData","getStreamPromise","encoding","buffer","maxBuffer","getSpawnedResult","processDone","stdoutPromise","stderrPromise","allPromise","Promise","error","signal","timedOut","validateInputSync","TypeError","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst isStream = require('is-stream');\nconst getStream = require('get-stream');\nconst mergeStream = require('merge-stream');\n\n// `input` option\nconst handleInput = (spawned, input) => {\n\t// Checking for stdin is workaround for https://github.com/nodejs/node/issues/26852\n\t// @todo remove `|| spawned.stdin === undefined` once we drop support for Node.js <=12.2.0\n\tif (input === undefined || spawned.stdin === undefined) {\n\t\treturn;\n\t}\n\n\tif (isStream(input)) {\n\t\tinput.pipe(spawned.stdin);\n\t} else {\n\t\tspawned.stdin.end(input);\n\t}\n};\n\n// `all` interleaves `stdout` and `stderr`\nconst makeAllStream = (spawned, {all}) => {\n\tif (!all || (!spawned.stdout && !spawned.stderr)) {\n\t\treturn;\n\t}\n\n\tconst mixed = mergeStream();\n\n\tif (spawned.stdout) {\n\t\tmixed.add(spawned.stdout);\n\t}\n\n\tif (spawned.stderr) {\n\t\tmixed.add(spawned.stderr);\n\t}\n\n\treturn mixed;\n};\n\n// On failure, `result.stdout|stderr|all` should contain the currently buffered stream\nconst getBufferedData = async (stream, streamPromise) => {\n\tif (!stream) {\n\t\treturn;\n\t}\n\n\tstream.destroy();\n\n\ttry {\n\t\treturn await streamPromise;\n\t} catch (error) {\n\t\treturn error.bufferedData;\n\t}\n};\n\nconst getStreamPromise = (stream, {encoding, buffer, maxBuffer}) => {\n\tif (!stream || !buffer) {\n\t\treturn;\n\t}\n\n\tif (encoding) {\n\t\treturn getStream(stream, {encoding, maxBuffer});\n\t}\n\n\treturn getStream.buffer(stream, {maxBuffer});\n};\n\n// Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)\nconst getSpawnedResult = async ({stdout, stderr, all}, {encoding, buffer, maxBuffer}, processDone) => {\n\tconst stdoutPromise = getStreamPromise(stdout, {encoding, buffer, maxBuffer});\n\tconst stderrPromise = getStreamPromise(stderr, {encoding, buffer, maxBuffer});\n\tconst allPromise = getStreamPromise(all, {encoding, buffer, maxBuffer: maxBuffer * 2});\n\n\ttry {\n\t\treturn await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);\n\t} catch (error) {\n\t\treturn Promise.all([\n\t\t\t{error, signal: error.signal, timedOut: error.timedOut},\n\t\t\tgetBufferedData(stdout, stdoutPromise),\n\t\t\tgetBufferedData(stderr, stderrPromise),\n\t\t\tgetBufferedData(all, allPromise)\n\t\t]);\n\t}\n};\n\nconst validateInputSync = ({input}) => {\n\tif (isStream(input)) {\n\t\tthrow new TypeError('The `input` option cannot be a stream in sync mode');\n\t}\n};\n\nmodule.exports = {\n\thandleInput,\n\tmakeAllStream,\n\tgetSpawnedResult,\n\tvalidateInputSync\n};\n\n"]},"metadata":{},"sourceType":"script"}