{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"E:/DW/wasai-cinema/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/es.weak-map.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.map.js\");\n\nrequire(\"core-js/modules/es.string.starts-with.js\");\n\nrequire(\"core-js/modules/es.array.join.js\");\n\nvar path = require(\"path\");\n\nvar _require = require(\"url\"),\n    parse = _require.parse;\n\nvar querystring = require(\"querystring\");\n\nvar getPaths = require(\"./getPaths\");\n/** @typedef {import(\"../index.js\").IncomingMessage} IncomingMessage */\n\n/** @typedef {import(\"../index.js\").ServerResponse} ServerResponse */\n\n\nvar cacheStore = new WeakMap();\n/**\n * @param {Function} fn\n * @param {{ cache?: Map<any, any> }} [cache]\n * @returns {any}\n */\n\nvar mem = function mem(fn) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$cache = _ref.cache,\n      cache = _ref$cache === void 0 ? new Map() : _ref$cache;\n\n  /**\n   * @param {any} arguments_\n   * @return {any}\n   */\n  var memoized = function memoized() {\n    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {\n      arguments_[_key] = arguments[_key];\n    }\n\n    var key = arguments_[0];\n    var cacheItem = cache.get(key);\n\n    if (cacheItem) {\n      return cacheItem.data;\n    }\n\n    var result = fn.apply(void 0, arguments_);\n    cache.set(key, {\n      data: result\n    });\n    return result;\n  };\n\n  cacheStore.set(memoized, cache);\n  return memoized;\n};\n\nvar memoizedParse = mem(parse);\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @param {import(\"../index.js\").Context<Request, Response>} context\n * @param {string} url\n * @returns {string | undefined}\n */\n\nfunction getFilenameFromUrl(context, url) {\n  var options = context.options;\n  var paths = getPaths(context);\n  var foundFilename;\n  var urlObject;\n\n  try {\n    // The `url` property of the `request` is contains only  `pathname`, `search` and `hash`\n    urlObject = memoizedParse(url, false, true);\n  } catch (_ignoreError) {\n    return;\n  }\n\n  var _iterator = _createForOfIteratorHelper(paths),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n          publicPath = _step$value.publicPath,\n          outputPath = _step$value.outputPath;\n      var filename = void 0;\n      var publicPathObject = void 0;\n\n      try {\n        publicPathObject = memoizedParse(publicPath !== \"auto\" && publicPath ? publicPath : \"/\", false, true);\n      } catch (_ignoreError) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (urlObject.pathname && urlObject.pathname.startsWith(publicPathObject.pathname)) {\n        filename = outputPath; // Strip the `pathname` property from the `publicPath` option from the start of requested url\n        // `/complex/foo.js` => `foo.js`\n\n        var pathname = urlObject.pathname.substr(publicPathObject.pathname.length);\n\n        if (pathname) {\n          filename = path.join(outputPath, querystring.unescape(pathname));\n        }\n\n        var fsStats = void 0;\n\n        try {\n          fsStats =\n          /** @type {import(\"fs\").statSync} */\n          context.outputFileSystem.statSync(filename);\n        } catch (_ignoreError) {\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n\n        if (fsStats.isFile()) {\n          foundFilename = filename;\n          break;\n        } else if (fsStats.isDirectory() && (typeof options.index === \"undefined\" || options.index)) {\n          var indexValue = typeof options.index === \"undefined\" || typeof options.index === \"boolean\" ? \"index.html\" : options.index;\n          filename = path.join(filename, indexValue);\n\n          try {\n            fsStats =\n            /** @type {import(\"fs\").statSync} */\n            context.outputFileSystem.statSync(filename);\n          } catch (__ignoreError) {\n            // eslint-disable-next-line no-continue\n            continue;\n          }\n\n          if (fsStats.isFile()) {\n            foundFilename = filename;\n            break;\n          }\n        }\n      }\n    } // eslint-disable-next-line consistent-return\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return foundFilename;\n}\n\nmodule.exports = getFilenameFromUrl;","map":{"version":3,"sources":["E:/DW/wasai-cinema/node_modules/webpack-dev-middleware/dist/utils/getFilenameFromUrl.js"],"names":["path","require","parse","querystring","getPaths","cacheStore","WeakMap","mem","fn","cache","Map","memoized","arguments_","key","cacheItem","get","data","result","apply","set","memoizedParse","getFilenameFromUrl","context","url","options","paths","foundFilename","urlObject","_ignoreError","publicPath","outputPath","filename","publicPathObject","pathname","startsWith","substr","length","join","unescape","fsStats","outputFileSystem","statSync","isFile","isDirectory","index","indexValue","__ignoreError","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst path = require(\"path\");\n\nconst {\n  parse\n} = require(\"url\");\n\nconst querystring = require(\"querystring\");\n\nconst getPaths = require(\"./getPaths\");\n/** @typedef {import(\"../index.js\").IncomingMessage} IncomingMessage */\n\n/** @typedef {import(\"../index.js\").ServerResponse} ServerResponse */\n\n\nconst cacheStore = new WeakMap();\n/**\n * @param {Function} fn\n * @param {{ cache?: Map<any, any> }} [cache]\n * @returns {any}\n */\n\nconst mem = (fn, {\n  cache = new Map()\n} = {}) => {\n  /**\n   * @param {any} arguments_\n   * @return {any}\n   */\n  const memoized = (...arguments_) => {\n    const [key] = arguments_;\n    const cacheItem = cache.get(key);\n\n    if (cacheItem) {\n      return cacheItem.data;\n    }\n\n    const result = fn.apply(void 0, arguments_);\n    cache.set(key, {\n      data: result\n    });\n    return result;\n  };\n\n  cacheStore.set(memoized, cache);\n  return memoized;\n};\n\nconst memoizedParse = mem(parse);\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @param {import(\"../index.js\").Context<Request, Response>} context\n * @param {string} url\n * @returns {string | undefined}\n */\n\nfunction getFilenameFromUrl(context, url) {\n  const {\n    options\n  } = context;\n  const paths = getPaths(context);\n  let foundFilename;\n  let urlObject;\n\n  try {\n    // The `url` property of the `request` is contains only  `pathname`, `search` and `hash`\n    urlObject = memoizedParse(url, false, true);\n  } catch (_ignoreError) {\n    return;\n  }\n\n  for (const {\n    publicPath,\n    outputPath\n  } of paths) {\n    let filename;\n    let publicPathObject;\n\n    try {\n      publicPathObject = memoizedParse(publicPath !== \"auto\" && publicPath ? publicPath : \"/\", false, true);\n    } catch (_ignoreError) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (urlObject.pathname && urlObject.pathname.startsWith(publicPathObject.pathname)) {\n      filename = outputPath; // Strip the `pathname` property from the `publicPath` option from the start of requested url\n      // `/complex/foo.js` => `foo.js`\n\n      const pathname = urlObject.pathname.substr(publicPathObject.pathname.length);\n\n      if (pathname) {\n        filename = path.join(outputPath, querystring.unescape(pathname));\n      }\n\n      let fsStats;\n\n      try {\n        fsStats =\n        /** @type {import(\"fs\").statSync} */\n        context.outputFileSystem.statSync(filename);\n      } catch (_ignoreError) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (fsStats.isFile()) {\n        foundFilename = filename;\n        break;\n      } else if (fsStats.isDirectory() && (typeof options.index === \"undefined\" || options.index)) {\n        const indexValue = typeof options.index === \"undefined\" || typeof options.index === \"boolean\" ? \"index.html\" : options.index;\n        filename = path.join(filename, indexValue);\n\n        try {\n          fsStats =\n          /** @type {import(\"fs\").statSync} */\n          context.outputFileSystem.statSync(filename);\n        } catch (__ignoreError) {\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n\n        if (fsStats.isFile()) {\n          foundFilename = filename;\n          break;\n        }\n      }\n    }\n  } // eslint-disable-next-line consistent-return\n\n\n  return foundFilename;\n}\n\nmodule.exports = getFilenameFromUrl;"]},"metadata":{},"sourceType":"script"}